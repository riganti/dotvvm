/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v10.0.6306.29915 (NJsonSchema v8.30.6304.31883) (http://NSwag.org)
// </auto-generated>
//----------------------


class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    emojis(x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Emojis> {
        let url_ = this.baseUrl + "/emojis";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEmojis(_response);
        });
    }

    protected processEmojis(_response: Response): Promise<Emojis> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Emojis = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Emojis.fromJS(resultData200) : new Emojis();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    events(x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Events> {
        let url_ = this.baseUrl + "/events";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEvents(_response);
        });
    }

    protected processEvents(_response: Response): Promise<Events> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Events = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Events.fromJS(resultData200) : new Events();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    feeds(x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Feeds> {
        let url_ = this.baseUrl + "/feeds";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFeeds(_response);
        });
    }

    protected processFeeds(_response: Response): Promise<Feeds> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Feeds = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Feeds.fromJS(resultData200) : new Feeds();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @since Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
Only gists updated at or after this time are returned.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    gistsAll(since: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous[]> {
        let url_ = this.baseUrl + "/gists?";
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGistsAll(_response);
        });
    }

    protected processGistsAll(_response: Response): Promise<Anonymous[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    gists(x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: PostGist): Promise<Gist> {
        let url_ = this.baseUrl + "/gists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGists(_response);
        });
    }

    protected processGists(_response: Response): Promise<Gist> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            let result201: Gist = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Gist.fromJS(resultData201) : new Gist();
            return result201;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @since Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
Only gists updated at or after this time are returned.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    publicAll(since: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous[]> {
        let url_ = this.baseUrl + "/gists/public?";
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPublicAll(_response);
        });
    }

    protected processPublicAll(_response: Response): Promise<Anonymous[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @since Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
Only gists updated at or after this time are returned.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    starredAll(since: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous[]> {
        let url_ = this.baseUrl + "/gists/starred?";
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStarredAll(_response);
        });
    }

    protected processStarredAll(_response: Response): Promise<Anonymous[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @id Id of gist.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    gists2(id: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/gists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGists2(_response);
        });
    }

    protected processGists2(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @id Id of gist.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    gists3(id: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Gist> {
        let url_ = this.baseUrl + "/gists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGists3(_response);
        });
    }

    protected processGists3(_response: Response): Promise<Gist> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Gist = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Gist.fromJS(resultData200) : new Gist();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @id Id of gist.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    gists4(id: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: PatchGist): Promise<Gist> {
        let url_ = this.baseUrl + "/gists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGists4(_response);
        });
    }

    protected processGists4(_response: Response): Promise<Gist> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Gist = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Gist.fromJS(resultData200) : new Gist();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @id Id of gist.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    commentsAll(id: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous2[]> {
        let url_ = this.baseUrl + "/gists/{id}/comments";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCommentsAll(_response);
        });
    }

    protected processCommentsAll(_response: Response): Promise<Anonymous2[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous2[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous2.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @id Id of gist.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    comments(id: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: CommentBody): Promise<Comment> {
        let url_ = this.baseUrl + "/gists/{id}/comments";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComments(_response);
        });
    }

    protected processComments(_response: Response): Promise<Comment> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            let result201: Comment = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Comment.fromJS(resultData201) : new Comment();
            return result201;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @id Id of gist.
     * @commentId Id of comment.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    comments2(id: number, commentId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/gists/{id}/comments/{commentId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComments2(_response);
        });
    }

    protected processComments2(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @id Id of gist.
     * @commentId Id of comment.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments3(id: number, commentId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Comment> {
        let url_ = this.baseUrl + "/gists/{id}/comments/{commentId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComments3(_response);
        });
    }

    protected processComments3(_response: Response): Promise<Comment> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Comment = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Comment.fromJS(resultData200) : new Comment();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @id Id of gist.
     * @commentId Id of comment.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments4(id: number, commentId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: Comment): Promise<Comment> {
        let url_ = this.baseUrl + "/gists/{id}/comments/{commentId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComments4(_response);
        });
    }

    protected processComments4(_response: Response): Promise<Comment> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Comment = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Comment.fromJS(resultData200) : new Comment();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @id Id of gist.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Exists.
     */
    forks(id: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/gists/{id}/forks";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForks(_response);
        });
    }

    protected processForks(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status === 404) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @id Id of gist.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Item removed.
     */
    star(id: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/gists/{id}/star";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStar(_response);
        });
    }

    protected processStar(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @id Id of gist.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Exists.
     */
    star2(id: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/gists/{id}/star";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStar2(_response);
        });
    }

    protected processStar2(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status === 404) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @id Id of gist.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Starred.
     */
    star3(id: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/gists/{id}/star";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStar3(_response);
        });
    }

    protected processStar3(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    templatesAll(x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<any[]> {
        let url_ = this.baseUrl + "/gitignore/templates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTemplatesAll(_response);
        });
    }

    protected processTemplatesAll(_response: Response): Promise<any[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: any[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    templates(language: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<GitignoreLang> {
        let url_ = this.baseUrl + "/gitignore/templates/{language}";
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined.");
        url_ = url_.replace("{language}", encodeURIComponent("" + language)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTemplates(_response);
        });
    }

    protected processTemplates(_response: Response): Promise<GitignoreLang> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: GitignoreLang = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GitignoreLang.fromJS(resultData200) : new GitignoreLang();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @filter Issues assigned to you / created by you / mentioning you / you're
subscribed to updates for / All issues the authenticated user can see
     * @labels String list of comma separated Label names. Example - bug,ui,@high.
     * @since Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
Only issues updated at or after this time are returned.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    issuesAll(filter: Filter, state: State, labels: string, sort: Sort, direction: Direction, since: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous3[]> {
        let url_ = this.baseUrl + "/issues?";
        if (filter === undefined || filter === null)
            throw new Error("The parameter 'filter' must be defined and cannot be null.");
        else
            url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
        if (state === undefined || state === null)
            throw new Error("The parameter 'state' must be defined and cannot be null.");
        else
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        if (labels === undefined || labels === null)
            throw new Error("The parameter 'labels' must be defined and cannot be null.");
        else
            url_ += "labels=" + encodeURIComponent("" + labels) + "&"; 
        if (sort === undefined || sort === null)
            throw new Error("The parameter 'sort' must be defined and cannot be null.");
        else
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        if (direction === undefined || direction === null)
            throw new Error("The parameter 'direction' must be defined and cannot be null.");
        else
            url_ += "direction=" + encodeURIComponent("" + direction) + "&"; 
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIssuesAll(_response);
        });
    }

    protected processIssuesAll(_response: Response): Promise<Anonymous3[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous3[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous3.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @keyword The search term.
     * @state Indicates the state of the issues to return. Can be either open or closed.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    search(keyword: string, state: State2, owner: string, repository: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<SearchIssuesByKeyword> {
        let url_ = this.baseUrl + "/legacy/issues/search/{owner}/{repository}/{state}/{keyword}";
        if (keyword === undefined || keyword === null)
            throw new Error("The parameter 'keyword' must be defined.");
        url_ = url_.replace("{keyword}", encodeURIComponent("" + keyword)); 
        if (state === undefined || state === null)
            throw new Error("The parameter 'state' must be defined.");
        url_ = url_.replace("{state}", encodeURIComponent("" + state)); 
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repository === undefined || repository === null)
            throw new Error("The parameter 'repository' must be defined.");
        url_ = url_.replace("{repository}", encodeURIComponent("" + repository)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(_response: Response): Promise<SearchIssuesByKeyword> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: SearchIssuesByKeyword = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SearchIssuesByKeyword.fromJS(resultData200) : new SearchIssuesByKeyword();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @keyword The search term
     * @order The sort field. if sort param is provided. Can be either asc or desc.
     * @language Filter results by language
     * @start_page The page number to fetch
     * @sort The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    search2(keyword: string, order: Order, language: string, start_page: string, sort: Sort2, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<SearchRepositoriesByKeyword> {
        let url_ = this.baseUrl + "/legacy/repos/search/{keyword}?";
        if (keyword === undefined || keyword === null)
            throw new Error("The parameter 'keyword' must be defined.");
        url_ = url_.replace("{keyword}", encodeURIComponent("" + keyword)); 
        if (order !== undefined)
            url_ += "order=" + encodeURIComponent("" + order) + "&"; 
        if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&"; 
        if (start_page !== undefined)
            url_ += "start_page=" + encodeURIComponent("" + start_page) + "&"; 
        if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch2(_response);
        });
    }

    protected processSearch2(_response: Response): Promise<SearchRepositoriesByKeyword> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: SearchRepositoriesByKeyword = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SearchRepositoriesByKeyword.fromJS(resultData200) : new SearchRepositoriesByKeyword();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @email The email address
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    email(email: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<SearchUserByEmail> {
        let url_ = this.baseUrl + "/legacy/user/email/{email}";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEmail(_response);
        });
    }

    protected processEmail(_response: Response): Promise<SearchUserByEmail> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: SearchUserByEmail = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SearchUserByEmail.fromJS(resultData200) : new SearchUserByEmail();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @keyword The search term
     * @order The sort field. if sort param is provided. Can be either asc or desc.
     * @start_page The page number to fetch
     * @sort The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    search3(keyword: string, order: Order2, start_page: string, sort: Sort3, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<SearchUsersByKeyword> {
        let url_ = this.baseUrl + "/legacy/user/search/{keyword}?";
        if (keyword === undefined || keyword === null)
            throw new Error("The parameter 'keyword' must be defined.");
        url_ = url_.replace("{keyword}", encodeURIComponent("" + keyword)); 
        if (order !== undefined)
            url_ += "order=" + encodeURIComponent("" + order) + "&"; 
        if (start_page !== undefined)
            url_ += "start_page=" + encodeURIComponent("" + start_page) + "&"; 
        if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch3(_response);
        });
    }

    protected processSearch3(_response: Response): Promise<SearchUsersByKeyword> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: SearchUsersByKeyword = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SearchUsersByKeyword.fromJS(resultData200) : new SearchUsersByKeyword();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    markdown(x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: Markdown): Promise<void> {
        let url_ = this.baseUrl + "/markdown";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "text/html; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMarkdown(_response);
        });
    }

    protected processMarkdown(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    raw(x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/markdown/raw";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "text/plain; charset=UTF-8", 
                "Accept": "text/html; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRaw(_response);
        });
    }

    protected processRaw(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    meta(x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Meta> {
        let url_ = this.baseUrl + "/meta";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMeta(_response);
        });
    }

    protected processMeta(_response: Response): Promise<Meta> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Meta = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Meta.fromJS(resultData200) : new Meta();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of the owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    events2(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Events> {
        let url_ = this.baseUrl + "/networks/{owner}/{repo}/events";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEvents2(_response);
        });
    }

    protected processEvents2(_response: Response): Promise<Events> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Events = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Events.fromJS(resultData200) : new Events();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @all True to show notifications marked as read.
     * @participating True to show only notifications in which the user is directly participating
or mentioned.
     * @since The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
Example: "2012-10-09T23:39:01Z".
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    notifications(all: boolean, participating: boolean, since: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Notifications> {
        let url_ = this.baseUrl + "/notifications?";
        if (all !== undefined)
            url_ += "all=" + encodeURIComponent("" + all) + "&"; 
        if (participating !== undefined)
            url_ += "participating=" + encodeURIComponent("" + participating) + "&"; 
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNotifications(_response);
        });
    }

    protected processNotifications(_response: Response): Promise<Notifications> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Notifications = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Notifications.fromJS(resultData200) : new Notifications();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Marked as read.
     */
    notifications2(x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: NotificationMarkRead): Promise<void> {
        let url_ = this.baseUrl + "/notifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNotifications2(_response);
        });
    }

    protected processNotifications2(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 205) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @id Id of thread.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    threads(id: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Notifications> {
        let url_ = this.baseUrl + "/notifications/threads/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processThreads(_response);
        });
    }

    protected processThreads(_response: Response): Promise<Notifications> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Notifications = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Notifications.fromJS(resultData200) : new Notifications();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @id Id of thread.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Thread marked as read.
     */
    threads2(id: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/notifications/threads/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processThreads2(_response);
        });
    }

    protected processThreads2(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 205) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @id Id of thread.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No Content
     */
    subscription(id: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/notifications/threads/{id}/subscription";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubscription(_response);
        });
    }

    protected processSubscription(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @id Id of thread.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    subscription2(id: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Subscription> {
        let url_ = this.baseUrl + "/notifications/threads/{id}/subscription";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubscription2(_response);
        });
    }

    protected processSubscription2(_response: Response): Promise<Subscription> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Subscription = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Subscription.fromJS(resultData200) : new Subscription();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @id Id of thread.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    subscription3(id: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: PutSubscription): Promise<Subscription> {
        let url_ = this.baseUrl + "/notifications/threads/{id}/subscription";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubscription3(_response);
        });
    }

    protected processSubscription3(_response: Response): Promise<Subscription> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Subscription = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Subscription.fromJS(resultData200) : new Subscription();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @org Name of organisation.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    orgs(org: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Organization> {
        let url_ = this.baseUrl + "/orgs/{org}";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrgs(_response);
        });
    }

    protected processOrgs(_response: Response): Promise<Organization> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Organization = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Organization.fromJS(resultData200) : new Organization();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @org Name of organisation.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    orgs2(org: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: PatchOrg): Promise<Organization> {
        let url_ = this.baseUrl + "/orgs/{org}";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrgs2(_response);
        });
    }

    protected processOrgs2(_response: Response): Promise<Organization> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Organization = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Organization.fromJS(resultData200) : new Organization();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @org Name of organisation.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    events3(org: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Events> {
        let url_ = this.baseUrl + "/orgs/{org}/events";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEvents3(_response);
        });
    }

    protected processEvents3(_response: Response): Promise<Events> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Events = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Events.fromJS(resultData200) : new Events();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @org Name of organisation.
     * @filter Issues assigned to you / created by you / mentioning you / you're
subscribed to updates for / All issues the authenticated user can see
     * @labels String list of comma separated Label names. Example - bug,ui,@high.
     * @since Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
Only issues updated at or after this time are returned.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    issues(org: string, filter: Filter2, state: State3, labels: string, sort: Sort4, direction: Direction2, since: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous3[]> {
        let url_ = this.baseUrl + "/orgs/{org}/issues?";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        if (filter === undefined || filter === null)
            throw new Error("The parameter 'filter' must be defined and cannot be null.");
        else
            url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
        if (state === undefined || state === null)
            throw new Error("The parameter 'state' must be defined and cannot be null.");
        else
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        if (labels === undefined || labels === null)
            throw new Error("The parameter 'labels' must be defined and cannot be null.");
        else
            url_ += "labels=" + encodeURIComponent("" + labels) + "&"; 
        if (sort === undefined || sort === null)
            throw new Error("The parameter 'sort' must be defined and cannot be null.");
        else
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        if (direction === undefined || direction === null)
            throw new Error("The parameter 'direction' must be defined and cannot be null.");
        else
            url_ += "direction=" + encodeURIComponent("" + direction) + "&"; 
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIssues(_response);
        });
    }

    protected processIssues(_response: Response): Promise<Anonymous3[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous3[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous3.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @org Name of organisation.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    membersAll(org: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous4[]> {
        let url_ = this.baseUrl + "/orgs/{org}/members";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembersAll(_response);
        });
    }

    protected processMembersAll(_response: Response): Promise<Anonymous4[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous4[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous4.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 302) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @org Name of organisation.
     * @username Name of the user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    members(org: string, username: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/orgs/{org}/members/{username}";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembers(_response);
        });
    }

    protected processMembers(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @org Name of organisation.
     * @username Name of the user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content. Response if requester is an organization member and user is a member
     */
    members2(org: string, username: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/orgs/{org}/members/{username}";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembers2(_response);
        });
    }

    protected processMembers2(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 302) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status === 404) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @org Name of organisation.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    reposAll(org: string, type: Type, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous5[]> {
        let url_ = this.baseUrl + "/orgs/{org}/repos?";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReposAll(_response);
        });
    }

    protected processReposAll(_response: Response): Promise<Anonymous5[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous5[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous5.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @org Name of organisation.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    repos(org: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: PostRepo): Promise<Anonymous5[]> {
        let url_ = this.baseUrl + "/orgs/{org}/repos";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRepos(_response);
        });
    }

    protected processRepos(_response: Response): Promise<Anonymous5[]> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            let result201: Anonymous5[] = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData201 && resultData201.constructor === Array) {
                result201 = [];
                for (let item of resultData201)
                    result201.push(Anonymous5.fromJS(item));
            }
            return result201;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @org Name of organisation.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    teamsAll(org: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous6[]> {
        let url_ = this.baseUrl + "/orgs/{org}/teams";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTeamsAll(_response);
        });
    }

    protected processTeamsAll(_response: Response): Promise<Anonymous6[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous6[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous6.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @org Name of organisation.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    teams(org: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: OrgTeamsPost): Promise<Team> {
        let url_ = this.baseUrl + "/orgs/{org}/teams";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTeams(_response);
        });
    }

    protected processTeams(_response: Response): Promise<Team> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            let result201: Team = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Team.fromJS(resultData201) : new Team();
            return result201;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Item removed.
     */
    repos2(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRepos2(_response);
        });
    }

    protected processRepos2(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    repos3(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Repo> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRepos3(_response);
        });
    }

    protected processRepos3(_response: Response): Promise<Repo> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Repo = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Repo.fromJS(resultData200) : new Repo();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    repos4(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: RepoEdit): Promise<Repo> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRepos4(_response);
        });
    }

    protected processRepos4(_response: Response): Promise<Repo> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Repo = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Repo.fromJS(resultData200) : new Repo();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    assigneesAll(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous7[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/assignees";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssigneesAll(_response);
        });
    }

    protected processAssigneesAll(_response: Response): Promise<Anonymous7[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous7[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous7.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @assignee Login of the assignee.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return User is an assignee.
     */
    assignees(owner: string, repo: string, assignee: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/assignees/{assignee}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (assignee === undefined || assignee === null)
            throw new Error("The parameter 'assignee' must be defined.");
        url_ = url_.replace("{assignee}", encodeURIComponent("" + assignee)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssignees(_response);
        });
    }

    protected processAssignees(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status === 404) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    branchesAll(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous8[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/branches";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBranchesAll(_response);
        });
    }

    protected processBranchesAll(_response: Response): Promise<Anonymous8[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous8[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous8.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @branch Name of the branch.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    branches(owner: string, repo: string, branch: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Branch> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/branches/{branch}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (branch === undefined || branch === null)
            throw new Error("The parameter 'branch' must be defined.");
        url_ = url_.replace("{branch}", encodeURIComponent("" + branch)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBranches(_response);
        });
    }

    protected processBranches(_response: Response): Promise<Branch> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Branch = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Branch.fromJS(resultData200) : new Branch();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    collaboratorsAll(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous4[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/collaborators";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCollaboratorsAll(_response);
        });
    }

    protected processCollaboratorsAll(_response: Response): Promise<Anonymous4[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous4[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous4.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @user Login of the user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Collaborator removed.
     */
    collaborators(owner: string, repo: string, user: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/collaborators/{user}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (user === undefined || user === null)
            throw new Error("The parameter 'user' must be defined.");
        url_ = url_.replace("{user}", encodeURIComponent("" + user)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCollaborators(_response);
        });
    }

    protected processCollaborators(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @user Login of the user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return User is a collaborator.
     */
    collaborators2(owner: string, repo: string, user: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/collaborators/{user}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (user === undefined || user === null)
            throw new Error("The parameter 'user' must be defined.");
        url_ = url_.replace("{user}", encodeURIComponent("" + user)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCollaborators2(_response);
        });
    }

    protected processCollaborators2(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status === 404) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @user Login of the user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Collaborator added.
     */
    collaborators3(owner: string, repo: string, user: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/collaborators/{user}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (user === undefined || user === null)
            throw new Error("The parameter 'user' must be defined.");
        url_ = url_.replace("{user}", encodeURIComponent("" + user)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCollaborators3(_response);
        });
    }

    protected processCollaborators3(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments5(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous9[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/comments";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComments5(_response);
        });
    }

    protected processComments5(_response: Response): Promise<Anonymous9[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous9[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous9.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @commentId Id of comment.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    comments6(owner: string, repo: string, commentId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/comments/{commentId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComments6(_response);
        });
    }

    protected processComments6(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @commentId Id of comment.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments7(owner: string, repo: string, commentId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<CommitComments> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/comments/{commentId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComments7(_response);
        });
    }

    protected processComments7(_response: Response): Promise<CommitComments> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: CommitComments = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommitComments.fromJS(resultData200) : new CommitComments();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @commentId Id of comment.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments8(owner: string, repo: string, commentId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: CommentBody): Promise<CommitComments> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/comments/{commentId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComments8(_response);
        });
    }

    protected processComments8(_response: Response): Promise<CommitComments> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: CommitComments = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommitComments.fromJS(resultData200) : new CommitComments();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @since The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
Example: "2012-10-09T23:39:01Z".
     * @sha Sha or branch to start listing commits from.
     * @path Only commits containing this file path will be returned.
     * @author GitHub login, name, or email by which to filter by commit author.
     * @until ISO 8601 Date - Only commits before this date will be returned.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    commitsAll(owner: string, repo: string, since: string, sha: string, path: string, author: string, until: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous10[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/commits?";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        if (sha !== undefined)
            url_ += "sha=" + encodeURIComponent("" + sha) + "&"; 
        if (path !== undefined)
            url_ += "path=" + encodeURIComponent("" + path) + "&"; 
        if (author !== undefined)
            url_ += "author=" + encodeURIComponent("" + author) + "&"; 
        if (until !== undefined)
            url_ += "until=" + encodeURIComponent("" + until) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCommitsAll(_response);
        });
    }

    protected processCommitsAll(_response: Response): Promise<Anonymous10[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous10[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous10.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    status(owner: string, repo: string, ref: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous11[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/commits/{ref}/status";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (ref === undefined || ref === null)
            throw new Error("The parameter 'ref' must be defined.");
        url_ = url_.replace("{ref}", encodeURIComponent("" + ref)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatus(_response);
        });
    }

    protected processStatus(_response: Response): Promise<Anonymous11[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous11[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous11.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @shaCode SHA-1 code of the commit.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    commits(owner: string, repo: string, shaCode: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Commit> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/commits/{shaCode}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (shaCode === undefined || shaCode === null)
            throw new Error("The parameter 'shaCode' must be defined.");
        url_ = url_.replace("{shaCode}", encodeURIComponent("" + shaCode)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCommits(_response);
        });
    }

    protected processCommits(_response: Response): Promise<Commit> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Commit = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Commit.fromJS(resultData200) : new Commit();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @shaCode SHA-1 code of the commit.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments9(owner: string, repo: string, shaCode: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous9[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/commits/{shaCode}/comments";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (shaCode === undefined || shaCode === null)
            throw new Error("The parameter 'shaCode' must be defined.");
        url_ = url_.replace("{shaCode}", encodeURIComponent("" + shaCode)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComments9(_response);
        });
    }

    protected processComments9(_response: Response): Promise<Anonymous9[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous9[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous9.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @shaCode SHA-1 code of the commit.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    comments10(owner: string, repo: string, shaCode: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: CommitBody): Promise<CommitComments> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/commits/{shaCode}/comments";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (shaCode === undefined || shaCode === null)
            throw new Error("The parameter 'shaCode' must be defined.");
        url_ = url_.replace("{shaCode}", encodeURIComponent("" + shaCode)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComments10(_response);
        });
    }

    protected processComments10(_response: Response): Promise<CommitComments> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            let result201: CommitComments = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? CommitComments.fromJS(resultData201) : new CommitComments();
            return result201;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    compare(owner: string, repo: string, baseId: string, headId: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<CompareCommits> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/compare/{baseId}...{headId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (baseId === undefined || baseId === null)
            throw new Error("The parameter 'baseId' must be defined.");
        url_ = url_.replace("{baseId}", encodeURIComponent("" + baseId)); 
        if (headId === undefined || headId === null)
            throw new Error("The parameter 'headId' must be defined.");
        url_ = url_.replace("{headId}", encodeURIComponent("" + headId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCompare(_response);
        });
    }

    protected processCompare(_response: Response): Promise<CompareCommits> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: CompareCommits = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CompareCommits.fromJS(resultData200) : new CompareCommits();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    contents(owner: string, repo: string, path: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: DeleteFileBody): Promise<DeleteFile> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/contents/{path}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processContents(_response);
        });
    }

    protected processContents(_response: Response): Promise<DeleteFile> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: DeleteFile = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DeleteFile.fromJS(resultData200) : new DeleteFile();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @pathQuery The content path.
     * @ref The String name of the Commit/Branch/Tag. Defaults to 'master'.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    contents2(owner: string, repo: string, pathPath: string, pathQuery: string, ref: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<ContentsPath> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/contents/{path}?";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (pathPath === undefined || pathPath === null)
            throw new Error("The parameter 'pathPath' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + pathPath)); 
        if (pathQuery !== undefined)
            url_ += "path=" + encodeURIComponent("" + pathQuery) + "&"; 
        if (ref !== undefined)
            url_ += "ref=" + encodeURIComponent("" + ref) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processContents2(_response);
        });
    }

    protected processContents2(_response: Response): Promise<ContentsPath> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: ContentsPath = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentsPath.fromJS(resultData200) : new ContentsPath();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    contents3(owner: string, repo: string, path: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: CreateFileBody): Promise<CreateFile> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/contents/{path}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processContents3(_response);
        });
    }

    protected processContents3(_response: Response): Promise<CreateFile> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: CreateFile = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateFile.fromJS(resultData200) : new CreateFile();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @anon Set to 1 or true to include anonymous contributors in results.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    contributorsAll(owner: string, repo: string, anon: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous12[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/contributors?";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (anon === undefined || anon === null)
            throw new Error("The parameter 'anon' must be defined and cannot be null.");
        else
            url_ += "anon=" + encodeURIComponent("" + anon) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processContributorsAll(_response);
        });
    }

    protected processContributorsAll(_response: Response): Promise<Anonymous12[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous12[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous12.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    deploymentsAll(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous13[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/deployments";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeploymentsAll(_response);
        });
    }

    protected processDeploymentsAll(_response: Response): Promise<Anonymous13[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous13[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous13.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    deployments(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: Deployment): Promise<DeploymentResp> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/deployments";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeployments(_response);
        });
    }

    protected processDeployments(_response: Response): Promise<DeploymentResp> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            let result201: DeploymentResp = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? DeploymentResp.fromJS(resultData201) : new DeploymentResp();
            return result201;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @id The Deployment ID to list the statuses from.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    statusesAll(owner: string, repo: string, id: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous14[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/deployments/{id}/statuses";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatusesAll(_response);
        });
    }

    protected processStatusesAll(_response: Response): Promise<Anonymous14[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous14[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous14.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @id The Deployment ID to list the statuses from.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return ok
     */
    statuses(owner: string, repo: string, id: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: DeploymentStatusesCreate): Promise<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/deployments/{id}/statuses";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatuses(_response);
        });
    }

    protected processStatuses(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    downloads(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Downloads> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/downloads";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDownloads(_response);
        });
    }

    protected processDownloads(_response: Response): Promise<Downloads> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Downloads = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Downloads.fromJS(resultData200) : new Downloads();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @downloadId Id of download.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    downloads2(owner: string, repo: string, downloadId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/downloads/{downloadId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (downloadId === undefined || downloadId === null)
            throw new Error("The parameter 'downloadId' must be defined.");
        url_ = url_.replace("{downloadId}", encodeURIComponent("" + downloadId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDownloads2(_response);
        });
    }

    protected processDownloads2(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @downloadId Id of download.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    downloads3(owner: string, repo: string, downloadId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Downloads> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/downloads/{downloadId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (downloadId === undefined || downloadId === null)
            throw new Error("The parameter 'downloadId' must be defined.");
        url_ = url_.replace("{downloadId}", encodeURIComponent("" + downloadId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDownloads3(_response);
        });
    }

    protected processDownloads3(_response: Response): Promise<Downloads> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Downloads = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Downloads.fromJS(resultData200) : new Downloads();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    events4(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Events> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/events";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEvents4(_response);
        });
    }

    protected processEvents4(_response: Response): Promise<Events> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Events = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Events.fromJS(resultData200) : new Events();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    forksAll(owner: string, repo: string, sort: Sort5, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous15[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/forks?";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForksAll(_response);
        });
    }

    protected processForksAll(_response: Response): Promise<Anonymous15[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous15[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous15.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    forks2(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: ForkBody): Promise<Fork> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/forks";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForks2(_response);
        });
    }

    protected processForks2(_response: Response): Promise<Fork> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            let result201: Fork = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Fork.fromJS(resultData201) : new Fork();
            return result201;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    blobs(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: Blob): Promise<Blobs> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/blobs";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBlobs(_response);
        });
    }

    protected processBlobs(_response: Response): Promise<Blobs> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            let result201: Blobs = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Blobs.fromJS(resultData201) : new Blobs();
            return result201;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @shaCode SHA-1 code.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    blobs2(owner: string, repo: string, shaCode: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Blob> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/blobs/{shaCode}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (shaCode === undefined || shaCode === null)
            throw new Error("The parameter 'shaCode' must be defined.");
        url_ = url_.replace("{shaCode}", encodeURIComponent("" + shaCode)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBlobs2(_response);
        });
    }

    protected processBlobs2(_response: Response): Promise<Blob> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Blob = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Blob.fromJS(resultData200) : new Blob();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    commits2(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: RepoCommitBody): Promise<GitCommit> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/commits";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCommits2(_response);
        });
    }

    protected processCommits2(_response: Response): Promise<GitCommit> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            let result201: GitCommit = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? GitCommit.fromJS(resultData201) : new GitCommit();
            return result201;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @shaCode SHA-1 code.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    commits3(owner: string, repo: string, shaCode: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<RepoCommit> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/commits/{shaCode}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (shaCode === undefined || shaCode === null)
            throw new Error("The parameter 'shaCode' must be defined.");
        url_ = url_.replace("{shaCode}", encodeURIComponent("" + shaCode)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCommits3(_response);
        });
    }

    protected processCommits3(_response: Response): Promise<RepoCommit> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: RepoCommit = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RepoCommit.fromJS(resultData200) : new RepoCommit();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    refsAll(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous16[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/refs";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefsAll(_response);
        });
    }

    protected processRefsAll(_response: Response): Promise<Anonymous16[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous16[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous16.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    refs(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: RefsBody): Promise<HeadBranch> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/refs";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefs(_response);
        });
    }

    protected processRefs(_response: Response): Promise<HeadBranch> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            let result201: HeadBranch = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? HeadBranch.fromJS(resultData201) : new HeadBranch();
            return result201;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No Content
     */
    refs2(owner: string, repo: string, ref: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/refs/{ref}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (ref === undefined || ref === null)
            throw new Error("The parameter 'ref' must be defined.");
        url_ = url_.replace("{ref}", encodeURIComponent("" + ref)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefs2(_response);
        });
    }

    protected processRefs2(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    refs3(owner: string, repo: string, ref: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<HeadBranch> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/refs/{ref}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (ref === undefined || ref === null)
            throw new Error("The parameter 'ref' must be defined.");
        url_ = url_.replace("{ref}", encodeURIComponent("" + ref)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefs3(_response);
        });
    }

    protected processRefs3(_response: Response): Promise<HeadBranch> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: HeadBranch = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HeadBranch.fromJS(resultData200) : new HeadBranch();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    refs4(owner: string, repo: string, ref: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: GitRefPatch): Promise<HeadBranch> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/refs/{ref}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (ref === undefined || ref === null)
            throw new Error("The parameter 'ref' must be defined.");
        url_ = url_.replace("{ref}", encodeURIComponent("" + ref)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefs4(_response);
        });
    }

    protected processRefs4(_response: Response): Promise<HeadBranch> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: HeadBranch = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HeadBranch.fromJS(resultData200) : new HeadBranch();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    tags(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: Tag): Promise<Tags> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/tags";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTags(_response);
        });
    }

    protected processTags(_response: Response): Promise<Tags> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            let result201: Tags = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Tags.fromJS(resultData201) : new Tags();
            return result201;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    tags2(owner: string, repo: string, shaCode: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Tag> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/tags/{shaCode}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (shaCode === undefined || shaCode === null)
            throw new Error("The parameter 'shaCode' must be defined.");
        url_ = url_.replace("{shaCode}", encodeURIComponent("" + shaCode)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTags2(_response);
        });
    }

    protected processTags2(_response: Response): Promise<Tag> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Tag = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Tag.fromJS(resultData200) : new Tag();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    trees(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: Tree): Promise<Trees> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/trees";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTrees(_response);
        });
    }

    protected processTrees(_response: Response): Promise<Trees> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            let result201: Trees = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Trees.fromJS(resultData201) : new Trees();
            return result201;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @shaCode Tree SHA.
     * @recursive Get a Tree Recursively. (0 or 1)
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    trees2(owner: string, repo: string, shaCode: string, recursive: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Tree> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/trees/{shaCode}?";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (shaCode === undefined || shaCode === null)
            throw new Error("The parameter 'shaCode' must be defined.");
        url_ = url_.replace("{shaCode}", encodeURIComponent("" + shaCode)); 
        if (recursive !== undefined)
            url_ += "recursive=" + encodeURIComponent("" + recursive) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTrees2(_response);
        });
    }

    protected processTrees2(_response: Response): Promise<Tree> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Tree = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Tree.fromJS(resultData200) : new Tree();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    hooksAll(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous17[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/hooks";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHooksAll(_response);
        });
    }

    protected processHooksAll(_response: Response): Promise<Anonymous17[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous17[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous17.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    hooks(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: HookBody): Promise<Anonymous17[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/hooks";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHooks(_response);
        });
    }

    protected processHooks(_response: Response): Promise<Anonymous17[]> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            let result201: Anonymous17[] = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData201 && resultData201.constructor === Array) {
                result201 = [];
                for (let item of resultData201)
                    result201.push(Anonymous17.fromJS(item));
            }
            return result201;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @hookId Id of hook.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    hooks2(owner: string, repo: string, hookId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/hooks/{hookId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (hookId === undefined || hookId === null)
            throw new Error("The parameter 'hookId' must be defined.");
        url_ = url_.replace("{hookId}", encodeURIComponent("" + hookId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHooks2(_response);
        });
    }

    protected processHooks2(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @hookId Id of hook.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    hooks3(owner: string, repo: string, hookId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous17[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/hooks/{hookId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (hookId === undefined || hookId === null)
            throw new Error("The parameter 'hookId' must be defined.");
        url_ = url_.replace("{hookId}", encodeURIComponent("" + hookId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHooks3(_response);
        });
    }

    protected processHooks3(_response: Response): Promise<Anonymous17[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous17[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous17.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @hookId Id of hook.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    hooks4(owner: string, repo: string, hookId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: HookBody): Promise<Anonymous17[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/hooks/{hookId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (hookId === undefined || hookId === null)
            throw new Error("The parameter 'hookId' must be defined.");
        url_ = url_.replace("{hookId}", encodeURIComponent("" + hookId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHooks4(_response);
        });
    }

    protected processHooks4(_response: Response): Promise<Anonymous17[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous17[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous17.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @hookId Id of hook.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Hook is triggered.
     */
    tests(owner: string, repo: string, hookId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/hooks/{hookId}/tests";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (hookId === undefined || hookId === null)
            throw new Error("The parameter 'hookId' must be defined.");
        url_ = url_.replace("{hookId}", encodeURIComponent("" + hookId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTests(_response);
        });
    }

    protected processTests(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @filter Issues assigned to you / created by you / mentioning you / you're
subscribed to updates for / All issues the authenticated user can see
     * @labels String list of comma separated Label names. Example - bug,ui,@high.
     * @since Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
Only issues updated at or after this time are returned.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    issues2(owner: string, repo: string, filter: Filter3, state: State4, labels: string, sort: Sort6, direction: Direction3, since: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous3[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues?";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (filter === undefined || filter === null)
            throw new Error("The parameter 'filter' must be defined and cannot be null.");
        else
            url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
        if (state === undefined || state === null)
            throw new Error("The parameter 'state' must be defined and cannot be null.");
        else
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        if (labels === undefined || labels === null)
            throw new Error("The parameter 'labels' must be defined and cannot be null.");
        else
            url_ += "labels=" + encodeURIComponent("" + labels) + "&"; 
        if (sort === undefined || sort === null)
            throw new Error("The parameter 'sort' must be defined and cannot be null.");
        else
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        if (direction === undefined || direction === null)
            throw new Error("The parameter 'direction' must be defined and cannot be null.");
        else
            url_ += "direction=" + encodeURIComponent("" + direction) + "&"; 
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIssues2(_response);
        });
    }

    protected processIssues2(_response: Response): Promise<Anonymous3[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous3[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous3.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    issues3(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: Issue): Promise<Issue> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIssues3(_response);
        });
    }

    protected processIssues3(_response: Response): Promise<Issue> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            let result201: Issue = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Issue.fromJS(resultData201) : new Issue();
            return result201;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @direction Ignored without 'sort' parameter.
     * @since The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
Example: "2012-10-09T23:39:01Z".
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments11(owner: string, repo: string, direction: string, sort: Sort7, since: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous18[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/comments?";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (direction !== undefined)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&"; 
        if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComments11(_response);
        });
    }

    protected processComments11(_response: Response): Promise<Anonymous18[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous18[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous18.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @commentId ID of comment.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    comments12(owner: string, repo: string, commentId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/comments/{commentId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComments12(_response);
        });
    }

    protected processComments12(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @commentId ID of comment.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments13(owner: string, repo: string, commentId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<IssuesComment> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/comments/{commentId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComments13(_response);
        });
    }

    protected processComments13(_response: Response): Promise<IssuesComment> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: IssuesComment = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IssuesComment.fromJS(resultData200) : new IssuesComment();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @commentId ID of comment.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments14(owner: string, repo: string, commentId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: CommentBody): Promise<IssuesComment> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/comments/{commentId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComments14(_response);
        });
    }

    protected processComments14(_response: Response): Promise<IssuesComment> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: IssuesComment = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IssuesComment.fromJS(resultData200) : new IssuesComment();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    events5(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Events> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/events";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEvents5(_response);
        });
    }

    protected processEvents5(_response: Response): Promise<Events> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Events = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Events.fromJS(resultData200) : new Events();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @eventId Id of the event.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    events6(owner: string, repo: string, eventId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Event> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/events/{eventId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEvents6(_response);
        });
    }

    protected processEvents6(_response: Response): Promise<Event> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Event = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Event.fromJS(resultData200) : new Event();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of issue.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    issues4(owner: string, repo: string, number: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Issue> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIssues4(_response);
        });
    }

    protected processIssues4(_response: Response): Promise<Issue> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Issue = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Issue.fromJS(resultData200) : new Issue();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of issue.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    issues5(owner: string, repo: string, number: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: Issue): Promise<Issue> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIssues5(_response);
        });
    }

    protected processIssues5(_response: Response): Promise<Issue> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Issue = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Issue.fromJS(resultData200) : new Issue();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of issue.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments15(owner: string, repo: string, number: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous18[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}/comments";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComments15(_response);
        });
    }

    protected processComments15(_response: Response): Promise<Anonymous18[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous18[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous18.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of issue.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    comments16(owner: string, repo: string, number: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: CommentBody): Promise<IssuesComment> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}/comments";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComments16(_response);
        });
    }

    protected processComments16(_response: Response): Promise<IssuesComment> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            let result201: IssuesComment = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? IssuesComment.fromJS(resultData201) : new IssuesComment();
            return result201;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of issue.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    events7(owner: string, repo: string, number: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Events> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}/events";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEvents7(_response);
        });
    }

    protected processEvents7(_response: Response): Promise<Events> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Events = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Events.fromJS(resultData200) : new Events();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of issue.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    labels(owner: string, repo: string, number: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}/labels";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLabels(_response);
        });
    }

    protected processLabels(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of issue.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    labelsAll(owner: string, repo: string, number: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous19[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}/labels";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLabelsAll(_response);
        });
    }

    protected processLabelsAll(_response: Response): Promise<Anonymous19[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous19[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous19.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of issue.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    labels2(owner: string, repo: string, number: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: string[]): Promise<Label> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}/labels";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLabels2(_response);
        });
    }

    protected processLabels2(_response: Response): Promise<Label> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            let result201: Label = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Label.fromJS(resultData201) : new Label();
            return result201;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of issue.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    labels3(owner: string, repo: string, number: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: string[]): Promise<Label> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}/labels";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLabels3(_response);
        });
    }

    protected processLabels3(_response: Response): Promise<Label> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            let result201: Label = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Label.fromJS(resultData201) : new Label();
            return result201;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of issue.
     * @name Name of the label.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Item removed.
     */
    labels4(owner: string, repo: string, number: number, name: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}/labels/{name}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLabels4(_response);
        });
    }

    protected processLabels4(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    keysAll(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous20[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/keys";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processKeysAll(_response);
        });
    }

    protected processKeysAll(_response: Response): Promise<Anonymous20[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous20[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous20.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    keys(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: UserKeysPost): Promise<UserKeysKeyId> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/keys";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processKeys(_response);
        });
    }

    protected processKeys(_response: Response): Promise<UserKeysKeyId> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            let result201: UserKeysKeyId = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? UserKeysKeyId.fromJS(resultData201) : new UserKeysKeyId();
            return result201;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @keyId Id of key.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    keys2(owner: string, repo: string, keyId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/keys/{keyId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (keyId === undefined || keyId === null)
            throw new Error("The parameter 'keyId' must be defined.");
        url_ = url_.replace("{keyId}", encodeURIComponent("" + keyId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processKeys2(_response);
        });
    }

    protected processKeys2(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @keyId Id of key.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    keys3(owner: string, repo: string, keyId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<UserKeysKeyId> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/keys/{keyId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (keyId === undefined || keyId === null)
            throw new Error("The parameter 'keyId' must be defined.");
        url_ = url_.replace("{keyId}", encodeURIComponent("" + keyId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processKeys3(_response);
        });
    }

    protected processKeys3(_response: Response): Promise<UserKeysKeyId> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: UserKeysKeyId = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserKeysKeyId.fromJS(resultData200) : new UserKeysKeyId();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    labels5(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous19[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/labels";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLabels5(_response);
        });
    }

    protected processLabels5(_response: Response): Promise<Anonymous19[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous19[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous19.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    labels6(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: string[]): Promise<Label> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/labels";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLabels6(_response);
        });
    }

    protected processLabels6(_response: Response): Promise<Label> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            let result201: Label = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Label.fromJS(resultData201) : new Label();
            return result201;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @name Name of the label.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    labels7(owner: string, repo: string, name: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/labels/{name}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLabels7(_response);
        });
    }

    protected processLabels7(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @name Name of the label.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    labels8(owner: string, repo: string, name: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Label> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/labels/{name}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLabels8(_response);
        });
    }

    protected processLabels8(_response: Response): Promise<Label> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Label = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Label.fromJS(resultData200) : new Label();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @name Name of the label.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    labels9(owner: string, repo: string, name: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: string[]): Promise<Label> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/labels/{name}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLabels9(_response);
        });
    }

    protected processLabels9(_response: Response): Promise<Label> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Label = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Label.fromJS(resultData200) : new Label();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    languages(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<{ [key: string] : number; }> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/languages";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLanguages(_response);
        });
    }

    protected processLanguages(_response: Response): Promise<{ [key: string] : number; }> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: { [key: string] : number; } = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key] !== undefined ? resultData200[key] : {};
                }
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Successful Response (The resulting merge commit)
     */
    merges(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: MergesBody): Promise<MergesSuccessful> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/merges";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMerges(_response);
        });
    }

    protected processMerges(_response: Response): Promise<MergesSuccessful> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            let result201: MergesSuccessful = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? MergesSuccessful.fromJS(resultData201) : new MergesSuccessful();
            return result201;
            });
        } else if (_status === 204) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status === 404) {
            return _response.text().then((_responseText) => {
            let result404: MergesConflict = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? MergesConflict.fromJS(resultData404) : new MergesConflict();
            return throwException("A server error occurred.", _status, _responseText, result404);
            });
        } else if (_status === 409) {
            return _response.text().then((_responseText) => {
            let result409: MergesConflict = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? MergesConflict.fromJS(resultData409) : new MergesConflict();
            return throwException("A server error occurred.", _status, _responseText, result409);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @state String to filter by state.
     * @direction Ignored without 'sort' parameter.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    milestones(owner: string, repo: string, state: State5, direction: string, sort: Sort8, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Milestone> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/milestones?";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        if (direction !== undefined)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&"; 
        if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMilestones(_response);
        });
    }

    protected processMilestones(_response: Response): Promise<Milestone> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Milestone = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Milestone.fromJS(resultData200) : new Milestone();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    milestones2(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: MilestoneUpdate): Promise<Milestone> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/milestones";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMilestones2(_response);
        });
    }

    protected processMilestones2(_response: Response): Promise<Milestone> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            let result201: Milestone = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Milestone.fromJS(resultData201) : new Milestone();
            return result201;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of milestone.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    milestones3(owner: string, repo: string, number: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/milestones/{number}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMilestones3(_response);
        });
    }

    protected processMilestones3(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of milestone.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    milestones4(owner: string, repo: string, number: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Milestone> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/milestones/{number}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMilestones4(_response);
        });
    }

    protected processMilestones4(_response: Response): Promise<Milestone> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Milestone = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Milestone.fromJS(resultData200) : new Milestone();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of milestone.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    milestones5(owner: string, repo: string, number: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: MilestoneUpdate): Promise<Milestone> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/milestones/{number}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMilestones5(_response);
        });
    }

    protected processMilestones5(_response: Response): Promise<Milestone> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Milestone = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Milestone.fromJS(resultData200) : new Milestone();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of milestone.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    labels10(owner: string, repo: string, number: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous19[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/milestones/{number}/labels";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLabels10(_response);
        });
    }

    protected processLabels10(_response: Response): Promise<Anonymous19[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous19[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous19.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @all True to show notifications marked as read.
     * @participating True to show only notifications in which the user is directly participating
or mentioned.
     * @since The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
Example: "2012-10-09T23:39:01Z".
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    notifications3(owner: string, repo: string, all: boolean, participating: boolean, since: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Notifications> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/notifications?";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (all !== undefined)
            url_ += "all=" + encodeURIComponent("" + all) + "&"; 
        if (participating !== undefined)
            url_ += "participating=" + encodeURIComponent("" + participating) + "&"; 
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNotifications3(_response);
        });
    }

    protected processNotifications3(_response: Response): Promise<Notifications> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Notifications = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Notifications.fromJS(resultData200) : new Notifications();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Marked as read.
     */
    notifications4(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: NotificationMarkRead): Promise<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/notifications";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNotifications4(_response);
        });
    }

    protected processNotifications4(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 205) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @state String to filter by state.
     * @head Filter pulls by head user and branch name in the format of 'user:ref-name'.
Example: github:new-script-format.
     * @base Filter pulls by base branch name. Example - gh-pages.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    pullsAll(owner: string, repo: string, state: State6, head: string, base: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous21[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls?";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        if (head !== undefined)
            url_ += "head=" + encodeURIComponent("" + head) + "&"; 
        if (base !== undefined)
            url_ += "base=" + encodeURIComponent("" + base) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPullsAll(_response);
        });
    }

    protected processPullsAll(_response: Response): Promise<Anonymous21[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous21[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous21.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    pulls(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: PullsPost): Promise<Anonymous21[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPulls(_response);
        });
    }

    protected processPulls(_response: Response): Promise<Anonymous21[]> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            let result201: Anonymous21[] = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData201 && resultData201.constructor === Array) {
                result201 = [];
                for (let item of resultData201)
                    result201.push(Anonymous21.fromJS(item));
            }
            return result201;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @direction Ignored without 'sort' parameter.
     * @since The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
Example: "2012-10-09T23:39:01Z".
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments17(owner: string, repo: string, direction: string, sort: Sort9, since: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous18[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/comments?";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (direction !== undefined)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&"; 
        if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComments17(_response);
        });
    }

    protected processComments17(_response: Response): Promise<Anonymous18[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous18[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous18.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @commentId Id of comment.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    comments18(owner: string, repo: string, commentId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/comments/{commentId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComments18(_response);
        });
    }

    protected processComments18(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @commentId Id of comment.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments19(owner: string, repo: string, commentId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<PullsComment> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/comments/{commentId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComments19(_response);
        });
    }

    protected processComments19(_response: Response): Promise<PullsComment> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: PullsComment = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PullsComment.fromJS(resultData200) : new PullsComment();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @commentId Id of comment.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments20(owner: string, repo: string, commentId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: CommentBody): Promise<PullsComment> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/comments/{commentId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComments20(_response);
        });
    }

    protected processComments20(_response: Response): Promise<PullsComment> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: PullsComment = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PullsComment.fromJS(resultData200) : new PullsComment();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Id of pull.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    pulls2(owner: string, repo: string, number: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<PullRequest> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/{number}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPulls2(_response);
        });
    }

    protected processPulls2(_response: Response): Promise<PullRequest> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: PullRequest = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PullRequest.fromJS(resultData200) : new PullRequest();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Id of pull.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    pulls3(owner: string, repo: string, number: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: PullUpdate): Promise<Repo> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/{number}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPulls3(_response);
        });
    }

    protected processPulls3(_response: Response): Promise<Repo> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Repo = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Repo.fromJS(resultData200) : new Repo();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Id of pull.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments21(owner: string, repo: string, number: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<PullsComment> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/{number}/comments";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComments21(_response);
        });
    }

    protected processComments21(_response: Response): Promise<PullsComment> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: PullsComment = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PullsComment.fromJS(resultData200) : new PullsComment();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Id of pull.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    comments22(owner: string, repo: string, number: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: PullsCommentPost): Promise<PullsComment> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/{number}/comments";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComments22(_response);
        });
    }

    protected processComments22(_response: Response): Promise<PullsComment> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            let result201: PullsComment = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? PullsComment.fromJS(resultData201) : new PullsComment();
            return result201;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Id of pull.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    commits4(owner: string, repo: string, number: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous10[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/{number}/commits";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCommits4(_response);
        });
    }

    protected processCommits4(_response: Response): Promise<Anonymous10[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous10[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous10.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Id of pull.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    files(owner: string, repo: string, number: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous21[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/{number}/files";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFiles(_response);
        });
    }

    protected processFiles(_response: Response): Promise<Anonymous21[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous21[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous21.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Id of pull.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Pull request has been merged.
     */
    merge(owner: string, repo: string, number: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/{number}/merge";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMerge(_response);
        });
    }

    protected processMerge(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status === 404) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Id of pull.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Response if merge was successful.
     */
    merge2(owner: string, repo: string, number: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: MergePullBody): Promise<Merge> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/{number}/merge";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMerge2(_response);
        });
    }

    protected processMerge2(_response: Response): Promise<Merge> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Merge = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Merge.fromJS(resultData200) : new Merge();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status === 405) {
            return _response.text().then((_responseText) => {
            let result405: Merge = null;
            let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result405 = resultData405 ? Merge.fromJS(resultData405) : new Merge();
            return throwException("A server error occurred.", _status, _responseText, result405);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @ref The String name of the Commit/Branch/Tag. Defaults to master.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    readme(owner: string, repo: string, ref: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<ContentsPath> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/readme?";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (ref !== undefined)
            url_ += "ref=" + encodeURIComponent("" + ref) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReadme(_response);
        });
    }

    protected processReadme(_response: Response): Promise<ContentsPath> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: ContentsPath = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentsPath.fromJS(resultData200) : new ContentsPath();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    releasesAll(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous22[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/releases";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReleasesAll(_response);
        });
    }

    protected processReleasesAll(_response: Response): Promise<Anonymous22[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous22[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous22.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    releases(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: ReleaseCreate): Promise<Release> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/releases";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReleases(_response);
        });
    }

    protected processReleases(_response: Response): Promise<Release> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            let result201: Release = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Release.fromJS(resultData201) : new Release();
            return result201;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No Content
     */
    assets(owner: string, repo: string, id: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/releases/assets/{id}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssets(_response);
        });
    }

    protected processAssets(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    assets2(owner: string, repo: string, id: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Asset> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/releases/assets/{id}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssets2(_response);
        });
    }

    protected processAssets2(_response: Response): Promise<Asset> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Asset = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Asset.fromJS(resultData200) : new Asset();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    assets3(owner: string, repo: string, id: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: AssetPatch): Promise<Asset> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/releases/assets/{id}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssets3(_response);
        });
    }

    protected processAssets3(_response: Response): Promise<Asset> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Asset = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Asset.fromJS(resultData200) : new Asset();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No Content
     */
    releases2(owner: string, repo: string, id: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/releases/{id}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReleases2(_response);
        });
    }

    protected processReleases2(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    releases3(owner: string, repo: string, id: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Release> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/releases/{id}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReleases3(_response);
        });
    }

    protected processReleases3(_response: Response): Promise<Release> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Release = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Release.fromJS(resultData200) : new Release();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    releases4(owner: string, repo: string, id: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: ReleaseCreate): Promise<Release> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/releases/{id}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReleases4(_response);
        });
    }

    protected processReleases4(_response: Response): Promise<Release> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Release = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Release.fromJS(resultData200) : new Release();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    assetsAll(owner: string, repo: string, id: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous23[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/releases/{id}/assets";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssetsAll(_response);
        });
    }

    protected processAssetsAll(_response: Response): Promise<Anonymous23[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous23[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous23.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    stargazers(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous4[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/stargazers";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStargazers(_response);
        });
    }

    protected processStargazers(_response: Response): Promise<Anonymous4[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous4[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous4.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    contributors(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous24[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/stats/contributors";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processContributors(_response);
        });
    }

    protected processContributors(_response: Response): Promise<Anonymous24[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous24[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous24.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    participation(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<ParticipationStats> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/stats/participation";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processParticipation(_response);
        });
    }

    protected processParticipation(_response: Response): Promise<ParticipationStats> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: ParticipationStats = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ParticipationStats.fromJS(resultData200) : new ParticipationStats();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @ref Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    statuses2(owner: string, repo: string, ref: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous25[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/statuses/{ref}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (ref === undefined || ref === null)
            throw new Error("The parameter 'ref' must be defined.");
        url_ = url_.replace("{ref}", encodeURIComponent("" + ref)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatuses2(_response);
        });
    }

    protected processStatuses2(_response: Response): Promise<Anonymous25[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous25[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous25.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @ref Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    statuses3(owner: string, repo: string, ref: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: HeadBranch): Promise<Anonymous25[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/statuses/{ref}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (ref === undefined || ref === null)
            throw new Error("The parameter 'ref' must be defined.");
        url_ = url_.replace("{ref}", encodeURIComponent("" + ref)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatuses3(_response);
        });
    }

    protected processStatuses3(_response: Response): Promise<Anonymous25[]> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            let result201: Anonymous25[] = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData201 && resultData201.constructor === Array) {
                result201 = [];
                for (let item of resultData201)
                    result201.push(Anonymous25.fromJS(item));
            }
            return result201;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    subscribers(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous4[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/subscribers";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubscribers(_response);
        });
    }

    protected processSubscribers(_response: Response): Promise<Anonymous4[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous4[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous4.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    subscription4(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/subscription";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubscription4(_response);
        });
    }

    protected processSubscription4(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    subscription5(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Subscribition> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/subscription";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubscription5(_response);
        });
    }

    protected processSubscription5(_response: Response): Promise<Subscribition> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Subscribition = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Subscribition.fromJS(resultData200) : new Subscribition();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    subscription6(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: SubscribitionBody): Promise<Subscribition> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/subscription";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubscription6(_response);
        });
    }

    protected processSubscription6(_response: Response): Promise<Subscribition> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Subscribition = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Subscribition.fromJS(resultData200) : new Subscribition();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    tags3(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Tags> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/tags";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTags3(_response);
        });
    }

    protected processTags3(_response: Response): Promise<Tags> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Tags = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Tags.fromJS(resultData200) : new Tags();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    teams2(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous6[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/teams";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTeams2(_response);
        });
    }

    protected processTeams2(_response: Response): Promise<Anonymous6[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous6[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous6.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    watchers(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous4[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/watchers";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWatchers(_response);
        });
    }

    protected processWatchers(_response: Response): Promise<Anonymous4[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous4[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous4.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @path Valid Git reference, defaults to 'master'.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     */
    repos5(owner: string, repo: string, archive_format: Archive_format, path: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/{archive_format}/{path}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (archive_format === undefined || archive_format === null)
            throw new Error("The parameter 'archive_format' must be defined.");
        url_ = url_.replace("{archive_format}", encodeURIComponent("" + archive_format)); 
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRepos5(_response);
        });
    }

    protected processRepos5(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 302) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @since The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
Example: "2012-10-09T23:39:01Z".
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    repositoriesAll(since: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous26[]> {
        let url_ = this.baseUrl + "/repositories?";
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRepositoriesAll(_response);
        });
    }

    protected processRepositoriesAll(_response: Response): Promise<Anonymous26[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous26[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous26.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @order The sort field. if sort param is provided. Can be either asc or desc.
     * @q The search terms. This can be any combination of the supported code
search parameters:
'Search In' Qualifies which fields are searched. With this qualifier
you can restrict the search to just the file contents, the file path,
or both.
'Languages' Searches code based on the language it's written in.
'Forks' Filters repositories based on the number of forks, and/or
whether code from forked repositories should be included in the results
at all.
'Size' Finds files that match a certain size (in bytes).
'Path' Specifies the path that the resulting file must be at.
'Extension' Matches files with a certain extension.
'Users' or 'Repositories' Limits searches to a specific user or repository.
     * @sort Can only be 'indexed', which indicates how recently a file has been indexed
by the GitHub search infrastructure. If not provided, results are sorted
by best match.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    code(order: Order3, q: string, sort: Sort10, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<SearchCode> {
        let url_ = this.baseUrl + "/search/code?";
        if (order !== undefined)
            url_ += "order=" + encodeURIComponent("" + order) + "&"; 
        if (q === undefined || q === null)
            throw new Error("The parameter 'q' must be defined and cannot be null.");
        else
            url_ += "q=" + encodeURIComponent("" + q) + "&"; 
        if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCode(_response);
        });
    }

    protected processCode(_response: Response): Promise<SearchCode> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: SearchCode = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SearchCode.fromJS(resultData200) : new SearchCode();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @order The sort field. if sort param is provided. Can be either asc or desc.
     * @q The q search term can also contain any combination of the supported issue search qualifiers:
     * @sort The sort field. Can be comments, created, or updated. Default: results are sorted by best match.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    issues6(order: Order4, q: string, sort: Sort11, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<SearchIssues> {
        let url_ = this.baseUrl + "/search/issues?";
        if (order !== undefined)
            url_ += "order=" + encodeURIComponent("" + order) + "&"; 
        if (q === undefined || q === null)
            throw new Error("The parameter 'q' must be defined and cannot be null.");
        else
            url_ += "q=" + encodeURIComponent("" + q) + "&"; 
        if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIssues6(_response);
        });
    }

    protected processIssues6(_response: Response): Promise<SearchIssues> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: SearchIssues = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SearchIssues.fromJS(resultData200) : new SearchIssues();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @order The sort field. if sort param is provided. Can be either asc or desc.
     * @q The search terms. This can be any combination of the supported repository
search parameters:
'Search In' Qualifies which fields are searched. With this qualifier you
can restrict the search to just the repository name, description, readme,
or any combination of these.
'Size' Finds repositories that match a certain size (in kilobytes).
'Forks' Filters repositories based on the number of forks, and/or whether
forked repositories should be included in the results at all.
'Created' and 'Last Updated' Filters repositories based on times of
creation, or when they were last updated.
'Users or Repositories' Limits searches to a specific user or repository.
'Languages' Searches repositories based on the language they are written in.
'Stars' Searches repositories based on the number of stars.
     * @sort If not provided, results are sorted by best match.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    repositories(order: Order5, q: string, sort: Sort12, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<SearchRepositories> {
        let url_ = this.baseUrl + "/search/repositories?";
        if (order !== undefined)
            url_ += "order=" + encodeURIComponent("" + order) + "&"; 
        if (q === undefined || q === null)
            throw new Error("The parameter 'q' must be defined and cannot be null.");
        else
            url_ += "q=" + encodeURIComponent("" + q) + "&"; 
        if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRepositories(_response);
        });
    }

    protected processRepositories(_response: Response): Promise<SearchRepositories> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: SearchRepositories = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SearchRepositories.fromJS(resultData200) : new SearchRepositories();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @order The sort field. if sort param is provided. Can be either asc or desc.
     * @q The search terms. This can be any combination of the supported user
search parameters:
'Search In' Qualifies which fields are searched. With this qualifier you
can restrict the search to just the username, public email, full name,
location, or any combination of these.
'Repository count' Filters users based on the number of repositories they
have.
'Location' Filter users by the location indicated in their profile.
'Language' Search for users that have repositories that match a certain
language.
'Created' Filter users based on when they joined.
'Followers' Filter users based on the number of followers they have.
     * @sort If not provided, results are sorted by best match.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    users(order: Order6, q: string, sort: Sort13, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<SearchUsers> {
        let url_ = this.baseUrl + "/search/users?";
        if (order !== undefined)
            url_ += "order=" + encodeURIComponent("" + order) + "&"; 
        if (q === undefined || q === null)
            throw new Error("The parameter 'q' must be defined and cannot be null.");
        else
            url_ += "q=" + encodeURIComponent("" + q) + "&"; 
        if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsers(_response);
        });
    }

    protected processUsers(_response: Response): Promise<SearchUsers> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: SearchUsers = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SearchUsers.fromJS(resultData200) : new SearchUsers();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @teamId Id of team.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    teams3(teamId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/teams/{teamId}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTeams3(_response);
        });
    }

    protected processTeams3(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @teamId Id of team.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    teams4(teamId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Team> {
        let url_ = this.baseUrl + "/teams/{teamId}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTeams4(_response);
        });
    }

    protected processTeams4(_response: Response): Promise<Team> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Team = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Team.fromJS(resultData200) : new Team();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @teamId Id of team.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    teams5(teamId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: EditTeam): Promise<Team> {
        let url_ = this.baseUrl + "/teams/{teamId}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTeams5(_response);
        });
    }

    protected processTeams5(_response: Response): Promise<Team> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Team = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Team.fromJS(resultData200) : new Team();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @teamId Id of team.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    members3(teamId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous4[]> {
        let url_ = this.baseUrl + "/teams/{teamId}/members";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembers3(_response);
        });
    }

    protected processMembers3(_response: Response): Promise<Anonymous4[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous4[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous4.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @teamId Id of team.
     * @username Name of a member.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Team member removed.
     */
    members4(teamId: number, username: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/teams/{teamId}/members/{username}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembers4(_response);
        });
    }

    protected processMembers4(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @teamId Id of team.
     * @username Name of a member.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return User is a member.
     */
    members5(teamId: number, username: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/teams/{teamId}/members/{username}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembers5(_response);
        });
    }

    protected processMembers5(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status === 404) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @teamId Id of team.
     * @username Name of a member.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Team member added.
     */
    members6(teamId: number, username: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/teams/{teamId}/members/{username}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembers6(_response);
        });
    }

    protected processMembers6(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status === 422) {
            return _response.text().then((_responseText) => {
            let result422: OrganizationAsTeamMember = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = resultData422 ? OrganizationAsTeamMember.fromJS(resultData422) : new OrganizationAsTeamMember();
            return throwException("A server error occurred.", _status, _responseText, result422);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @teamId Id of team.
     * @username Name of a member.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Team member removed.
     */
    memberships(teamId: number, username: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/teams/{teamId}/memberships/{username}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMemberships(_response);
        });
    }

    protected processMemberships(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @teamId Id of team.
     * @username Name of a member.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return User is a member.
     */
    memberships2(teamId: number, username: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<TeamMembership> {
        let url_ = this.baseUrl + "/teams/{teamId}/memberships/{username}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMemberships2(_response);
        });
    }

    protected processMemberships2(_response: Response): Promise<TeamMembership> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: TeamMembership = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TeamMembership.fromJS(resultData200) : new TeamMembership();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status === 404) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @teamId Id of team.
     * @username Name of a member.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Team member added.
     */
    memberships3(teamId: number, username: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<TeamMembership> {
        let url_ = this.baseUrl + "/teams/{teamId}/memberships/{username}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMemberships3(_response);
        });
    }

    protected processMemberships3(_response: Response): Promise<TeamMembership> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: TeamMembership = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TeamMembership.fromJS(resultData200) : new TeamMembership();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status === 422) {
            return _response.text().then((_responseText) => {
            let result422: OrganizationAsTeamMember = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = resultData422 ? OrganizationAsTeamMember.fromJS(resultData422) : new OrganizationAsTeamMember();
            return throwException("A server error occurred.", _status, _responseText, result422);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @teamId Id of team.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    repos6(teamId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous27[]> {
        let url_ = this.baseUrl + "/teams/{teamId}/repos";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRepos6(_response);
        });
    }

    protected processRepos6(_response: Response): Promise<Anonymous27[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous27[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous27.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @teamId Id of team.
     * @org Name of a organization.
     * @repo Name of a repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     */
    repos7(teamId: number, org: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/teams/{teamId}/repos/{org}/{repo}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRepos7(_response);
        });
    }

    protected processRepos7(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @teamId Id of team.
     * @owner Name of a repository owner.
     * @repo Name of a repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    repos8(teamId: number, owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/teams/{teamId}/repos/{owner}/{repo}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRepos8(_response);
        });
    }

    protected processRepos8(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @teamId Id of team.
     * @owner Name of a repository owner.
     * @repo Name of a repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     */
    repos9(teamId: number, owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/teams/{teamId}/repos/{owner}/{repo}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRepos9(_response);
        });
    }

    protected processRepos9(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    user(x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<User> {
        let url_ = this.baseUrl + "/user";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUser(_response);
        });
    }

    protected processUser(_response: Response): Promise<User> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: User = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? User.fromJS(resultData200) : new User();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    user2(x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: UserUpdate): Promise<User> {
        let url_ = this.baseUrl + "/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUser2(_response);
        });
    }

    protected processUser2(_response: Response): Promise<User> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: User = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? User.fromJS(resultData200) : new User();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    emails(x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: string[]): Promise<void> {
        let url_ = this.baseUrl + "/user/emails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEmails(_response);
        });
    }

    protected processEmails(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    emailsAll(x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<string[]> {
        let url_ = this.baseUrl + "/user/emails";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/vnd.github.v3; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEmailsAll(_response);
        });
    }

    protected processEmailsAll(_response: Response): Promise<string[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: string[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     */
    emails2(x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: string[]): Promise<void> {
        let url_ = this.baseUrl + "/user/emails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEmails2(_response);
        });
    }

    protected processEmails2(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    followersAll(x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous4[]> {
        let url_ = this.baseUrl + "/user/followers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFollowersAll(_response);
        });
    }

    protected processFollowersAll(_response: Response): Promise<Anonymous4[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous4[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous4.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    followingAll(x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous4[]> {
        let url_ = this.baseUrl + "/user/following";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFollowingAll(_response);
        });
    }

    protected processFollowingAll(_response: Response): Promise<Anonymous4[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous4[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous4.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return User unfollowed.
     */
    following(username: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/user/following/{username}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFollowing(_response);
        });
    }

    protected processFollowing(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Response if you are following this user.
     */
    following2(username: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/user/following/{username}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFollowing2(_response);
        });
    }

    protected processFollowing2(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status === 404) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return You are now following the user.
     */
    following3(username: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/user/following/{username}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFollowing3(_response);
        });
    }

    protected processFollowing3(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @filter Issues assigned to you / created by you / mentioning you / you're
subscribed to updates for / All issues the authenticated user can see
     * @labels String list of comma separated Label names. Example - bug,ui,@high.
     * @since Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
Only issues updated at or after this time are returned.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    issues7(filter: Filter4, state: State7, labels: string, sort: Sort14, direction: Direction4, since: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous3[]> {
        let url_ = this.baseUrl + "/user/issues?";
        if (filter === undefined || filter === null)
            throw new Error("The parameter 'filter' must be defined and cannot be null.");
        else
            url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
        if (state === undefined || state === null)
            throw new Error("The parameter 'state' must be defined and cannot be null.");
        else
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        if (labels === undefined || labels === null)
            throw new Error("The parameter 'labels' must be defined and cannot be null.");
        else
            url_ += "labels=" + encodeURIComponent("" + labels) + "&"; 
        if (sort === undefined || sort === null)
            throw new Error("The parameter 'sort' must be defined and cannot be null.");
        else
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        if (direction === undefined || direction === null)
            throw new Error("The parameter 'direction' must be defined and cannot be null.");
        else
            url_ += "direction=" + encodeURIComponent("" + direction) + "&"; 
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIssues7(_response);
        });
    }

    protected processIssues7(_response: Response): Promise<Anonymous3[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous3[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous3.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    keys4(x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<any[]> {
        let url_ = this.baseUrl + "/user/keys";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processKeys4(_response);
        });
    }

    protected processKeys4(_response: Response): Promise<any[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: any[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    keys5(x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: UserKeysPost): Promise<UserKeysKeyId> {
        let url_ = this.baseUrl + "/user/keys";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processKeys5(_response);
        });
    }

    protected processKeys5(_response: Response): Promise<UserKeysKeyId> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            let result201: UserKeysKeyId = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? UserKeysKeyId.fromJS(resultData201) : new UserKeysKeyId();
            return result201;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @keyId ID of key.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    keys6(keyId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/user/keys/{keyId}";
        if (keyId === undefined || keyId === null)
            throw new Error("The parameter 'keyId' must be defined.");
        url_ = url_.replace("{keyId}", encodeURIComponent("" + keyId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processKeys6(_response);
        });
    }

    protected processKeys6(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @keyId ID of key.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    keys7(keyId: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<UserKeysKeyId> {
        let url_ = this.baseUrl + "/user/keys/{keyId}";
        if (keyId === undefined || keyId === null)
            throw new Error("The parameter 'keyId' must be defined.");
        url_ = url_.replace("{keyId}", encodeURIComponent("" + keyId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processKeys7(_response);
        });
    }

    protected processKeys7(_response: Response): Promise<UserKeysKeyId> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: UserKeysKeyId = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserKeysKeyId.fromJS(resultData200) : new UserKeysKeyId();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    orgsAll(x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<any[]> {
        let url_ = this.baseUrl + "/user/orgs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrgsAll(_response);
        });
    }

    protected processOrgsAll(_response: Response): Promise<any[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: any[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    repos10(type: Type2, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous5[]> {
        let url_ = this.baseUrl + "/user/repos?";
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRepos10(_response);
        });
    }

    protected processRepos10(_response: Response): Promise<Anonymous5[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous5[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous5.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    repos11(x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number, body: PostRepo): Promise<Anonymous5[]> {
        let url_ = this.baseUrl + "/user/repos";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body ? body.toJSON() : null);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRepos11(_response);
        });
    }

    protected processRepos11(_response: Response): Promise<Anonymous5[]> {
        const _status = _response.status;
        if (_status === 201) {
            return _response.text().then((_responseText) => {
            let result201: Anonymous5[] = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData201 && resultData201.constructor === Array) {
                result201 = [];
                for (let item of resultData201)
                    result201.push(Anonymous5.fromJS(item));
            }
            return result201;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @direction Ignored without 'sort' parameter.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    starred(direction: string, sort: Sort15, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<any[]> {
        let url_ = this.baseUrl + "/user/starred?";
        if (direction !== undefined)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&"; 
        if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStarred(_response);
        });
    }

    protected processStarred(_response: Response): Promise<any[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: any[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of a repository owner.
     * @repo Name of a repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Unstarred.
     */
    starred2(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/user/starred/{owner}/{repo}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStarred2(_response);
        });
    }

    protected processStarred2(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of a repository owner.
     * @repo Name of a repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return This repository is starred by you.
     */
    starred3(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/user/starred/{owner}/{repo}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStarred3(_response);
        });
    }

    protected processStarred3(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status === 404) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of a repository owner.
     * @repo Name of a repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Repository starred.
     */
    starred4(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/user/starred/{owner}/{repo}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStarred4(_response);
        });
    }

    protected processStarred4(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    subscriptionsAll(x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous28[]> {
        let url_ = this.baseUrl + "/user/subscriptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubscriptionsAll(_response);
        });
    }

    protected processSubscriptionsAll(_response: Response): Promise<Anonymous28[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous28[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous28.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of the owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Unwatched.
     */
    subscriptions(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/user/subscriptions/{owner}/{repo}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubscriptions(_response);
        });
    }

    protected processSubscriptions(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of the owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Repository is watched by you.
     */
    subscriptions2(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/user/subscriptions/{owner}/{repo}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubscriptions2(_response);
        });
    }

    protected processSubscriptions2(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status === 404) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @owner Name of the owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Repository is watched.
     */
    subscriptions3(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/user/subscriptions/{owner}/{repo}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubscriptions3(_response);
        });
    }

    protected processSubscriptions3(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    teams6(x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous29[]> {
        let url_ = this.baseUrl + "/user/teams";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTeams6(_response);
        });
    }

    protected processTeams6(_response: Response): Promise<Anonymous29[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous29[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous29.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @since The integer ID of the last User that you've seen.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    usersAll(since: number, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous4[]> {
        let url_ = this.baseUrl + "/users?";
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersAll(_response);
        });
    }

    protected processUsersAll(_response: Response): Promise<Anonymous4[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous4[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous4.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    users2(username: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous4[]> {
        let url_ = this.baseUrl + "/users/{username}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsers2(_response);
        });
    }

    protected processUsers2(_response: Response): Promise<Anonymous4[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous4[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous4.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     */
    events8(username: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/users/{username}/events";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEvents8(_response);
        });
    }

    protected processEvents8(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     */
    orgs3(username: string, org: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/users/{username}/events/orgs/{org}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrgs3(_response);
        });
    }

    protected processOrgs3(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    followers(username: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous4[]> {
        let url_ = this.baseUrl + "/users/{username}/followers";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFollowers(_response);
        });
    }

    protected processFollowers(_response: Response): Promise<Anonymous4[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous4[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous4.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @username Name of user.
     * @targetUser Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Response if user follows target user.
     */
    following4(username: string, targetUser: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/users/{username}/following/{targetUser}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        if (targetUser === undefined || targetUser === null)
            throw new Error("The parameter 'targetUser' must be defined.");
        url_ = url_.replace("{targetUser}", encodeURIComponent("" + targetUser)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFollowing4(_response);
        });
    }

    protected processFollowing4(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status === 404) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @username Name of user.
     * @since The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
Example: "2012-10-09T23:39:01Z".
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    gists5(username: string, since: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous[]> {
        let url_ = this.baseUrl + "/users/{username}/gists?";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGists5(_response);
        });
    }

    protected processGists5(_response: Response): Promise<Anonymous[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    keys8(username: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<any[]> {
        let url_ = this.baseUrl + "/users/{username}/keys";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processKeys8(_response);
        });
    }

    protected processKeys8(_response: Response): Promise<any[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: any[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    orgs4(username: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<any[]> {
        let url_ = this.baseUrl + "/users/{username}/orgs";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrgs4(_response);
        });
    }

    protected processOrgs4(_response: Response): Promise<any[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: any[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     */
    public(username: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/users/{username}/received_events/public";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPublic(_response);
        });
    }

    protected processPublic(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    repos12(username: string, type: Type3, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous5[]> {
        let url_ = this.baseUrl + "/users/{username}/repos?";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRepos12(_response);
        });
    }

    protected processRepos12(_response: Response): Promise<Anonymous5[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous5[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous5.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     */
    starred5(username: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/users/{username}/starred";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStarred5(_response);
        });
    }

    protected processStarred5(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     */
    subscriptions4(username: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/users/{username}/subscriptions";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSubscriptions4(_response);
        });
    }

    protected processSubscriptions4(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }
}

class PublicClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    /**
     * @org Name of organisation.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    membersAll(org: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous4[]> {
        let url_ = this.baseUrl + "/orgs/{org}/public_members";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembersAll(_response);
        });
    }

    protected processMembersAll(_response: Response): Promise<Anonymous4[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous4[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous4.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @org Name of organisation.
     * @username Name of the user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Concealed.
     */
    members(org: string, username: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/orgs/{org}/public_members/{username}";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembers(_response);
        });
    }

    protected processMembers(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @org Name of organisation.
     * @username Name of the user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return User is a public member.
     */
    members2(org: string, username: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/orgs/{org}/public_members/{username}";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembers2(_response);
        });
    }

    protected processMembers2(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status === 404) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }

    /**
     * @org Name of organisation.
     * @username Name of the user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Publicized.
     */
    members3(org: string, username: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/orgs/{org}/public_members/{username}";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMembers3(_response);
        });
    }

    protected processMembers3(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 204) {
            return _response.text().then((_responseText) => {
            return null;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }
}

class RateClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    limit(x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Rate_limit> {
        let url_ = this.baseUrl + "/rate_limit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLimit(_response);
        });
    }

    protected processLimit(_response: Response): Promise<Rate_limit> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Rate_limit = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Rate_limit.fromJS(resultData200) : new Rate_limit();
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }
}

class CodeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    frequency(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<number[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/stats/code_frequency";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFrequency(_response);
        });
    }

    protected processFrequency(_response: Response): Promise<number[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: number[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }
}

class CommitClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    activity(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<Anonymous30[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/stats/commit_activity";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processActivity(_response);
        });
    }

    protected processActivity(_response: Response): Promise<Anonymous30[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: Anonymous30[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous30.fromJS(item));
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }
}

class PunchClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    card(owner: string, repo: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<number[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/stats/punch_card";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCard(_response);
        });
    }

    protected processCard(_response: Response): Promise<number[]> {
        const _status = _response.status;
        if (_status === 200) {
            return _response.text().then((_responseText) => {
            let result200: number[] = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return result200;
            });
        } else if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }
}

class ReceivedClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     */
    events(username: string, x_GitHub_Media_Type: string, accept: string, x_RateLimit_Limit: number, x_RateLimit_Remaining: number, x_RateLimit_Reset: number, x_GitHub_Request_Id: number): Promise<void> {
        let url_ = this.baseUrl + "/users/{username}/received_events";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEvents(_response);
        });
    }

    protected processEvents(_response: Response): Promise<void> {
        const _status = _response.status;
        if (_status === 403) {
            return _response.text().then((_responseText) => {
            return throwException("A server error occurred.", _status, _responseText);
            });
        } else if (_status !== 200 && _status !== 204) {
            return _response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", _status, _responseText);
            });
        }
        return Promise.resolve(null);
    }
}

class Asset implements IAsset {
    content_type?: string;
    created_at?: string;
    download_count?: number;
    id?: number;
    label?: string;
    name?: string;
    size?: number;
    state?: string;
    updated_at?: string;
    uploader?: Uploader;
    url?: string;

    constructor(data?: IAsset) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content_type = data["content_type"];
            this.created_at = data["created_at"];
            this.download_count = data["download_count"];
            this.id = data["id"];
            this.label = data["label"];
            this.name = data["name"];
            this.size = data["size"];
            this.state = data["state"];
            this.updated_at = data["updated_at"];
            this.uploader = data["uploader"] ? Uploader.fromJS(data["uploader"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Asset {
        let result = new Asset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["content_type"] = this.content_type;
        data["created_at"] = this.created_at;
        data["download_count"] = this.download_count;
        data["id"] = this.id;
        data["label"] = this.label;
        data["name"] = this.name;
        data["size"] = this.size;
        data["state"] = this.state;
        data["updated_at"] = this.updated_at;
        data["uploader"] = this.uploader ? this.uploader.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

interface IAsset {
    content_type?: string;
    created_at?: string;
    download_count?: number;
    id?: number;
    label?: string;
    name?: string;
    size?: number;
    state?: string;
    updated_at?: string;
    uploader?: Uploader;
    url?: string;
}

class AssetPatch implements IAssetPatch {
    label?: string;
    name: string;

    constructor(data?: IAssetPatch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): AssetPatch {
        let result = new AssetPatch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["label"] = this.label;
        data["name"] = this.name;
        return data; 
    }
}

interface IAssetPatch {
    label?: string;
    name: string;
}

class Blob implements IBlob {
    content?: string;
    encoding?: BlobEncoding;
    sha?: string;
    size?: number;

    constructor(data?: IBlob) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["content"];
            this.encoding = data["encoding"];
            this.sha = data["sha"];
            this.size = data["size"];
        }
    }

    static fromJS(data: any): Blob {
        let result = new Blob();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["content"] = this.content;
        data["encoding"] = this.encoding;
        data["sha"] = this.sha;
        data["size"] = this.size;
        return data; 
    }
}

interface IBlob {
    content?: string;
    encoding?: BlobEncoding;
    sha?: string;
    size?: number;
}

class Blobs implements IBlobs {
    sha?: string;

    constructor(data?: IBlobs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
        }
    }

    static fromJS(data: any): Blobs {
        let result = new Blobs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["sha"] = this.sha;
        return data; 
    }
}

interface IBlobs {
    sha?: string;
}

class Branch implements IBranch {
    _links?: _links;
    commit?: commit;
    name?: string;

    constructor(data?: IBranch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this._links = data["_links"] ? _links.fromJS(data["_links"]) : <any>undefined;
            this.commit = data["commit"] ? commit.fromJS(data["commit"]) : <any>undefined;
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Branch {
        let result = new Branch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
        data["commit"] = this.commit ? this.commit.toJSON() : <any>undefined;
        data["name"] = this.name;
        return data; 
    }
}

interface IBranch {
    _links?: _links;
    commit?: commit;
    name?: string;
}

class Comment implements IComment {
    body?: string;

    constructor(data?: IComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.body = data["body"];
        }
    }

    static fromJS(data: any): Comment {
        let result = new Comment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["body"] = this.body;
        return data; 
    }
}

interface IComment {
    body?: string;
}

class CommentBody implements ICommentBody {
    body: string;

    constructor(data?: ICommentBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.body = data["body"];
        }
    }

    static fromJS(data: any): CommentBody {
        let result = new CommentBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["body"] = this.body;
        return data; 
    }
}

interface ICommentBody {
    body: string;
}

class Commit implements ICommit {
    author?: Author;
    commit?: commit2;
    committer?: Committer;
    files?: Files[];
    parents?: Parents[];
    sha?: string;
    stats?: Stats;
    url?: string;

    constructor(data?: ICommit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? Author.fromJS(data["author"]) : <any>undefined;
            this.commit = data["commit"] ? commit2.fromJS(data["commit"]) : <any>undefined;
            this.committer = data["committer"] ? Committer.fromJS(data["committer"]) : <any>undefined;
            if (data["files"] && data["files"].constructor === Array) {
                this.files = [];
                for (let item of data["files"])
                    this.files.push(Files.fromJS(item));
            }
            if (data["parents"] && data["parents"].constructor === Array) {
                this.parents = [];
                for (let item of data["parents"])
                    this.parents.push(Parents.fromJS(item));
            }
            this.sha = data["sha"];
            this.stats = data["stats"] ? Stats.fromJS(data["stats"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Commit {
        let result = new Commit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["commit"] = this.commit ? this.commit.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        if (this.files && this.files.constructor === Array) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        if (this.parents && this.parents.constructor === Array) {
            data["parents"] = [];
            for (let item of this.parents)
                data["parents"].push(item.toJSON());
        }
        data["sha"] = this.sha;
        data["stats"] = this.stats ? this.stats.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

interface ICommit {
    author?: Author;
    commit?: commit2;
    committer?: Committer;
    files?: Files[];
    parents?: Parents[];
    sha?: string;
    stats?: Stats;
    url?: string;
}

class CommitBody implements ICommitBody {
    body: string;
    /** Deprecated - Use position parameter instead. */
    line?: string;
    /** Line number in the file to comment on. Defaults to null. */
    number?: string;
    /** Relative path of the file to comment on. */
    path?: string;
    /** Line index in the diff to comment on. */
    position?: number;
    /** SHA of the commit to comment on. */
    sha: string;

    constructor(data?: ICommitBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.body = data["body"];
            this.line = data["line"];
            this.number = data["number"];
            this.path = data["path"];
            this.position = data["position"];
            this.sha = data["sha"];
        }
    }

    static fromJS(data: any): CommitBody {
        let result = new CommitBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["body"] = this.body;
        data["line"] = this.line;
        data["number"] = this.number;
        data["path"] = this.path;
        data["position"] = this.position;
        data["sha"] = this.sha;
        return data; 
    }
}

interface ICommitBody {
    body: string;
    /** Deprecated - Use position parameter instead. */
    line?: string;
    /** Line number in the file to comment on. Defaults to null. */
    number?: string;
    /** Relative path of the file to comment on. */
    path?: string;
    /** Line index in the diff to comment on. */
    position?: number;
    /** SHA of the commit to comment on. */
    sha: string;
}

class CommitComments implements ICommitComments {
    body?: string;
    commit_id?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    html_url?: string;
    id?: number;
    line?: number;
    path?: string;
    position?: number;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    user?: user;

    constructor(data?: ICommitComments) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.body = data["body"];
            this.commit_id = data["commit_id"];
            this.created_at = data["created_at"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.line = data["line"];
            this.path = data["path"];
            this.position = data["position"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.user = data["user"] ? user.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CommitComments {
        let result = new CommitComments();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["body"] = this.body;
        data["commit_id"] = this.commit_id;
        data["created_at"] = this.created_at;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["line"] = this.line;
        data["path"] = this.path;
        data["position"] = this.position;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

interface ICommitComments {
    body?: string;
    commit_id?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    html_url?: string;
    id?: number;
    line?: number;
    path?: string;
    position?: number;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    user?: user;
}

class CompareCommits implements ICompareCommits {
    ahead_by?: number;
    base_commit?: Base_commit;
    behind_by?: number;
    commits?: Commits[];
    diff_url?: string;
    files?: files[];
    html_url?: string;
    patch_url?: string;
    permalink_url?: string;
    status?: string;
    total_commits?: number;
    url?: string;

    constructor(data?: ICompareCommits) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ahead_by = data["ahead_by"];
            this.base_commit = data["base_commit"] ? Base_commit.fromJS(data["base_commit"]) : <any>undefined;
            this.behind_by = data["behind_by"];
            if (data["commits"] && data["commits"].constructor === Array) {
                this.commits = [];
                for (let item of data["commits"])
                    this.commits.push(Commits.fromJS(item));
            }
            this.diff_url = data["diff_url"];
            if (data["files"] && data["files"].constructor === Array) {
                this.files = [];
                for (let item of data["files"])
                    this.files.push(files.fromJS(item));
            }
            this.html_url = data["html_url"];
            this.patch_url = data["patch_url"];
            this.permalink_url = data["permalink_url"];
            this.status = data["status"];
            this.total_commits = data["total_commits"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): CompareCommits {
        let result = new CompareCommits();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["ahead_by"] = this.ahead_by;
        data["base_commit"] = this.base_commit ? this.base_commit.toJSON() : <any>undefined;
        data["behind_by"] = this.behind_by;
        if (this.commits && this.commits.constructor === Array) {
            data["commits"] = [];
            for (let item of this.commits)
                data["commits"].push(item.toJSON());
        }
        data["diff_url"] = this.diff_url;
        if (this.files && this.files.constructor === Array) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["html_url"] = this.html_url;
        data["patch_url"] = this.patch_url;
        data["permalink_url"] = this.permalink_url;
        data["status"] = this.status;
        data["total_commits"] = this.total_commits;
        data["url"] = this.url;
        return data; 
    }
}

interface ICompareCommits {
    ahead_by?: number;
    base_commit?: Base_commit;
    behind_by?: number;
    commits?: Commits[];
    diff_url?: string;
    files?: files[];
    html_url?: string;
    patch_url?: string;
    permalink_url?: string;
    status?: string;
    total_commits?: number;
    url?: string;
}

class ContentsPath implements IContentsPath {
    _links?: _links2;
    content?: string;
    encoding?: string;
    git_url?: string;
    html_url?: string;
    name?: string;
    path?: string;
    sha?: string;
    size?: number;
    type?: string;
    url?: string;

    constructor(data?: IContentsPath) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this._links = data["_links"] ? _links2.fromJS(data["_links"]) : <any>undefined;
            this.content = data["content"];
            this.encoding = data["encoding"];
            this.git_url = data["git_url"];
            this.html_url = data["html_url"];
            this.name = data["name"];
            this.path = data["path"];
            this.sha = data["sha"];
            this.size = data["size"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): ContentsPath {
        let result = new ContentsPath();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
        data["content"] = this.content;
        data["encoding"] = this.encoding;
        data["git_url"] = this.git_url;
        data["html_url"] = this.html_url;
        data["name"] = this.name;
        data["path"] = this.path;
        data["sha"] = this.sha;
        data["size"] = this.size;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface IContentsPath {
    _links?: _links2;
    content?: string;
    encoding?: string;
    git_url?: string;
    html_url?: string;
    name?: string;
    path?: string;
    sha?: string;
    size?: number;
    type?: string;
    url?: string;
}

class CreateDownload implements ICreateDownload {
    accesskeyid?: string;
    acl?: string;
    bucket?: string;
    content_type?: string;
    description?: string;
    download_count?: number;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    expirationdate?: string;
    html_url?: string;
    id?: number;
    mime_type?: string;
    name?: string;
    path?: string;
    policy?: string;
    prefix?: string;
    redirect?: boolean;
    s3_url?: string;
    signature?: string;
    size?: number;
    url?: string;

    constructor(data?: ICreateDownload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accesskeyid = data["accesskeyid"];
            this.acl = data["acl"];
            this.bucket = data["bucket"];
            this.content_type = data["content_type"];
            this.description = data["description"];
            this.download_count = data["download_count"];
            this.expirationdate = data["expirationdate"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.mime_type = data["mime_type"];
            this.name = data["name"];
            this.path = data["path"];
            this.policy = data["policy"];
            this.prefix = data["prefix"];
            this.redirect = data["redirect"];
            this.s3_url = data["s3_url"];
            this.signature = data["signature"];
            this.size = data["size"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): CreateDownload {
        let result = new CreateDownload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["accesskeyid"] = this.accesskeyid;
        data["acl"] = this.acl;
        data["bucket"] = this.bucket;
        data["content_type"] = this.content_type;
        data["description"] = this.description;
        data["download_count"] = this.download_count;
        data["expirationdate"] = this.expirationdate;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["mime_type"] = this.mime_type;
        data["name"] = this.name;
        data["path"] = this.path;
        data["policy"] = this.policy;
        data["prefix"] = this.prefix;
        data["redirect"] = this.redirect;
        data["s3_url"] = this.s3_url;
        data["signature"] = this.signature;
        data["size"] = this.size;
        data["url"] = this.url;
        return data; 
    }
}

interface ICreateDownload {
    accesskeyid?: string;
    acl?: string;
    bucket?: string;
    content_type?: string;
    description?: string;
    download_count?: number;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    expirationdate?: string;
    html_url?: string;
    id?: number;
    mime_type?: string;
    name?: string;
    path?: string;
    policy?: string;
    prefix?: string;
    redirect?: boolean;
    s3_url?: string;
    signature?: string;
    size?: number;
    url?: string;
}

class CreateFile implements ICreateFile {
    commit?: commit3;
    content?: Content;

    constructor(data?: ICreateFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.commit = data["commit"] ? commit3.fromJS(data["commit"]) : <any>undefined;
            this.content = data["content"] ? Content.fromJS(data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateFile {
        let result = new CreateFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["commit"] = this.commit ? this.commit.toJSON() : <any>undefined;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data; 
    }
}

interface ICreateFile {
    commit?: commit3;
    content?: Content;
}

class CreateFileBody implements ICreateFileBody {
    committer?: committer;
    content?: string;
    message?: string;

    constructor(data?: ICreateFileBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.committer = data["committer"] ? committer.fromJS(data["committer"]) : <any>undefined;
            this.content = data["content"];
            this.message = data["message"];
        }
    }

    static fromJS(data: any): CreateFileBody {
        let result = new CreateFileBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        data["content"] = this.content;
        data["message"] = this.message;
        return data; 
    }
}

interface ICreateFileBody {
    committer?: committer;
    content?: string;
    message?: string;
}

class DeleteFile implements IDeleteFile {
    commit?: commit4;
    content?: string;

    constructor(data?: IDeleteFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.commit = data["commit"] ? commit4.fromJS(data["commit"]) : <any>undefined;
            this.content = data["content"];
        }
    }

    static fromJS(data: any): DeleteFile {
        let result = new DeleteFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["commit"] = this.commit ? this.commit.toJSON() : <any>undefined;
        data["content"] = this.content;
        return data; 
    }
}

interface IDeleteFile {
    commit?: commit4;
    content?: string;
}

class DeleteFileBody implements IDeleteFileBody {
    committer?: committer2;
    message?: string;
    sha?: string;

    constructor(data?: IDeleteFileBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.committer = data["committer"] ? committer2.fromJS(data["committer"]) : <any>undefined;
            this.message = data["message"];
            this.sha = data["sha"];
        }
    }

    static fromJS(data: any): DeleteFileBody {
        let result = new DeleteFileBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["sha"] = this.sha;
        return data; 
    }
}

interface IDeleteFileBody {
    committer?: committer2;
    message?: string;
    sha?: string;
}

class Deployment implements IDeployment {
    description?: string;
    payload?: Payload;
    ref?: string;

    constructor(data?: IDeployment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.payload = data["payload"] ? Payload.fromJS(data["payload"]) : <any>undefined;
            this.ref = data["ref"];
        }
    }

    static fromJS(data: any): Deployment {
        let result = new Deployment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["description"] = this.description;
        data["payload"] = this.payload ? this.payload.toJSON() : <any>undefined;
        data["ref"] = this.ref;
        return data; 
    }
}

interface IDeployment {
    description?: string;
    payload?: Payload;
    ref?: string;
}

class DeploymentResp implements IDeploymentResp {
    created_at?: string;
    creator?: Creator;
    description?: string;
    id?: number;
    payload?: string;
    sha?: string;
    statuses_url?: string;
    updated_at?: string;
    url?: string;

    constructor(data?: IDeploymentResp) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.created_at = data["created_at"];
            this.creator = data["creator"] ? Creator.fromJS(data["creator"]) : <any>undefined;
            this.description = data["description"];
            this.id = data["id"];
            this.payload = data["payload"];
            this.sha = data["sha"];
            this.statuses_url = data["statuses_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): DeploymentResp {
        let result = new DeploymentResp();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["created_at"] = this.created_at;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["id"] = this.id;
        data["payload"] = this.payload;
        data["sha"] = this.sha;
        data["statuses_url"] = this.statuses_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        return data; 
    }
}

interface IDeploymentResp {
    created_at?: string;
    creator?: Creator;
    description?: string;
    id?: number;
    payload?: string;
    sha?: string;
    statuses_url?: string;
    updated_at?: string;
    url?: string;
}

class DeploymentStatusesCreate implements IDeploymentStatusesCreate {
    description?: string;
    state?: string;
    target_url?: string;

    constructor(data?: IDeploymentStatusesCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.state = data["state"];
            this.target_url = data["target_url"];
        }
    }

    static fromJS(data: any): DeploymentStatusesCreate {
        let result = new DeploymentStatusesCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["description"] = this.description;
        data["state"] = this.state;
        data["target_url"] = this.target_url;
        return data; 
    }
}

interface IDeploymentStatusesCreate {
    description?: string;
    state?: string;
    target_url?: string;
}

class DownloadBody implements IDownloadBody {
    content_type?: string;
    description?: string;
    name: string;
    /** Size of file in bytes. */
    size: number;

    constructor(data?: IDownloadBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content_type = data["content_type"];
            this.description = data["description"];
            this.name = data["name"];
            this.size = data["size"];
        }
    }

    static fromJS(data: any): DownloadBody {
        let result = new DownloadBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["content_type"] = this.content_type;
        data["description"] = this.description;
        data["name"] = this.name;
        data["size"] = this.size;
        return data; 
    }
}

interface IDownloadBody {
    content_type?: string;
    description?: string;
    name: string;
    /** Size of file in bytes. */
    size: number;
}

class Downloads implements IDownloads {
    content_type?: string;
    description?: string;
    download_count?: number;
    html_url?: string;
    id?: number;
    name?: string;
    size?: number;
    url?: string;

    constructor(data?: IDownloads) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content_type = data["content_type"];
            this.description = data["description"];
            this.download_count = data["download_count"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.name = data["name"];
            this.size = data["size"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Downloads {
        let result = new Downloads();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["content_type"] = this.content_type;
        data["description"] = this.description;
        data["download_count"] = this.download_count;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["name"] = this.name;
        data["size"] = this.size;
        data["url"] = this.url;
        return data; 
    }
}

interface IDownloads {
    content_type?: string;
    description?: string;
    download_count?: number;
    html_url?: string;
    id?: number;
    name?: string;
    size?: number;
    url?: string;
}

class EditTeam implements IEditTeam {
    name: string;
    permission?: EditTeamPermission;

    constructor(data?: IEditTeam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.permission = data["permission"] ? EditTeamPermission.fromJS(data["permission"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EditTeam {
        let result = new EditTeam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["name"] = this.name;
        data["permission"] = this.permission ? this.permission.toJSON() : <any>undefined;
        return data; 
    }
}

interface IEditTeam {
    name: string;
    permission?: EditTeamPermission;
}

class Emojis implements IEmojis {
    _100?: string;
    _1234?: string;
    _1?: string;
    _8ball?: string;
    a?: string;
    ab?: string;

    constructor(data?: IEmojis) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this._100 = data["100"];
            this._1234 = data["1234"];
            this["+1"] = data["+1"];
            this._1 = data["-1"];
            this._8ball = data["8ball"];
            this.a = data["a"];
            this.ab = data["ab"];
        }
    }

    static fromJS(data: any): Emojis {
        let result = new Emojis();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["100"] = this._100;
        data["1234"] = this._1234;
        data["+1"] = this["+1"];
        data["-1"] = this._1;
        data["8ball"] = this._8ball;
        data["a"] = this.a;
        data["ab"] = this.ab;
        return data; 
    }
}

interface IEmojis {
    _100?: string;
    _1234?: string;
    _1?: string;
    _8ball?: string;
    a?: string;
    ab?: string;
}

class Event implements IEvent {
    actor?: Actor;
    commit_id?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    event?: string;
    issue?: issue;
    url?: string;

    constructor(data?: IEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.actor = data["actor"] ? Actor.fromJS(data["actor"]) : <any>undefined;
            this.commit_id = data["commit_id"];
            this.created_at = data["created_at"];
            this.event = data["event"];
            this.issue = data["issue"] ? issue.fromJS(data["issue"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Event {
        let result = new Event();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["actor"] = this.actor ? this.actor.toJSON() : <any>undefined;
        data["commit_id"] = this.commit_id;
        data["created_at"] = this.created_at;
        data["event"] = this.event;
        data["issue"] = this.issue ? this.issue.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

interface IEvent {
    actor?: Actor;
    commit_id?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    event?: string;
    issue?: issue;
    url?: string;
}

class Events implements IEvents {
    actor?: actor;
    created_at?: any;
    id?: number;
    org?: Org;
    payload?: any;
    public?: boolean;
    repo?: repo;
    type?: string;

    constructor(data?: IEvents) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.actor = data["actor"] ? actor.fromJS(data["actor"]) : <any>undefined;
            if (data["created_at"]) {
                this.created_at = {};
                for (let key in data["created_at"]) {
                    if (data["created_at"].hasOwnProperty(key))
                        this.created_at[key] = data["created_at"][key];
                }
            }
            this.id = data["id"];
            this.org = data["org"] ? Org.fromJS(data["org"]) : <any>undefined;
            if (data["payload"]) {
                this.payload = {};
                for (let key in data["payload"]) {
                    if (data["payload"].hasOwnProperty(key))
                        this.payload[key] = data["payload"][key];
                }
            }
            this.public = data["public"];
            this.repo = data["repo"] ? repo.fromJS(data["repo"]) : <any>undefined;
            this.type = data["type"];
        }
    }

    static fromJS(data: any): Events {
        let result = new Events();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["actor"] = this.actor ? this.actor.toJSON() : <any>undefined;
        if (this.created_at) {
            data["created_at"] = {};
            for (let key in this.created_at) {
                if (this.created_at.hasOwnProperty(key))
                    data["created_at"][key] = this.created_at[key];
            }
        }
        data["id"] = this.id;
        data["org"] = this.org ? this.org.toJSON() : <any>undefined;
        if (this.payload) {
            data["payload"] = {};
            for (let key in this.payload) {
                if (this.payload.hasOwnProperty(key))
                    data["payload"][key] = this.payload[key];
            }
        }
        data["public"] = this.public;
        data["repo"] = this.repo ? this.repo.toJSON() : <any>undefined;
        data["type"] = this.type;
        return data; 
    }
}

interface IEvents {
    actor?: actor;
    created_at?: any;
    id?: number;
    org?: Org;
    payload?: any;
    public?: boolean;
    repo?: repo;
    type?: string;
}

class Feeds implements IFeeds {
    _links?: _links3;
    current_user_actor_url?: string;
    current_user_organization_url?: string;
    current_user_public?: string;
    current_user_url?: string;
    timeline_url?: string;
    user_url?: string;

    constructor(data?: IFeeds) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this._links = data["_links"] ? _links3.fromJS(data["_links"]) : <any>undefined;
            this.current_user_actor_url = data["current_user_actor_url"];
            this.current_user_organization_url = data["current_user_organization_url"];
            this.current_user_public = data["current_user_public"];
            this.current_user_url = data["current_user_url"];
            this.timeline_url = data["timeline_url"];
            this.user_url = data["user_url"];
        }
    }

    static fromJS(data: any): Feeds {
        let result = new Feeds();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
        data["current_user_actor_url"] = this.current_user_actor_url;
        data["current_user_organization_url"] = this.current_user_organization_url;
        data["current_user_public"] = this.current_user_public;
        data["current_user_url"] = this.current_user_url;
        data["timeline_url"] = this.timeline_url;
        data["user_url"] = this.user_url;
        return data; 
    }
}

interface IFeeds {
    _links?: _links3;
    current_user_actor_url?: string;
    current_user_organization_url?: string;
    current_user_public?: string;
    current_user_url?: string;
    timeline_url?: string;
    user_url?: string;
}

class Fork implements IFork {
    clone_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    description?: string;
    fork?: boolean;
    forks?: number;
    forks_count?: number;
    full_name?: string;
    git_url?: string;
    homepage?: string;
    html_url?: string;
    id?: number;
    language?: string;
    master_branch?: string;
    mirror_url?: string;
    name?: string;
    open_issues?: number;
    open_issues_count?: number;
    owner?: Owner;
    private?: boolean;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string;
    size?: number;
    ssh_url?: string;
    svn_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    watchers?: number;
    watchers_count?: number;

    constructor(data?: IFork) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clone_url = data["clone_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.forks_count = data["forks_count"];
            this.full_name = data["full_name"];
            this.git_url = data["git_url"];
            this.homepage = data["homepage"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.language = data["language"];
            this.master_branch = data["master_branch"];
            this.mirror_url = data["mirror_url"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.open_issues_count = data["open_issues_count"];
            this.owner = data["owner"] ? Owner.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.pushed_at = data["pushed_at"];
            this.size = data["size"];
            this.ssh_url = data["ssh_url"];
            this.svn_url = data["svn_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.watchers = data["watchers"];
            this.watchers_count = data["watchers_count"];
        }
    }

    static fromJS(data: any): Fork {
        let result = new Fork();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["clone_url"] = this.clone_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["forks_count"] = this.forks_count;
        data["full_name"] = this.full_name;
        data["git_url"] = this.git_url;
        data["homepage"] = this.homepage;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["language"] = this.language;
        data["master_branch"] = this.master_branch;
        data["mirror_url"] = this.mirror_url;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["open_issues_count"] = this.open_issues_count;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pushed_at"] = this.pushed_at;
        data["size"] = this.size;
        data["ssh_url"] = this.ssh_url;
        data["svn_url"] = this.svn_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["watchers"] = this.watchers;
        data["watchers_count"] = this.watchers_count;
        return data; 
    }
}

interface IFork {
    clone_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    description?: string;
    fork?: boolean;
    forks?: number;
    forks_count?: number;
    full_name?: string;
    git_url?: string;
    homepage?: string;
    html_url?: string;
    id?: number;
    language?: string;
    master_branch?: string;
    mirror_url?: string;
    name?: string;
    open_issues?: number;
    open_issues_count?: number;
    owner?: Owner;
    private?: boolean;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string;
    size?: number;
    ssh_url?: string;
    svn_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    watchers?: number;
    watchers_count?: number;
}

class ForkBody implements IForkBody {
    organization?: string;

    constructor(data?: IForkBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organization = data["organization"];
        }
    }

    static fromJS(data: any): ForkBody {
        let result = new ForkBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["organization"] = this.organization;
        return data; 
    }
}

interface IForkBody {
    organization?: string;
}

class Gist implements IGist {
    comments?: number;
    comments_url?: string;
    /** Timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. */
    created_at?: string;
    description?: string;
    files?: files2;
    forks?: Forks[];
    git_pull_url?: string;
    git_push_url?: string;
    history?: History[];
    html_url?: string;
    id?: string;
    public?: boolean;
    url?: string;
    user?: user2;

    constructor(data?: IGist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.comments = data["comments"];
            this.comments_url = data["comments_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.files = data["files"] ? files2.fromJS(data["files"]) : <any>undefined;
            if (data["forks"] && data["forks"].constructor === Array) {
                this.forks = [];
                for (let item of data["forks"])
                    this.forks.push(Forks.fromJS(item));
            }
            this.git_pull_url = data["git_pull_url"];
            this.git_push_url = data["git_push_url"];
            if (data["history"] && data["history"].constructor === Array) {
                this.history = [];
                for (let item of data["history"])
                    this.history.push(History.fromJS(item));
            }
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.public = data["public"];
            this.url = data["url"];
            this.user = data["user"] ? user2.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Gist {
        let result = new Gist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["comments"] = this.comments;
        data["comments_url"] = this.comments_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["files"] = this.files ? this.files.toJSON() : <any>undefined;
        if (this.forks && this.forks.constructor === Array) {
            data["forks"] = [];
            for (let item of this.forks)
                data["forks"].push(item.toJSON());
        }
        data["git_pull_url"] = this.git_pull_url;
        data["git_push_url"] = this.git_push_url;
        if (this.history && this.history.constructor === Array) {
            data["history"] = [];
            for (let item of this.history)
                data["history"].push(item.toJSON());
        }
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["public"] = this.public;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

interface IGist {
    comments?: number;
    comments_url?: string;
    /** Timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. */
    created_at?: string;
    description?: string;
    files?: files2;
    forks?: Forks[];
    git_pull_url?: string;
    git_push_url?: string;
    history?: History[];
    html_url?: string;
    id?: string;
    public?: boolean;
    url?: string;
    user?: user2;
}

class GitCommit implements IGitCommit {
    author?: author;
    message?: string;
    parents?: string;
    tree?: string;

    constructor(data?: IGitCommit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? author.fromJS(data["author"]) : <any>undefined;
            this.message = data["message"];
            this.parents = data["parents"];
            this.tree = data["tree"];
        }
    }

    static fromJS(data: any): GitCommit {
        let result = new GitCommit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["parents"] = this.parents;
        data["tree"] = this.tree;
        return data; 
    }
}

interface IGitCommit {
    author?: author;
    message?: string;
    parents?: string;
    tree?: string;
}

class GitRefPatch implements IGitRefPatch {
    force?: boolean;
    sha?: string;

    constructor(data?: IGitRefPatch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.force = data["force"];
            this.sha = data["sha"];
        }
    }

    static fromJS(data: any): GitRefPatch {
        let result = new GitRefPatch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["force"] = this.force;
        data["sha"] = this.sha;
        return data; 
    }
}

interface IGitRefPatch {
    force?: boolean;
    sha?: string;
}

class GitignoreLang implements IGitignoreLang {
    name?: string;
    source?: string;

    constructor(data?: IGitignoreLang) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.source = data["source"];
        }
    }

    static fromJS(data: any): GitignoreLang {
        let result = new GitignoreLang();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["name"] = this.name;
        data["source"] = this.source;
        return data; 
    }
}

interface IGitignoreLang {
    name?: string;
    source?: string;
}

class HeadBranch implements IHeadBranch {
    object?: ObjectP;
    ref?: string;
    url?: string;

    constructor(data?: IHeadBranch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.object = data["object"] ? ObjectP.fromJS(data["object"]) : <any>undefined;
            this.ref = data["ref"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): HeadBranch {
        let result = new HeadBranch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["object"] = this.object ? this.object.toJSON() : <any>undefined;
        data["ref"] = this.ref;
        data["url"] = this.url;
        return data; 
    }
}

interface IHeadBranch {
    object?: ObjectP;
    ref?: string;
    url?: string;
}

class HeadBranchBody implements IHeadBranchBody {
    /** Boolean indicating whether to force the update or to make sure the update is a fast-forward update. The default is false, so leaving this out or setting it to false will make sure youre not overwriting work. */
    force: boolean;
    /** String of the SHA1 value to set this reference to. */
    sha: string;

    constructor(data?: IHeadBranchBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.force = data["force"];
            this.sha = data["sha"];
        }
    }

    static fromJS(data: any): HeadBranchBody {
        let result = new HeadBranchBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["force"] = this.force;
        data["sha"] = this.sha;
        return data; 
    }
}

interface IHeadBranchBody {
    /** Boolean indicating whether to force the update or to make sure the update is a fast-forward update. The default is false, so leaving this out or setting it to false will make sure youre not overwriting work. */
    force: boolean;
    /** String of the SHA1 value to set this reference to. */
    sha: string;
}

class HookBody implements IHookBody {
    active?: boolean;
    add_events?: string[];

    constructor(data?: IHookBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.active = data["active"];
            if (data["add_events"] && data["add_events"].constructor === Array) {
                this.add_events = [];
                for (let item of data["add_events"])
                    this.add_events.push(item);
            }
        }
    }

    static fromJS(data: any): HookBody {
        let result = new HookBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["active"] = this.active;
        if (this.add_events && this.add_events.constructor === Array) {
            data["add_events"] = [];
            for (let item of this.add_events)
                data["add_events"].push(item);
        }
        return data; 
    }
}

interface IHookBody {
    active?: boolean;
    add_events?: string[];
}

class Issue implements IIssue {
    assignee?: string;
    body?: string;
    labels?: string[];
    milestone?: number;
    title?: string;

    constructor(data?: IIssue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assignee = data["assignee"];
            this.body = data["body"];
            if (data["labels"] && data["labels"].constructor === Array) {
                this.labels = [];
                for (let item of data["labels"])
                    this.labels.push(item);
            }
            this.milestone = data["milestone"];
            this.title = data["title"];
        }
    }

    static fromJS(data: any): Issue {
        let result = new Issue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["assignee"] = this.assignee;
        data["body"] = this.body;
        if (this.labels && this.labels.constructor === Array) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item);
        }
        data["milestone"] = this.milestone;
        data["title"] = this.title;
        return data; 
    }
}

interface IIssue {
    assignee?: string;
    body?: string;
    labels?: string[];
    milestone?: number;
    title?: string;
}

class IssueBody implements IIssueBody {
    assignee?: string;
    body?: string;
    labels?: string[];
    milestone?: number;
    title?: string;

    constructor(data?: IIssueBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assignee = data["assignee"];
            this.body = data["body"];
            if (data["labels"] && data["labels"].constructor === Array) {
                this.labels = [];
                for (let item of data["labels"])
                    this.labels.push(item);
            }
            this.milestone = data["milestone"];
            this.title = data["title"];
        }
    }

    static fromJS(data: any): IssueBody {
        let result = new IssueBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["assignee"] = this.assignee;
        data["body"] = this.body;
        if (this.labels && this.labels.constructor === Array) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item);
        }
        data["milestone"] = this.milestone;
        data["title"] = this.title;
        return data; 
    }
}

interface IIssueBody {
    assignee?: string;
    body?: string;
    labels?: string[];
    milestone?: number;
    title?: string;
}

class IssuesComment implements IIssuesComment {
    body?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    html_url?: string;
    id?: number;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    user?: user3;

    constructor(data?: IIssuesComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.body = data["body"];
            this.created_at = data["created_at"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.user = data["user"] ? user3.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IssuesComment {
        let result = new IssuesComment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["body"] = this.body;
        data["created_at"] = this.created_at;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

interface IIssuesComment {
    body?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    html_url?: string;
    id?: number;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    user?: user3;
}

class Key implements IKey {
    id?: number;
    key?: string;
    title?: string;
    url?: string;

    constructor(data?: IKey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.key = data["key"];
            this.title = data["title"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Key {
        let result = new Key();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["title"] = this.title;
        data["url"] = this.url;
        return data; 
    }
}

interface IKey {
    id?: number;
    key?: string;
    title?: string;
    url?: string;
}

class KeyBody implements IKeyBody {
    key?: string;
    title?: string;

    constructor(data?: IKeyBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.title = data["title"];
        }
    }

    static fromJS(data: any): KeyBody {
        let result = new KeyBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["key"] = this.key;
        data["title"] = this.title;
        return data; 
    }
}

interface IKeyBody {
    key?: string;
    title?: string;
}

class Label implements ILabel {
    color?: string;
    name?: string;
    url?: string;

    constructor(data?: ILabel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.color = data["color"];
            this.name = data["name"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Label {
        let result = new Label();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["color"] = this.color;
        data["name"] = this.name;
        data["url"] = this.url;
        return data; 
    }
}

interface ILabel {
    color?: string;
    name?: string;
    url?: string;
}

class Markdown implements IMarkdown {
    context?: string;
    mode?: string;
    text?: string;

    constructor(data?: IMarkdown) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.context = data["context"];
            this.mode = data["mode"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): Markdown {
        let result = new Markdown();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["context"] = this.context;
        data["mode"] = this.mode;
        data["text"] = this.text;
        return data; 
    }
}

interface IMarkdown {
    context?: string;
    mode?: string;
    text?: string;
}

class Merge implements IMerge {
    merged?: boolean;
    message?: string;
    sha?: string;

    constructor(data?: IMerge) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.merged = data["merged"];
            this.message = data["message"];
            this.sha = data["sha"];
        }
    }

    static fromJS(data: any): Merge {
        let result = new Merge();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["merged"] = this.merged;
        data["message"] = this.message;
        data["sha"] = this.sha;
        return data; 
    }
}

interface IMerge {
    merged?: boolean;
    message?: string;
    sha?: string;
}

class MergePullBody implements IMergePullBody {
    commit_message?: string;

    constructor(data?: IMergePullBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.commit_message = data["commit_message"];
        }
    }

    static fromJS(data: any): MergePullBody {
        let result = new MergePullBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["commit_message"] = this.commit_message;
        return data; 
    }
}

interface IMergePullBody {
    commit_message?: string;
}

class MergesBody implements IMergesBody {
    base?: string;
    commit_message?: string;
    head?: string;

    constructor(data?: IMergesBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.base = data["base"];
            this.commit_message = data["commit_message"];
            this.head = data["head"];
        }
    }

    static fromJS(data: any): MergesBody {
        let result = new MergesBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["base"] = this.base;
        data["commit_message"] = this.commit_message;
        data["head"] = this.head;
        return data; 
    }
}

interface IMergesBody {
    base?: string;
    commit_message?: string;
    head?: string;
}

class MergesConflict implements IMergesConflict {
    /** Error message */
    message?: string;

    constructor(data?: IMergesConflict) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.message = data["message"];
        }
    }

    static fromJS(data: any): MergesConflict {
        let result = new MergesConflict();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["message"] = this.message;
        return data; 
    }
}

interface IMergesConflict {
    /** Error message */
    message?: string;
}

class MergesSuccessful implements IMergesSuccessful {
    author?: author2;
    comments_url?: string;
    commit?: commit5;
    committer?: committer3;
    merged?: boolean;
    message?: string;
    parents?: parents[];
    sha?: string;
    url?: string;

    constructor(data?: IMergesSuccessful) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? author2.fromJS(data["author"]) : <any>undefined;
            this.comments_url = data["comments_url"];
            this.commit = data["commit"] ? commit5.fromJS(data["commit"]) : <any>undefined;
            this.committer = data["committer"] ? committer3.fromJS(data["committer"]) : <any>undefined;
            this.merged = data["merged"];
            this.message = data["message"];
            if (data["parents"] && data["parents"].constructor === Array) {
                this.parents = [];
                for (let item of data["parents"])
                    this.parents.push(parents.fromJS(item));
            }
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): MergesSuccessful {
        let result = new MergesSuccessful();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["comments_url"] = this.comments_url;
        data["commit"] = this.commit ? this.commit.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        data["merged"] = this.merged;
        data["message"] = this.message;
        if (this.parents && this.parents.constructor === Array) {
            data["parents"] = [];
            for (let item of this.parents)
                data["parents"].push(item.toJSON());
        }
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

interface IMergesSuccessful {
    author?: author2;
    comments_url?: string;
    commit?: commit5;
    committer?: committer3;
    merged?: boolean;
    message?: string;
    parents?: parents[];
    sha?: string;
    url?: string;
}

class Meta implements IMeta {
    git?: string[];
    hooks?: string[];

    constructor(data?: IMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["git"] && data["git"].constructor === Array) {
                this.git = [];
                for (let item of data["git"])
                    this.git.push(item);
            }
            if (data["hooks"] && data["hooks"].constructor === Array) {
                this.hooks = [];
                for (let item of data["hooks"])
                    this.hooks.push(item);
            }
        }
    }

    static fromJS(data: any): Meta {
        let result = new Meta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        if (this.git && this.git.constructor === Array) {
            data["git"] = [];
            for (let item of this.git)
                data["git"].push(item);
        }
        if (this.hooks && this.hooks.constructor === Array) {
            data["hooks"] = [];
            for (let item of this.hooks)
                data["hooks"].push(item);
        }
        return data; 
    }
}

interface IMeta {
    git?: string[];
    hooks?: string[];
}

class Milestone implements IMilestone {
    closed_issues?: number;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    creator?: creator;
    description?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    due_on?: string;
    number?: number;
    open_issues?: number;
    state?: MilestoneState;
    title?: string;
    url?: string;

    constructor(data?: IMilestone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.closed_issues = data["closed_issues"];
            this.created_at = data["created_at"];
            this.creator = data["creator"] ? creator.fromJS(data["creator"]) : <any>undefined;
            this.description = data["description"];
            this.due_on = data["due_on"];
            this.number = data["number"];
            this.open_issues = data["open_issues"];
            this.state = data["state"] ? MilestoneState.fromJS(data["state"]) : <any>undefined;
            this.title = data["title"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Milestone {
        let result = new Milestone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["closed_issues"] = this.closed_issues;
        data["created_at"] = this.created_at;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["due_on"] = this.due_on;
        data["number"] = this.number;
        data["open_issues"] = this.open_issues;
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["url"] = this.url;
        return data; 
    }
}

interface IMilestone {
    closed_issues?: number;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    creator?: creator;
    description?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    due_on?: string;
    number?: number;
    open_issues?: number;
    state?: MilestoneState;
    title?: string;
    url?: string;
}

class MilestoneBody implements IMilestoneBody {
    description?: string;
    due_on?: string;
    state?: string;
    title?: string;

    constructor(data?: IMilestoneBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.due_on = data["due_on"];
            this.state = data["state"];
            this.title = data["title"];
        }
    }

    static fromJS(data: any): MilestoneBody {
        let result = new MilestoneBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["description"] = this.description;
        data["due_on"] = this.due_on;
        data["state"] = this.state;
        data["title"] = this.title;
        return data; 
    }
}

interface IMilestoneBody {
    description?: string;
    due_on?: string;
    state?: string;
    title?: string;
}

class MilestoneUpdate implements IMilestoneUpdate {
    description?: string;
    due_on?: string;
    state?: string;
    title?: string;

    constructor(data?: IMilestoneUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.due_on = data["due_on"];
            this.state = data["state"];
            this.title = data["title"];
        }
    }

    static fromJS(data: any): MilestoneUpdate {
        let result = new MilestoneUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["description"] = this.description;
        data["due_on"] = this.due_on;
        data["state"] = this.state;
        data["title"] = this.title;
        return data; 
    }
}

interface IMilestoneUpdate {
    description?: string;
    due_on?: string;
    state?: string;
    title?: string;
}

class NotificationMarkRead implements INotificationMarkRead {
    last_read_at?: string;

    constructor(data?: INotificationMarkRead) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.last_read_at = data["last_read_at"];
        }
    }

    static fromJS(data: any): NotificationMarkRead {
        let result = new NotificationMarkRead();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["last_read_at"] = this.last_read_at;
        return data; 
    }
}

interface INotificationMarkRead {
    last_read_at?: string;
}

class Notifications implements INotifications {
    id?: number;
    last_read_at?: string;
    reason?: string;
    repository?: Repository;
    subject?: Subject;
    unread?: boolean;
    updated_at?: string;
    url?: string;

    constructor(data?: INotifications) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.last_read_at = data["last_read_at"];
            this.reason = data["reason"];
            this.repository = data["repository"] ? Repository.fromJS(data["repository"]) : <any>undefined;
            this.subject = data["subject"] ? Subject.fromJS(data["subject"]) : <any>undefined;
            this.unread = data["unread"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Notifications {
        let result = new Notifications();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["id"] = this.id;
        data["last_read_at"] = this.last_read_at;
        data["reason"] = this.reason;
        data["repository"] = this.repository ? this.repository.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["unread"] = this.unread;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        return data; 
    }
}

interface INotifications {
    id?: number;
    last_read_at?: string;
    reason?: string;
    repository?: Repository;
    subject?: Subject;
    unread?: boolean;
    updated_at?: string;
    url?: string;
}

class OrgTeamsPost implements IOrgTeamsPost {
    name: string;
    permission?: OrgTeamsPostPermission;
    repo_names?: string[];

    constructor(data?: IOrgTeamsPost) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.permission = data["permission"] ? OrgTeamsPostPermission.fromJS(data["permission"]) : <any>undefined;
            if (data["repo_names"] && data["repo_names"].constructor === Array) {
                this.repo_names = [];
                for (let item of data["repo_names"])
                    this.repo_names.push(item);
            }
        }
    }

    static fromJS(data: any): OrgTeamsPost {
        let result = new OrgTeamsPost();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["name"] = this.name;
        data["permission"] = this.permission ? this.permission.toJSON() : <any>undefined;
        if (this.repo_names && this.repo_names.constructor === Array) {
            data["repo_names"] = [];
            for (let item of this.repo_names)
                data["repo_names"].push(item);
        }
        return data; 
    }
}

interface IOrgTeamsPost {
    name: string;
    permission?: OrgTeamsPostPermission;
    repo_names?: string[];
}

class Organization implements IOrganization {
    avatar_url?: string;
    blog?: string;
    company?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    email?: string;
    followers?: number;
    following?: number;
    html_url?: string;
    id?: number;
    location?: string;
    login?: string;
    name?: string;
    public_gists?: number;
    public_repos?: number;
    type?: string;
    url?: string;

    constructor(data?: IOrganization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.blog = data["blog"];
            this.company = data["company"];
            this.created_at = data["created_at"];
            this.email = data["email"];
            this.followers = data["followers"];
            this.following = data["following"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.location = data["location"];
            this.login = data["login"];
            this.name = data["name"];
            this.public_gists = data["public_gists"];
            this.public_repos = data["public_repos"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Organization {
        let result = new Organization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["blog"] = this.blog;
        data["company"] = this.company;
        data["created_at"] = this.created_at;
        data["email"] = this.email;
        data["followers"] = this.followers;
        data["following"] = this.following;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["location"] = this.location;
        data["login"] = this.login;
        data["name"] = this.name;
        data["public_gists"] = this.public_gists;
        data["public_repos"] = this.public_repos;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface IOrganization {
    avatar_url?: string;
    blog?: string;
    company?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    email?: string;
    followers?: number;
    following?: number;
    html_url?: string;
    id?: number;
    location?: string;
    login?: string;
    name?: string;
    public_gists?: number;
    public_repos?: number;
    type?: string;
    url?: string;
}

class OrganizationAsTeamMember implements IOrganizationAsTeamMember {
    errors?: Errors[];
    message?: string;

    constructor(data?: IOrganizationAsTeamMember) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [];
                for (let item of data["errors"])
                    this.errors.push(Errors.fromJS(item));
            }
            this.message = data["message"];
        }
    }

    static fromJS(data: any): OrganizationAsTeamMember {
        let result = new OrganizationAsTeamMember();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["message"] = this.message;
        return data; 
    }
}

interface IOrganizationAsTeamMember {
    errors?: Errors[];
    message?: string;
}

class ParticipationStats implements IParticipationStats {
    all?: number[];
    owner?: number[];

    constructor(data?: IParticipationStats) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["all"] && data["all"].constructor === Array) {
                this.all = [];
                for (let item of data["all"])
                    this.all.push(item);
            }
            if (data["owner"] && data["owner"].constructor === Array) {
                this.owner = [];
                for (let item of data["owner"])
                    this.owner.push(item);
            }
        }
    }

    static fromJS(data: any): ParticipationStats {
        let result = new ParticipationStats();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        if (this.all && this.all.constructor === Array) {
            data["all"] = [];
            for (let item of this.all)
                data["all"].push(item);
        }
        if (this.owner && this.owner.constructor === Array) {
            data["owner"] = [];
            for (let item of this.owner)
                data["owner"].push(item);
        }
        return data; 
    }
}

interface IParticipationStats {
    all?: number[];
    owner?: number[];
}

class PatchGist implements IPatchGist {
    description?: string;
    files?: files3;

    constructor(data?: IPatchGist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.files = data["files"] ? files3.fromJS(data["files"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PatchGist {
        let result = new PatchGist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["description"] = this.description;
        data["files"] = this.files ? this.files.toJSON() : <any>undefined;
        return data; 
    }
}

interface IPatchGist {
    description?: string;
    files?: files3;
}

class PatchOrg implements IPatchOrg {
    /** Billing email address. This address is not publicized. */
    billing_email?: string;
    company?: string;
    /** Publicly visible email address. */
    email?: string;
    location?: string;
    name?: string;

    constructor(data?: IPatchOrg) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.billing_email = data["billing_email"];
            this.company = data["company"];
            this.email = data["email"];
            this.location = data["location"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): PatchOrg {
        let result = new PatchOrg();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["billing_email"] = this.billing_email;
        data["company"] = this.company;
        data["email"] = this.email;
        data["location"] = this.location;
        data["name"] = this.name;
        return data; 
    }
}

interface IPatchOrg {
    /** Billing email address. This address is not publicized. */
    billing_email?: string;
    company?: string;
    /** Publicly visible email address. */
    email?: string;
    location?: string;
    name?: string;
}

class PostComment implements IPostComment {
    body: string;

    constructor(data?: IPostComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.body = data["body"];
        }
    }

    static fromJS(data: any): PostComment {
        let result = new PostComment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["body"] = this.body;
        return data; 
    }
}

interface IPostComment {
    body: string;
}

class PostGist implements IPostGist {
    description?: string;
    files?: files4;
    public?: boolean;

    constructor(data?: IPostGist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.files = data["files"] ? files4.fromJS(data["files"]) : <any>undefined;
            this.public = data["public"];
        }
    }

    static fromJS(data: any): PostGist {
        let result = new PostGist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["description"] = this.description;
        data["files"] = this.files ? this.files.toJSON() : <any>undefined;
        data["public"] = this.public;
        return data; 
    }
}

interface IPostGist {
    description?: string;
    files?: files4;
    public?: boolean;
}

class PostRepo implements IPostRepo {
    /** True to create an initial commit with empty README. Default is false. */
    auto_init?: boolean;
    description?: string;
    /** Desired language or platform .gitignore template to apply. Use the name of the template without the extension. For example, "Haskell" Ignored if auto_init parameter is not provided.  */
    gitignore_template?: string;
    /** True to enable downloads for this repository, false to disable them. Default is true. */
    has_downloads?: boolean;
    /** True to enable issues for this repository, false to disable them. Default is true. */
    has_issues?: boolean;
    /** True to enable the wiki for this repository, false to disable it. Default is true. */
    has_wiki?: boolean;
    homepage?: string;
    name: string;
    /** True to create a private repository, false to create a public one. Creating private repositories requires a paid GitHub account. */
    private?: boolean;
    /** The id of the team that will be granted access to this repository. This is only valid when creating a repo in an organization. */
    team_id?: number;

    constructor(data?: IPostRepo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.auto_init = data["auto_init"];
            this.description = data["description"];
            this.gitignore_template = data["gitignore_template"];
            this.has_downloads = data["has_downloads"];
            this.has_issues = data["has_issues"];
            this.has_wiki = data["has_wiki"];
            this.homepage = data["homepage"];
            this.name = data["name"];
            this.private = data["private"];
            this.team_id = data["team_id"];
        }
    }

    static fromJS(data: any): PostRepo {
        let result = new PostRepo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["auto_init"] = this.auto_init;
        data["description"] = this.description;
        data["gitignore_template"] = this.gitignore_template;
        data["has_downloads"] = this.has_downloads;
        data["has_issues"] = this.has_issues;
        data["has_wiki"] = this.has_wiki;
        data["homepage"] = this.homepage;
        data["name"] = this.name;
        data["private"] = this.private;
        data["team_id"] = this.team_id;
        return data; 
    }
}

interface IPostRepo {
    /** True to create an initial commit with empty README. Default is false. */
    auto_init?: boolean;
    description?: string;
    /** Desired language or platform .gitignore template to apply. Use the name of the template without the extension. For example, "Haskell" Ignored if auto_init parameter is not provided.  */
    gitignore_template?: string;
    /** True to enable downloads for this repository, false to disable them. Default is true. */
    has_downloads?: boolean;
    /** True to enable issues for this repository, false to disable them. Default is true. */
    has_issues?: boolean;
    /** True to enable the wiki for this repository, false to disable it. Default is true. */
    has_wiki?: boolean;
    homepage?: string;
    name: string;
    /** True to create a private repository, false to create a public one. Creating private repositories requires a paid GitHub account. */
    private?: boolean;
    /** The id of the team that will be granted access to this repository. This is only valid when creating a repo in an organization. */
    team_id?: number;
}

class PullRequest implements IPullRequest {
    _links?: _links4;
    additions?: number;
    base?: Base;
    body?: string;
    changed_files?: number;
    closed_at?: string;
    comments?: number;
    commits?: number;
    created_at?: string;
    deletions?: number;
    diff_url?: string;
    head?: Head;
    html_url?: string;
    issue_url?: string;
    merge_commit_sha?: string;
    mergeable?: boolean;
    merged?: boolean;
    merged_at?: string;
    merged_by?: Merged_by;
    number?: number;
    patch_url?: string;
    state?: string;
    title?: string;
    updated_at?: string;
    url?: string;
    user?: user4;

    constructor(data?: IPullRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this._links = data["_links"] ? _links4.fromJS(data["_links"]) : <any>undefined;
            this.additions = data["additions"];
            this.base = data["base"] ? Base.fromJS(data["base"]) : <any>undefined;
            this.body = data["body"];
            this.changed_files = data["changed_files"];
            this.closed_at = data["closed_at"];
            this.comments = data["comments"];
            this.commits = data["commits"];
            this.created_at = data["created_at"];
            this.deletions = data["deletions"];
            this.diff_url = data["diff_url"];
            this.head = data["head"] ? Head.fromJS(data["head"]) : <any>undefined;
            this.html_url = data["html_url"];
            this.issue_url = data["issue_url"];
            this.merge_commit_sha = data["merge_commit_sha"];
            this.mergeable = data["mergeable"];
            this.merged = data["merged"];
            this.merged_at = data["merged_at"];
            this.merged_by = data["merged_by"] ? Merged_by.fromJS(data["merged_by"]) : <any>undefined;
            this.number = data["number"];
            this.patch_url = data["patch_url"];
            this.state = data["state"];
            this.title = data["title"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.user = data["user"] ? user4.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PullRequest {
        let result = new PullRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
        data["additions"] = this.additions;
        data["base"] = this.base ? this.base.toJSON() : <any>undefined;
        data["body"] = this.body;
        data["changed_files"] = this.changed_files;
        data["closed_at"] = this.closed_at;
        data["comments"] = this.comments;
        data["commits"] = this.commits;
        data["created_at"] = this.created_at;
        data["deletions"] = this.deletions;
        data["diff_url"] = this.diff_url;
        data["head"] = this.head ? this.head.toJSON() : <any>undefined;
        data["html_url"] = this.html_url;
        data["issue_url"] = this.issue_url;
        data["merge_commit_sha"] = this.merge_commit_sha;
        data["mergeable"] = this.mergeable;
        data["merged"] = this.merged;
        data["merged_at"] = this.merged_at;
        data["merged_by"] = this.merged_by ? this.merged_by.toJSON() : <any>undefined;
        data["number"] = this.number;
        data["patch_url"] = this.patch_url;
        data["state"] = this.state;
        data["title"] = this.title;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

interface IPullRequest {
    _links?: _links4;
    additions?: number;
    base?: Base;
    body?: string;
    changed_files?: number;
    closed_at?: string;
    comments?: number;
    commits?: number;
    created_at?: string;
    deletions?: number;
    diff_url?: string;
    head?: Head;
    html_url?: string;
    issue_url?: string;
    merge_commit_sha?: string;
    mergeable?: boolean;
    merged?: boolean;
    merged_at?: string;
    merged_by?: Merged_by;
    number?: number;
    patch_url?: string;
    state?: string;
    title?: string;
    updated_at?: string;
    url?: string;
    user?: user4;
}

class PullUpdate implements IPullUpdate {
    body?: string;
    state?: string;
    title?: string;

    constructor(data?: IPullUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.body = data["body"];
            this.state = data["state"];
            this.title = data["title"];
        }
    }

    static fromJS(data: any): PullUpdate {
        let result = new PullUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["body"] = this.body;
        data["state"] = this.state;
        data["title"] = this.title;
        return data; 
    }
}

interface IPullUpdate {
    body?: string;
    state?: string;
    title?: string;
}

class PullsComment implements IPullsComment {
    _links?: _links5;
    body?: string;
    commit_id?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    id?: number;
    path?: string;
    position?: number;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    user?: user5;

    constructor(data?: IPullsComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this._links = data["_links"] ? _links5.fromJS(data["_links"]) : <any>undefined;
            this.body = data["body"];
            this.commit_id = data["commit_id"];
            this.created_at = data["created_at"];
            this.id = data["id"];
            this.path = data["path"];
            this.position = data["position"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.user = data["user"] ? user5.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PullsComment {
        let result = new PullsComment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
        data["body"] = this.body;
        data["commit_id"] = this.commit_id;
        data["created_at"] = this.created_at;
        data["id"] = this.id;
        data["path"] = this.path;
        data["position"] = this.position;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

interface IPullsComment {
    _links?: _links5;
    body?: string;
    commit_id?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    id?: number;
    path?: string;
    position?: number;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    user?: user5;
}

class PullsCommentPost implements IPullsCommentPost {
    body?: string;
    commit_id?: string;
    path?: string;
    position?: number;

    constructor(data?: IPullsCommentPost) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.body = data["body"];
            this.commit_id = data["commit_id"];
            this.path = data["path"];
            this.position = data["position"];
        }
    }

    static fromJS(data: any): PullsCommentPost {
        let result = new PullsCommentPost();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["body"] = this.body;
        data["commit_id"] = this.commit_id;
        data["path"] = this.path;
        data["position"] = this.position;
        return data; 
    }
}

interface IPullsCommentPost {
    body?: string;
    commit_id?: string;
    path?: string;
    position?: number;
}

class PullsPost implements IPullsPost {
    base?: string;
    body?: string;
    head?: string;
    title?: string;

    constructor(data?: IPullsPost) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.base = data["base"];
            this.body = data["body"];
            this.head = data["head"];
            this.title = data["title"];
        }
    }

    static fromJS(data: any): PullsPost {
        let result = new PullsPost();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["base"] = this.base;
        data["body"] = this.body;
        data["head"] = this.head;
        data["title"] = this.title;
        return data; 
    }
}

interface IPullsPost {
    base?: string;
    body?: string;
    head?: string;
    title?: string;
}

class PutSubscription implements IPutSubscription {
    created_at?: string;
    ignored?: boolean;
    reason?: any;
    subscribed?: boolean;
    thread_url?: string;
    url?: string;

    constructor(data?: IPutSubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.created_at = data["created_at"];
            this.ignored = data["ignored"];
            if (data["reason"]) {
                this.reason = {};
                for (let key in data["reason"]) {
                    if (data["reason"].hasOwnProperty(key))
                        this.reason[key] = data["reason"][key];
                }
            }
            this.subscribed = data["subscribed"];
            this.thread_url = data["thread_url"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): PutSubscription {
        let result = new PutSubscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["created_at"] = this.created_at;
        data["ignored"] = this.ignored;
        if (this.reason) {
            data["reason"] = {};
            for (let key in this.reason) {
                if (this.reason.hasOwnProperty(key))
                    data["reason"][key] = this.reason[key];
            }
        }
        data["subscribed"] = this.subscribed;
        data["thread_url"] = this.thread_url;
        data["url"] = this.url;
        return data; 
    }
}

interface IPutSubscription {
    created_at?: string;
    ignored?: boolean;
    reason?: any;
    subscribed?: boolean;
    thread_url?: string;
    url?: string;
}

class Rate_limit implements IRate_limit {
    rate?: Rate;

    constructor(data?: IRate_limit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rate = data["rate"] ? Rate.fromJS(data["rate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Rate_limit {
        let result = new Rate_limit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["rate"] = this.rate ? this.rate.toJSON() : <any>undefined;
        return data; 
    }
}

interface IRate_limit {
    rate?: Rate;
}

class Readme implements IReadme {
    _links?: _links6;
    content?: string;
    encoding?: string;
    git_url?: string;
    html_url?: string;
    name?: string;
    path?: string;
    sha?: string;
    size?: number;
    type?: string;
    url?: string;

    constructor(data?: IReadme) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this._links = data["_links"] ? _links6.fromJS(data["_links"]) : <any>undefined;
            this.content = data["content"];
            this.encoding = data["encoding"];
            this.git_url = data["git_url"];
            this.html_url = data["html_url"];
            this.name = data["name"];
            this.path = data["path"];
            this.sha = data["sha"];
            this.size = data["size"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Readme {
        let result = new Readme();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
        data["content"] = this.content;
        data["encoding"] = this.encoding;
        data["git_url"] = this.git_url;
        data["html_url"] = this.html_url;
        data["name"] = this.name;
        data["path"] = this.path;
        data["sha"] = this.sha;
        data["size"] = this.size;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface IReadme {
    _links?: _links6;
    content?: string;
    encoding?: string;
    git_url?: string;
    html_url?: string;
    name?: string;
    path?: string;
    sha?: string;
    size?: number;
    type?: string;
    url?: string;
}

class RefBody implements IRefBody {
    object?: object;
    ref?: string;
    url?: string;

    constructor(data?: IRefBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.object = data["object"] ? object.fromJS(data["object"]) : <any>undefined;
            this.ref = data["ref"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): RefBody {
        let result = new RefBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["object"] = this.object ? this.object.toJSON() : <any>undefined;
        data["ref"] = this.ref;
        data["url"] = this.url;
        return data; 
    }
}

interface IRefBody {
    object?: object;
    ref?: string;
    url?: string;
}

class RefsBody implements IRefsBody {
    ref?: string;
    sha?: string;

    constructor(data?: IRefsBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ref = data["ref"];
            this.sha = data["sha"];
        }
    }

    static fromJS(data: any): RefsBody {
        let result = new RefsBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["ref"] = this.ref;
        data["sha"] = this.sha;
        return data; 
    }
}

interface IRefsBody {
    ref?: string;
    sha?: string;
}

class Release implements IRelease {
    assets?: Assets[];
    assets_url?: string;
    author?: author3;
    body?: string;
    created_at?: string;
    draft?: boolean;
    html_url?: string;
    id?: number;
    name?: string;
    prerelease?: boolean;
    published_at?: string;
    tag_name?: string;
    tarball_url?: string;
    target_commitish?: string;
    upload_url?: string;
    url?: string;
    zipball_url?: string;

    constructor(data?: IRelease) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["assets"] && data["assets"].constructor === Array) {
                this.assets = [];
                for (let item of data["assets"])
                    this.assets.push(Assets.fromJS(item));
            }
            this.assets_url = data["assets_url"];
            this.author = data["author"] ? author3.fromJS(data["author"]) : <any>undefined;
            this.body = data["body"];
            this.created_at = data["created_at"];
            this.draft = data["draft"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.name = data["name"];
            this.prerelease = data["prerelease"];
            this.published_at = data["published_at"];
            this.tag_name = data["tag_name"];
            this.tarball_url = data["tarball_url"];
            this.target_commitish = data["target_commitish"];
            this.upload_url = data["upload_url"];
            this.url = data["url"];
            this.zipball_url = data["zipball_url"];
        }
    }

    static fromJS(data: any): Release {
        let result = new Release();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        if (this.assets && this.assets.constructor === Array) {
            data["assets"] = [];
            for (let item of this.assets)
                data["assets"].push(item.toJSON());
        }
        data["assets_url"] = this.assets_url;
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["body"] = this.body;
        data["created_at"] = this.created_at;
        data["draft"] = this.draft;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["name"] = this.name;
        data["prerelease"] = this.prerelease;
        data["published_at"] = this.published_at;
        data["tag_name"] = this.tag_name;
        data["tarball_url"] = this.tarball_url;
        data["target_commitish"] = this.target_commitish;
        data["upload_url"] = this.upload_url;
        data["url"] = this.url;
        data["zipball_url"] = this.zipball_url;
        return data; 
    }
}

interface IRelease {
    assets?: Assets[];
    assets_url?: string;
    author?: author3;
    body?: string;
    created_at?: string;
    draft?: boolean;
    html_url?: string;
    id?: number;
    name?: string;
    prerelease?: boolean;
    published_at?: string;
    tag_name?: string;
    tarball_url?: string;
    target_commitish?: string;
    upload_url?: string;
    url?: string;
    zipball_url?: string;
}

class ReleaseCreate implements IReleaseCreate {
    body?: string;
    draft?: boolean;
    name?: string;
    prerelease?: boolean;
    tag_name?: string;
    target_commitish?: string;

    constructor(data?: IReleaseCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.body = data["body"];
            this.draft = data["draft"];
            this.name = data["name"];
            this.prerelease = data["prerelease"];
            this.tag_name = data["tag_name"];
            this.target_commitish = data["target_commitish"];
        }
    }

    static fromJS(data: any): ReleaseCreate {
        let result = new ReleaseCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["body"] = this.body;
        data["draft"] = this.draft;
        data["name"] = this.name;
        data["prerelease"] = this.prerelease;
        data["tag_name"] = this.tag_name;
        data["target_commitish"] = this.target_commitish;
        return data; 
    }
}

interface IReleaseCreate {
    body?: string;
    draft?: boolean;
    name?: string;
    prerelease?: boolean;
    tag_name?: string;
    target_commitish?: string;
}

class Repo implements IRepo {
    clone_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    description?: string;
    fork?: boolean;
    forks?: number;
    forks_count?: number;
    full_name?: string;
    git_url?: string;
    has_downloads?: boolean;
    has_issues?: boolean;
    has_wiki?: boolean;
    homepage?: string;
    html_url?: string;
    id?: number;
    language?: string;
    master_branch?: string;
    mirror_url?: string;
    name?: string;
    open_issues?: number;
    open_issues_count?: number;
    organization?: organization;
    owner?: owner;
    /** Is present when the repo is a fork. Parent is the repo this repo was forked from. */
    parent?: Parent;
    private?: boolean;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string;
    size?: number;
    /** Is present when the repo is a fork. Source is the ultimate source for the network. */
    source?: Source;
    ssh_url?: string;
    svn_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    watchers?: number;
    watchers_count?: number;

    constructor(data?: IRepo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clone_url = data["clone_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.forks_count = data["forks_count"];
            this.full_name = data["full_name"];
            this.git_url = data["git_url"];
            this.has_downloads = data["has_downloads"];
            this.has_issues = data["has_issues"];
            this.has_wiki = data["has_wiki"];
            this.homepage = data["homepage"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.language = data["language"];
            this.master_branch = data["master_branch"];
            this.mirror_url = data["mirror_url"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.open_issues_count = data["open_issues_count"];
            this.organization = data["organization"] ? organization.fromJS(data["organization"]) : <any>undefined;
            this.owner = data["owner"] ? owner.fromJS(data["owner"]) : <any>undefined;
            this.parent = data["parent"] ? Parent.fromJS(data["parent"]) : <any>undefined;
            this.private = data["private"];
            this.pushed_at = data["pushed_at"];
            this.size = data["size"];
            this.source = data["source"] ? Source.fromJS(data["source"]) : <any>undefined;
            this.ssh_url = data["ssh_url"];
            this.svn_url = data["svn_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.watchers = data["watchers"];
            this.watchers_count = data["watchers_count"];
        }
    }

    static fromJS(data: any): Repo {
        let result = new Repo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["clone_url"] = this.clone_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["forks_count"] = this.forks_count;
        data["full_name"] = this.full_name;
        data["git_url"] = this.git_url;
        data["has_downloads"] = this.has_downloads;
        data["has_issues"] = this.has_issues;
        data["has_wiki"] = this.has_wiki;
        data["homepage"] = this.homepage;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["language"] = this.language;
        data["master_branch"] = this.master_branch;
        data["mirror_url"] = this.mirror_url;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["open_issues_count"] = this.open_issues_count;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pushed_at"] = this.pushed_at;
        data["size"] = this.size;
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        data["ssh_url"] = this.ssh_url;
        data["svn_url"] = this.svn_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["watchers"] = this.watchers;
        data["watchers_count"] = this.watchers_count;
        return data; 
    }
}

interface IRepo {
    clone_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    description?: string;
    fork?: boolean;
    forks?: number;
    forks_count?: number;
    full_name?: string;
    git_url?: string;
    has_downloads?: boolean;
    has_issues?: boolean;
    has_wiki?: boolean;
    homepage?: string;
    html_url?: string;
    id?: number;
    language?: string;
    master_branch?: string;
    mirror_url?: string;
    name?: string;
    open_issues?: number;
    open_issues_count?: number;
    organization?: organization;
    owner?: owner;
    /** Is present when the repo is a fork. Parent is the repo this repo was forked from. */
    parent?: Parent;
    private?: boolean;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string;
    size?: number;
    /** Is present when the repo is a fork. Source is the ultimate source for the network. */
    source?: Source;
    ssh_url?: string;
    svn_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    watchers?: number;
    watchers_count?: number;
}

class RepoCommit implements IRepoCommit {
    author?: author4;
    committer?: committer4;
    message?: string;
    parents?: parents2[];
    sha?: string;
    tree?: tree;
    url?: string;

    constructor(data?: IRepoCommit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? author4.fromJS(data["author"]) : <any>undefined;
            this.committer = data["committer"] ? committer4.fromJS(data["committer"]) : <any>undefined;
            this.message = data["message"];
            if (data["parents"] && data["parents"].constructor === Array) {
                this.parents = [];
                for (let item of data["parents"])
                    this.parents.push(parents2.fromJS(item));
            }
            this.sha = data["sha"];
            this.tree = data["tree"] ? tree.fromJS(data["tree"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): RepoCommit {
        let result = new RepoCommit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (this.parents && this.parents.constructor === Array) {
            data["parents"] = [];
            for (let item of this.parents)
                data["parents"].push(item.toJSON());
        }
        data["sha"] = this.sha;
        data["tree"] = this.tree ? this.tree.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

interface IRepoCommit {
    author?: author4;
    committer?: committer4;
    message?: string;
    parents?: parents2[];
    sha?: string;
    tree?: tree;
    url?: string;
}

class RepoCommitBody implements IRepoCommitBody {
    author?: author5;
    message: string;
    parents: string[] = [];
    tree: string;

    constructor(data?: IRepoCommitBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? author5.fromJS(data["author"]) : <any>undefined;
            this.message = data["message"];
            if (data["parents"] && data["parents"].constructor === Array) {
                this.parents = [];
                for (let item of data["parents"])
                    this.parents.push(item);
            }
            this.tree = data["tree"];
        }
    }

    static fromJS(data: any): RepoCommitBody {
        let result = new RepoCommitBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (this.parents && this.parents.constructor === Array) {
            data["parents"] = [];
            for (let item of this.parents)
                data["parents"].push(item);
        }
        data["tree"] = this.tree;
        return data; 
    }
}

interface IRepoCommitBody {
    author?: author5;
    message: string;
    parents: string[];
    tree: string;
}

class RepoEdit implements IRepoEdit {
    description?: string;
    has_downloads?: boolean;
    has_issues?: boolean;
    has_wiki?: boolean;
    homepage?: string;
    name?: string;
    private?: boolean;

    constructor(data?: IRepoEdit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.has_downloads = data["has_downloads"];
            this.has_issues = data["has_issues"];
            this.has_wiki = data["has_wiki"];
            this.homepage = data["homepage"];
            this.name = data["name"];
            this.private = data["private"];
        }
    }

    static fromJS(data: any): RepoEdit {
        let result = new RepoEdit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["description"] = this.description;
        data["has_downloads"] = this.has_downloads;
        data["has_issues"] = this.has_issues;
        data["has_wiki"] = this.has_wiki;
        data["homepage"] = this.homepage;
        data["name"] = this.name;
        data["private"] = this.private;
        return data; 
    }
}

interface IRepoEdit {
    description?: string;
    has_downloads?: boolean;
    has_issues?: boolean;
    has_wiki?: boolean;
    homepage?: string;
    name?: string;
    private?: boolean;
}

class SearchCode implements ISearchCode {
    items?: Items[];
    total_count?: number;

    constructor(data?: ISearchCode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Items.fromJS(item));
            }
            this.total_count = data["total_count"];
        }
    }

    static fromJS(data: any): SearchCode {
        let result = new SearchCode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["total_count"] = this.total_count;
        return data; 
    }
}

interface ISearchCode {
    items?: Items[];
    total_count?: number;
}

class SearchIssues implements ISearchIssues {
    items?: items[];
    total_count?: number;

    constructor(data?: ISearchIssues) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(items.fromJS(item));
            }
            this.total_count = data["total_count"];
        }
    }

    static fromJS(data: any): SearchIssues {
        let result = new SearchIssues();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["total_count"] = this.total_count;
        return data; 
    }
}

interface ISearchIssues {
    items?: items[];
    total_count?: number;
}

class SearchIssuesByKeyword implements ISearchIssuesByKeyword {
    issues?: Issues[];

    constructor(data?: ISearchIssuesByKeyword) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["issues"] && data["issues"].constructor === Array) {
                this.issues = [];
                for (let item of data["issues"])
                    this.issues.push(Issues.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchIssuesByKeyword {
        let result = new SearchIssuesByKeyword();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        if (this.issues && this.issues.constructor === Array) {
            data["issues"] = [];
            for (let item of this.issues)
                data["issues"].push(item.toJSON());
        }
        return data; 
    }
}

interface ISearchIssuesByKeyword {
    issues?: Issues[];
}

class SearchRepositories implements ISearchRepositories {
    items?: items2[];
    total_count?: number;

    constructor(data?: ISearchRepositories) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(items2.fromJS(item));
            }
            this.total_count = data["total_count"];
        }
    }

    static fromJS(data: any): SearchRepositories {
        let result = new SearchRepositories();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["total_count"] = this.total_count;
        return data; 
    }
}

interface ISearchRepositories {
    items?: items2[];
    total_count?: number;
}

class SearchRepositoriesByKeyword implements ISearchRepositoriesByKeyword {
    repositories?: Repositories[];

    constructor(data?: ISearchRepositoriesByKeyword) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["repositories"] && data["repositories"].constructor === Array) {
                this.repositories = [];
                for (let item of data["repositories"])
                    this.repositories.push(Repositories.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchRepositoriesByKeyword {
        let result = new SearchRepositoriesByKeyword();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        if (this.repositories && this.repositories.constructor === Array) {
            data["repositories"] = [];
            for (let item of this.repositories)
                data["repositories"].push(item.toJSON());
        }
        return data; 
    }
}

interface ISearchRepositoriesByKeyword {
    repositories?: Repositories[];
}

class SearchUserByEmail implements ISearchUserByEmail {
    user?: user6;

    constructor(data?: ISearchUserByEmail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? user6.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SearchUserByEmail {
        let result = new SearchUserByEmail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

interface ISearchUserByEmail {
    user?: user6;
}

class SearchUsers implements ISearchUsers {
    items?: items3[];
    total_count?: number;

    constructor(data?: ISearchUsers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(items3.fromJS(item));
            }
            this.total_count = data["total_count"];
        }
    }

    static fromJS(data: any): SearchUsers {
        let result = new SearchUsers();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["total_count"] = this.total_count;
        return data; 
    }
}

interface ISearchUsers {
    items?: items3[];
    total_count?: number;
}

class SearchUsersByKeyword implements ISearchUsersByKeyword {
    users?: Users[];

    constructor(data?: ISearchUsersByKeyword) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["users"] && data["users"].constructor === Array) {
                this.users = [];
                for (let item of data["users"])
                    this.users.push(Users.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchUsersByKeyword {
        let result = new SearchUsersByKeyword();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        if (this.users && this.users.constructor === Array) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data; 
    }
}

interface ISearchUsersByKeyword {
    users?: Users[];
}

class Subscribition implements ISubscribition {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    ignored?: boolean;
    reason?: string;
    repository_url?: string;
    subscribed?: boolean;
    url?: string;

    constructor(data?: ISubscribition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.created_at = data["created_at"];
            this.ignored = data["ignored"];
            this.reason = data["reason"];
            this.repository_url = data["repository_url"];
            this.subscribed = data["subscribed"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Subscribition {
        let result = new Subscribition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["created_at"] = this.created_at;
        data["ignored"] = this.ignored;
        data["reason"] = this.reason;
        data["repository_url"] = this.repository_url;
        data["subscribed"] = this.subscribed;
        data["url"] = this.url;
        return data; 
    }
}

interface ISubscribition {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    ignored?: boolean;
    reason?: string;
    repository_url?: string;
    subscribed?: boolean;
    url?: string;
}

class SubscribitionBody implements ISubscribitionBody {
    ignored?: boolean;
    subscribed?: boolean;

    constructor(data?: ISubscribitionBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ignored = data["ignored"];
            this.subscribed = data["subscribed"];
        }
    }

    static fromJS(data: any): SubscribitionBody {
        let result = new SubscribitionBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["ignored"] = this.ignored;
        data["subscribed"] = this.subscribed;
        return data; 
    }
}

interface ISubscribitionBody {
    ignored?: boolean;
    subscribed?: boolean;
}

class Subscription implements ISubscription {
    created_at?: string;
    ignored?: boolean;
    reason?: boolean;
    subscribed?: boolean;
    thread_url?: string;
    url?: string;

    constructor(data?: ISubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.created_at = data["created_at"];
            this.ignored = data["ignored"];
            this.reason = data["reason"];
            this.subscribed = data["subscribed"];
            this.thread_url = data["thread_url"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Subscription {
        let result = new Subscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["created_at"] = this.created_at;
        data["ignored"] = this.ignored;
        data["reason"] = this.reason;
        data["subscribed"] = this.subscribed;
        data["thread_url"] = this.thread_url;
        data["url"] = this.url;
        return data; 
    }
}

interface ISubscription {
    created_at?: string;
    ignored?: boolean;
    reason?: boolean;
    subscribed?: boolean;
    thread_url?: string;
    url?: string;
}

class Tag implements ITag {
    message?: string;
    object?: object2;
    sha?: string;
    tag?: string;
    tagger?: Tagger;
    url?: string;

    constructor(data?: ITag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.message = data["message"];
            this.object = data["object"] ? object2.fromJS(data["object"]) : <any>undefined;
            this.sha = data["sha"];
            this.tag = data["tag"];
            this.tagger = data["tagger"] ? Tagger.fromJS(data["tagger"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Tag {
        let result = new Tag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["message"] = this.message;
        data["object"] = this.object ? this.object.toJSON() : <any>undefined;
        data["sha"] = this.sha;
        data["tag"] = this.tag;
        data["tagger"] = this.tagger ? this.tagger.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

interface ITag {
    message?: string;
    object?: object2;
    sha?: string;
    tag?: string;
    tagger?: Tagger;
    url?: string;
}

class Tags implements ITags {
    /** String of the tag message. */
    message: string;
    /** String of the SHA of the git object this is tagging. */
    object: string;
    tag: string;
    tagger: tagger = new tagger();
    /** String of the type of the object were tagging. Normally this is a commit but it can also be a tree or a blob. */
    type: string;

    constructor(data?: ITags) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.message = data["message"];
            this.object = data["object"];
            this.tag = data["tag"];
            this.tagger = data["tagger"] ? tagger.fromJS(data["tagger"]) : new tagger();
            this.type = data["type"];
        }
    }

    static fromJS(data: any): Tags {
        let result = new Tags();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["message"] = this.message;
        data["object"] = this.object;
        data["tag"] = this.tag;
        data["tagger"] = this.tagger ? this.tagger.toJSON() : <any>undefined;
        data["type"] = this.type;
        return data; 
    }
}

interface ITags {
    /** String of the tag message. */
    message: string;
    /** String of the SHA of the git object this is tagging. */
    object: string;
    tag: string;
    tagger: tagger;
    /** String of the type of the object were tagging. Normally this is a commit but it can also be a tree or a blob. */
    type: string;
}

class Team implements ITeam {
    id?: number;
    members_count?: number;
    name?: string;
    permission?: string;
    repos_count?: number;
    url?: string;

    constructor(data?: ITeam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.members_count = data["members_count"];
            this.name = data["name"];
            this.permission = data["permission"];
            this.repos_count = data["repos_count"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Team {
        let result = new Team();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["id"] = this.id;
        data["members_count"] = this.members_count;
        data["name"] = this.name;
        data["permission"] = this.permission;
        data["repos_count"] = this.repos_count;
        data["url"] = this.url;
        return data; 
    }
}

interface ITeam {
    id?: number;
    members_count?: number;
    name?: string;
    permission?: string;
    repos_count?: number;
    url?: string;
}

class TeamMembership implements ITeamMembership {
    state?: string;
    url?: string;

    constructor(data?: ITeamMembership) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): TeamMembership {
        let result = new TeamMembership();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["state"] = this.state;
        data["url"] = this.url;
        return data; 
    }
}

interface ITeamMembership {
    state?: string;
    url?: string;
}

class Tree implements ITree {
    sha?: string;
    tree?: tree2[];
    url?: string;

    constructor(data?: ITree) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            if (data["tree"] && data["tree"].constructor === Array) {
                this.tree = [];
                for (let item of data["tree"])
                    this.tree.push(tree2.fromJS(item));
            }
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Tree {
        let result = new Tree();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["sha"] = this.sha;
        if (this.tree && this.tree.constructor === Array) {
            data["tree"] = [];
            for (let item of this.tree)
                data["tree"].push(item.toJSON());
        }
        data["url"] = this.url;
        return data; 
    }
}

interface ITree {
    sha?: string;
    tree?: tree2[];
    url?: string;
}

class Trees implements ITrees {
    base_tree?: string;
    /** SHA1 checksum ID of the object in the tree. */
    sha?: string;
    tree?: tree3[];
    url?: string;

    constructor(data?: ITrees) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.base_tree = data["base_tree"];
            this.sha = data["sha"];
            if (data["tree"] && data["tree"].constructor === Array) {
                this.tree = [];
                for (let item of data["tree"])
                    this.tree.push(tree3.fromJS(item));
            }
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Trees {
        let result = new Trees();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["base_tree"] = this.base_tree;
        data["sha"] = this.sha;
        if (this.tree && this.tree.constructor === Array) {
            data["tree"] = [];
            for (let item of this.tree)
                data["tree"].push(item.toJSON());
        }
        data["url"] = this.url;
        return data; 
    }
}

interface ITrees {
    base_tree?: string;
    /** SHA1 checksum ID of the object in the tree. */
    sha?: string;
    tree?: tree3[];
    url?: string;
}

class User implements IUser {
    avatar_url?: string;
    bio?: string;
    blog?: string;
    collaborators?: number;
    company?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    disk_usage?: number;
    email?: string;
    followers?: number;
    following?: number;
    gravatar_id?: string;
    hireable?: boolean;
    html_url?: string;
    id?: number;
    location?: string;
    login?: string;
    name?: string;
    owned_private_repos?: number;
    plan?: Plan;
    private_gists?: number;
    public_gists?: number;
    public_repos?: number;
    total_private_repos?: number;
    type?: string;
    url?: string;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.bio = data["bio"];
            this.blog = data["blog"];
            this.collaborators = data["collaborators"];
            this.company = data["company"];
            this.created_at = data["created_at"];
            this.disk_usage = data["disk_usage"];
            this.email = data["email"];
            this.followers = data["followers"];
            this.following = data["following"];
            this.gravatar_id = data["gravatar_id"];
            this.hireable = data["hireable"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.location = data["location"];
            this.login = data["login"];
            this.name = data["name"];
            this.owned_private_repos = data["owned_private_repos"];
            this.plan = data["plan"] ? Plan.fromJS(data["plan"]) : <any>undefined;
            this.private_gists = data["private_gists"];
            this.public_gists = data["public_gists"];
            this.public_repos = data["public_repos"];
            this.total_private_repos = data["total_private_repos"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): User {
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["bio"] = this.bio;
        data["blog"] = this.blog;
        data["collaborators"] = this.collaborators;
        data["company"] = this.company;
        data["created_at"] = this.created_at;
        data["disk_usage"] = this.disk_usage;
        data["email"] = this.email;
        data["followers"] = this.followers;
        data["following"] = this.following;
        data["gravatar_id"] = this.gravatar_id;
        data["hireable"] = this.hireable;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["location"] = this.location;
        data["login"] = this.login;
        data["name"] = this.name;
        data["owned_private_repos"] = this.owned_private_repos;
        data["plan"] = this.plan ? this.plan.toJSON() : <any>undefined;
        data["private_gists"] = this.private_gists;
        data["public_gists"] = this.public_gists;
        data["public_repos"] = this.public_repos;
        data["total_private_repos"] = this.total_private_repos;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface IUser {
    avatar_url?: string;
    bio?: string;
    blog?: string;
    collaborators?: number;
    company?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    disk_usage?: number;
    email?: string;
    followers?: number;
    following?: number;
    gravatar_id?: string;
    hireable?: boolean;
    html_url?: string;
    id?: number;
    location?: string;
    login?: string;
    name?: string;
    owned_private_repos?: number;
    plan?: Plan;
    private_gists?: number;
    public_gists?: number;
    public_repos?: number;
    total_private_repos?: number;
    type?: string;
    url?: string;
}

class UserKeysKeyId implements IUserKeysKeyId {
    id?: number;
    key?: string;
    title?: string;
    url?: string;

    constructor(data?: IUserKeysKeyId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.key = data["key"];
            this.title = data["title"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): UserKeysKeyId {
        let result = new UserKeysKeyId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["title"] = this.title;
        data["url"] = this.url;
        return data; 
    }
}

interface IUserKeysKeyId {
    id?: number;
    key?: string;
    title?: string;
    url?: string;
}

class UserKeysPost implements IUserKeysPost {
    key?: string;
    title?: string;

    constructor(data?: IUserKeysPost) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.title = data["title"];
        }
    }

    static fromJS(data: any): UserKeysPost {
        let result = new UserKeysPost();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["key"] = this.key;
        data["title"] = this.title;
        return data; 
    }
}

interface IUserKeysPost {
    key?: string;
    title?: string;
}

class UserUpdate implements IUserUpdate {
    bio?: string;
    blog?: string;
    company?: string;
    email?: string;
    hireable?: boolean;
    location?: string;
    name?: string;

    constructor(data?: IUserUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bio = data["bio"];
            this.blog = data["blog"];
            this.company = data["company"];
            this.email = data["email"];
            this.hireable = data["hireable"];
            this.location = data["location"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): UserUpdate {
        let result = new UserUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["bio"] = this.bio;
        data["blog"] = this.blog;
        data["company"] = this.company;
        data["email"] = this.email;
        data["hireable"] = this.hireable;
        data["location"] = this.location;
        data["name"] = this.name;
        return data; 
    }
}

interface IUserUpdate {
    bio?: string;
    blog?: string;
    company?: string;
    email?: string;
    hireable?: boolean;
    location?: string;
    name?: string;
}

class UserUserId implements IUserUserId {
    avatar_url?: string;
    bio?: string;
    blog?: string;
    company?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    /** Note: The returned email is the users publicly visible email address (or null if the user has not specified a public email address in their profile). */
    email?: string;
    followers?: number;
    following?: number;
    gravatar_id?: string;
    hireable?: boolean;
    html_url?: string;
    id?: number;
    location?: string;
    login?: string;
    name?: string;
    public_gists?: number;
    public_repos?: number;
    type?: string;
    url?: string;

    constructor(data?: IUserUserId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.bio = data["bio"];
            this.blog = data["blog"];
            this.company = data["company"];
            this.created_at = data["created_at"];
            this.email = data["email"];
            this.followers = data["followers"];
            this.following = data["following"];
            this.gravatar_id = data["gravatar_id"];
            this.hireable = data["hireable"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.location = data["location"];
            this.login = data["login"];
            this.name = data["name"];
            this.public_gists = data["public_gists"];
            this.public_repos = data["public_repos"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): UserUserId {
        let result = new UserUserId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["bio"] = this.bio;
        data["blog"] = this.blog;
        data["company"] = this.company;
        data["created_at"] = this.created_at;
        data["email"] = this.email;
        data["followers"] = this.followers;
        data["following"] = this.following;
        data["gravatar_id"] = this.gravatar_id;
        data["hireable"] = this.hireable;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["location"] = this.location;
        data["login"] = this.login;
        data["name"] = this.name;
        data["public_gists"] = this.public_gists;
        data["public_repos"] = this.public_repos;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface IUserUserId {
    avatar_url?: string;
    bio?: string;
    blog?: string;
    company?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    /** Note: The returned email is the users publicly visible email address (or null if the user has not specified a public email address in their profile). */
    email?: string;
    followers?: number;
    following?: number;
    gravatar_id?: string;
    hireable?: boolean;
    html_url?: string;
    id?: number;
    location?: string;
    login?: string;
    name?: string;
    public_gists?: number;
    public_repos?: number;
    type?: string;
    url?: string;
}

/** Issues assigned to you / created by you / mentioning you / you're subscribed to updates for / All issues the authenticated user can see */
enum Filter {
    Assigned = <any>"assigned", 
    Created = <any>"created", 
    Mentioned = <any>"mentioned", 
    Subscribed = <any>"subscribed", 
    All = <any>"all", 
}

enum State {
    Open = <any>"open", 
    Closed = <any>"closed", 
}

enum Sort {
    Created = <any>"created", 
    Updated = <any>"updated", 
    Comments = <any>"comments", 
}

enum Direction {
    Asc = <any>"asc", 
    Desc = <any>"desc", 
}

/** Indicates the state of the issues to return. Can be either open or closed. */
enum State2 {
    Open = <any>"open", 
    Closed = <any>"closed", 
}

/** The sort field. if sort param is provided. Can be either asc or desc. */
enum Order {
    Desc = <any>"desc", 
    Asc = <any>"asc", 
}

/** The sort field. One of stars, forks, or updated. Default: results are sorted by best match. */
enum Sort2 {
    Updated = <any>"updated", 
    Stars = <any>"stars", 
    Forks = <any>"forks", 
}

/** The sort field. if sort param is provided. Can be either asc or desc. */
enum Order2 {
    Desc = <any>"desc", 
    Asc = <any>"asc", 
}

/** The sort field. One of stars, forks, or updated. Default: results are sorted by best match. */
enum Sort3 {
    Updated = <any>"updated", 
    Stars = <any>"stars", 
    Forks = <any>"forks", 
}

/** Issues assigned to you / created by you / mentioning you / you're subscribed to updates for / All issues the authenticated user can see */
enum Filter2 {
    Assigned = <any>"assigned", 
    Created = <any>"created", 
    Mentioned = <any>"mentioned", 
    Subscribed = <any>"subscribed", 
    All = <any>"all", 
}

enum State3 {
    Open = <any>"open", 
    Closed = <any>"closed", 
}

enum Sort4 {
    Created = <any>"created", 
    Updated = <any>"updated", 
    Comments = <any>"comments", 
}

enum Direction2 {
    Asc = <any>"asc", 
    Desc = <any>"desc", 
}

enum Type {
    All = <any>"all", 
    Public = <any>"public", 
    Private = <any>"private", 
    Forks = <any>"forks", 
    Sources = <any>"sources", 
    Member = <any>"member", 
}

enum Sort5 {
    Newes = <any>"newes", 
    Oldes = <any>"oldes", 
    Watchers = <any>"watchers", 
}

/** Issues assigned to you / created by you / mentioning you / you're subscribed to updates for / All issues the authenticated user can see */
enum Filter3 {
    Assigned = <any>"assigned", 
    Created = <any>"created", 
    Mentioned = <any>"mentioned", 
    Subscribed = <any>"subscribed", 
    All = <any>"all", 
}

enum State4 {
    Open = <any>"open", 
    Closed = <any>"closed", 
}

enum Sort6 {
    Created = <any>"created", 
    Updated = <any>"updated", 
    Comments = <any>"comments", 
}

enum Direction3 {
    Asc = <any>"asc", 
    Desc = <any>"desc", 
}

enum Sort7 {
    Created = <any>"created", 
    Updated = <any>"updated", 
}

/** String to filter by state. */
enum State5 {
    Open = <any>"open", 
    Closed = <any>"closed", 
}

enum Sort8 {
    Due_date = <any>"due_date", 
    Completeness = <any>"completeness", 
}

/** String to filter by state. */
enum State6 {
    Open = <any>"open", 
    Closed = <any>"closed", 
}

enum Sort9 {
    Created = <any>"created", 
    Updated = <any>"updated", 
}

enum Archive_format {
    Tarball = <any>"tarball", 
    Zipball = <any>"zipball", 
}

/** The sort field. if sort param is provided. Can be either asc or desc. */
enum Order3 {
    Desc = <any>"desc", 
    Asc = <any>"asc", 
}

/** Can only be 'indexed', which indicates how recently a file has been indexed by the GitHub search infrastructure. If not provided, results are sorted by best match. */
enum Sort10 {
    Indexed = <any>"indexed", 
}

/** The sort field. if sort param is provided. Can be either asc or desc. */
enum Order4 {
    Desc = <any>"desc", 
    Asc = <any>"asc", 
}

/** The sort field. Can be comments, created, or updated. Default: results are sorted by best match. */
enum Sort11 {
    Updated = <any>"updated", 
    Created = <any>"created", 
    Comments = <any>"comments", 
}

/** The sort field. if sort param is provided. Can be either asc or desc. */
enum Order5 {
    Desc = <any>"desc", 
    Asc = <any>"asc", 
}

/** If not provided, results are sorted by best match. */
enum Sort12 {
    Stars = <any>"stars", 
    Forks = <any>"forks", 
    Updated = <any>"updated", 
}

/** The sort field. if sort param is provided. Can be either asc or desc. */
enum Order6 {
    Desc = <any>"desc", 
    Asc = <any>"asc", 
}

/** If not provided, results are sorted by best match. */
enum Sort13 {
    Followers = <any>"followers", 
    Repositories = <any>"repositories", 
    Joined = <any>"joined", 
}

/** Issues assigned to you / created by you / mentioning you / you're subscribed to updates for / All issues the authenticated user can see */
enum Filter4 {
    Assigned = <any>"assigned", 
    Created = <any>"created", 
    Mentioned = <any>"mentioned", 
    Subscribed = <any>"subscribed", 
    All = <any>"all", 
}

enum State7 {
    Open = <any>"open", 
    Closed = <any>"closed", 
}

enum Sort14 {
    Created = <any>"created", 
    Updated = <any>"updated", 
    Comments = <any>"comments", 
}

enum Direction4 {
    Asc = <any>"asc", 
    Desc = <any>"desc", 
}

enum Type2 {
    All = <any>"all", 
    Public = <any>"public", 
    Private = <any>"private", 
    Forks = <any>"forks", 
    Sources = <any>"sources", 
    Member = <any>"member", 
}

enum Sort15 {
    Created = <any>"created", 
    Updated = <any>"updated", 
}

enum Type3 {
    All = <any>"all", 
    Public = <any>"public", 
    Private = <any>"private", 
    Forks = <any>"forks", 
    Sources = <any>"sources", 
    Member = <any>"member", 
}

class Anonymous implements IAnonymous {
    comments?: number;
    comments_url?: string;
    created_at?: string;
    description?: string;
    files?: files5;
    git_pull_url?: string;
    git_push_url?: string;
    html_url?: string;
    id?: string;
    public?: boolean;
    url?: string;
    user?: user7;

    constructor(data?: IAnonymous) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.comments = data["comments"];
            this.comments_url = data["comments_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.files = data["files"] ? files5.fromJS(data["files"]) : <any>undefined;
            this.git_pull_url = data["git_pull_url"];
            this.git_push_url = data["git_push_url"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.public = data["public"];
            this.url = data["url"];
            this.user = data["user"] ? user7.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Anonymous {
        let result = new Anonymous();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["comments"] = this.comments;
        data["comments_url"] = this.comments_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["files"] = this.files ? this.files.toJSON() : <any>undefined;
        data["git_pull_url"] = this.git_pull_url;
        data["git_push_url"] = this.git_push_url;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["public"] = this.public;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

interface IAnonymous {
    comments?: number;
    comments_url?: string;
    created_at?: string;
    description?: string;
    files?: files5;
    git_pull_url?: string;
    git_push_url?: string;
    html_url?: string;
    id?: string;
    public?: boolean;
    url?: string;
    user?: user7;
}

class Anonymous2 implements IAnonymous2 {
    body?: string;
    /** ISO 8601. */
    created_at?: string;
    id?: number;
    url?: string;
    user?: user8;

    constructor(data?: IAnonymous2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.body = data["body"];
            this.created_at = data["created_at"];
            this.id = data["id"];
            this.url = data["url"];
            this.user = data["user"] ? user8.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Anonymous2 {
        let result = new Anonymous2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["body"] = this.body;
        data["created_at"] = this.created_at;
        data["id"] = this.id;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

interface IAnonymous2 {
    body?: string;
    /** ISO 8601. */
    created_at?: string;
    id?: number;
    url?: string;
    user?: user8;
}

class Anonymous3 implements IAnonymous3 {
    assignee?: Assignee;
    body?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    closed_at?: string;
    comments?: number;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    html_url?: string;
    labels?: Labels[];
    milestone?: milestone;
    number?: number;
    pull_request?: Pull_request;
    state?: state;
    title?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    user?: user9;

    constructor(data?: IAnonymous3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assignee = data["assignee"] ? Assignee.fromJS(data["assignee"]) : <any>undefined;
            this.body = data["body"];
            this.closed_at = data["closed_at"];
            this.comments = data["comments"];
            this.created_at = data["created_at"];
            this.html_url = data["html_url"];
            if (data["labels"] && data["labels"].constructor === Array) {
                this.labels = [];
                for (let item of data["labels"])
                    this.labels.push(Labels.fromJS(item));
            }
            this.milestone = data["milestone"] ? milestone.fromJS(data["milestone"]) : <any>undefined;
            this.number = data["number"];
            this.pull_request = data["pull_request"] ? Pull_request.fromJS(data["pull_request"]) : <any>undefined;
            this.state = data["state"];
            this.title = data["title"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.user = data["user"] ? user9.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Anonymous3 {
        let result = new Anonymous3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["assignee"] = this.assignee ? this.assignee.toJSON() : <any>undefined;
        data["body"] = this.body;
        data["closed_at"] = this.closed_at;
        data["comments"] = this.comments;
        data["created_at"] = this.created_at;
        data["html_url"] = this.html_url;
        if (this.labels && this.labels.constructor === Array) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item.toJSON());
        }
        data["milestone"] = this.milestone ? this.milestone.toJSON() : <any>undefined;
        data["number"] = this.number;
        data["pull_request"] = this.pull_request ? this.pull_request.toJSON() : <any>undefined;
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

interface IAnonymous3 {
    assignee?: Assignee;
    body?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    closed_at?: string;
    comments?: number;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    html_url?: string;
    labels?: Labels[];
    milestone?: milestone;
    number?: number;
    pull_request?: Pull_request;
    state?: state;
    title?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    user?: user9;
}

class Anonymous4 implements IAnonymous4 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: IAnonymous4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous4 {
        let result = new Anonymous4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface IAnonymous4 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class Anonymous5 implements IAnonymous5 {
    clone_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    description?: string;
    fork?: boolean;
    forks?: number;
    forks_count?: number;
    full_name?: string;
    git_url?: string;
    homepage?: string;
    html_url?: string;
    id?: number;
    language?: string;
    master_branch?: string;
    mirror_url?: string;
    name?: string;
    open_issues?: number;
    open_issues_count?: number;
    owner?: owner2;
    private?: boolean;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string;
    size?: number;
    ssh_url?: string;
    svn_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    watchers?: number;
    watchers_count?: number;

    constructor(data?: IAnonymous5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clone_url = data["clone_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.forks_count = data["forks_count"];
            this.full_name = data["full_name"];
            this.git_url = data["git_url"];
            this.homepage = data["homepage"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.language = data["language"];
            this.master_branch = data["master_branch"];
            this.mirror_url = data["mirror_url"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.open_issues_count = data["open_issues_count"];
            this.owner = data["owner"] ? owner2.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.pushed_at = data["pushed_at"];
            this.size = data["size"];
            this.ssh_url = data["ssh_url"];
            this.svn_url = data["svn_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.watchers = data["watchers"];
            this.watchers_count = data["watchers_count"];
        }
    }

    static fromJS(data: any): Anonymous5 {
        let result = new Anonymous5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["clone_url"] = this.clone_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["forks_count"] = this.forks_count;
        data["full_name"] = this.full_name;
        data["git_url"] = this.git_url;
        data["homepage"] = this.homepage;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["language"] = this.language;
        data["master_branch"] = this.master_branch;
        data["mirror_url"] = this.mirror_url;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["open_issues_count"] = this.open_issues_count;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pushed_at"] = this.pushed_at;
        data["size"] = this.size;
        data["ssh_url"] = this.ssh_url;
        data["svn_url"] = this.svn_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["watchers"] = this.watchers;
        data["watchers_count"] = this.watchers_count;
        return data; 
    }
}

interface IAnonymous5 {
    clone_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    description?: string;
    fork?: boolean;
    forks?: number;
    forks_count?: number;
    full_name?: string;
    git_url?: string;
    homepage?: string;
    html_url?: string;
    id?: number;
    language?: string;
    master_branch?: string;
    mirror_url?: string;
    name?: string;
    open_issues?: number;
    open_issues_count?: number;
    owner?: owner2;
    private?: boolean;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string;
    size?: number;
    ssh_url?: string;
    svn_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    watchers?: number;
    watchers_count?: number;
}

class Anonymous6 implements IAnonymous6 {
    id?: number;
    name?: string;
    url?: string;

    constructor(data?: IAnonymous6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous6 {
        let result = new Anonymous6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["url"] = this.url;
        return data; 
    }
}

interface IAnonymous6 {
    id?: number;
    name?: string;
    url?: string;
}

class Anonymous7 implements IAnonymous7 {
    avatar_url?: number;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: IAnonymous7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous7 {
        let result = new Anonymous7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface IAnonymous7 {
    avatar_url?: number;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class Anonymous8 implements IAnonymous8 {
    commit?: commit6;
    name?: string;

    constructor(data?: IAnonymous8) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.commit = data["commit"] ? commit6.fromJS(data["commit"]) : <any>undefined;
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Anonymous8 {
        let result = new Anonymous8();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["commit"] = this.commit ? this.commit.toJSON() : <any>undefined;
        data["name"] = this.name;
        return data; 
    }
}

interface IAnonymous8 {
    commit?: commit6;
    name?: string;
}

class Anonymous9 implements IAnonymous9 {
    body?: string;
    commit_id?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    html_url?: string;
    id?: number;
    line?: number;
    path?: string;
    position?: number;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    user?: user10;

    constructor(data?: IAnonymous9) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.body = data["body"];
            this.commit_id = data["commit_id"];
            this.created_at = data["created_at"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.line = data["line"];
            this.path = data["path"];
            this.position = data["position"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.user = data["user"] ? user10.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Anonymous9 {
        let result = new Anonymous9();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["body"] = this.body;
        data["commit_id"] = this.commit_id;
        data["created_at"] = this.created_at;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["line"] = this.line;
        data["path"] = this.path;
        data["position"] = this.position;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

interface IAnonymous9 {
    body?: string;
    commit_id?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    html_url?: string;
    id?: number;
    line?: number;
    path?: string;
    position?: number;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    user?: user10;
}

class Anonymous10 implements IAnonymous10 {
    author?: author6;
    commit?: commit7;
    committer?: committer5;
    parents?: parents3[];
    sha?: string;
    url?: string;

    constructor(data?: IAnonymous10) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? author6.fromJS(data["author"]) : <any>undefined;
            this.commit = data["commit"] ? commit7.fromJS(data["commit"]) : <any>undefined;
            this.committer = data["committer"] ? committer5.fromJS(data["committer"]) : <any>undefined;
            if (data["parents"] && data["parents"].constructor === Array) {
                this.parents = [];
                for (let item of data["parents"])
                    this.parents.push(parents3.fromJS(item));
            }
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous10 {
        let result = new Anonymous10();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["commit"] = this.commit ? this.commit.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        if (this.parents && this.parents.constructor === Array) {
            data["parents"] = [];
            for (let item of this.parents)
                data["parents"].push(item.toJSON());
        }
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

interface IAnonymous10 {
    author?: author6;
    commit?: commit7;
    committer?: committer5;
    parents?: parents3[];
    sha?: string;
    url?: string;
}

class Anonymous11 implements IAnonymous11 {
    commit_url?: string;
    name?: string;
    repository_url?: string;
    sha?: string;
    state?: string;
    statuses?: Statuses[];

    constructor(data?: IAnonymous11) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.commit_url = data["commit_url"];
            this.name = data["name"];
            this.repository_url = data["repository_url"];
            this.sha = data["sha"];
            this.state = data["state"];
            if (data["statuses"] && data["statuses"].constructor === Array) {
                this.statuses = [];
                for (let item of data["statuses"])
                    this.statuses.push(Statuses.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Anonymous11 {
        let result = new Anonymous11();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["commit_url"] = this.commit_url;
        data["name"] = this.name;
        data["repository_url"] = this.repository_url;
        data["sha"] = this.sha;
        data["state"] = this.state;
        if (this.statuses && this.statuses.constructor === Array) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        return data; 
    }
}

interface IAnonymous11 {
    commit_url?: string;
    name?: string;
    repository_url?: string;
    sha?: string;
    state?: string;
    statuses?: Statuses[];
}

class Anonymous12 implements IAnonymous12 {
    avatar_url?: string;
    contributions?: number;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: IAnonymous12) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.contributions = data["contributions"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous12 {
        let result = new Anonymous12();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["contributions"] = this.contributions;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface IAnonymous12 {
    avatar_url?: string;
    contributions?: number;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class Anonymous13 implements IAnonymous13 {
    created_at?: string;
    creator?: creator2;
    description?: string;
    id?: number;
    payload?: string;
    sha?: string;
    statuses_url?: string;
    updated_at?: string;
    url?: string;

    constructor(data?: IAnonymous13) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.created_at = data["created_at"];
            this.creator = data["creator"] ? creator2.fromJS(data["creator"]) : <any>undefined;
            this.description = data["description"];
            this.id = data["id"];
            this.payload = data["payload"];
            this.sha = data["sha"];
            this.statuses_url = data["statuses_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous13 {
        let result = new Anonymous13();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["created_at"] = this.created_at;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["id"] = this.id;
        data["payload"] = this.payload;
        data["sha"] = this.sha;
        data["statuses_url"] = this.statuses_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        return data; 
    }
}

interface IAnonymous13 {
    created_at?: string;
    creator?: creator2;
    description?: string;
    id?: number;
    payload?: string;
    sha?: string;
    statuses_url?: string;
    updated_at?: string;
    url?: string;
}

class Anonymous14 implements IAnonymous14 {
    created_at?: string;
    creator?: creator3;
    description?: string;
    id?: number;
    payload?: string;
    state?: string;
    target_url?: string;
    updated_at?: string;
    url?: string;

    constructor(data?: IAnonymous14) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.created_at = data["created_at"];
            this.creator = data["creator"] ? creator3.fromJS(data["creator"]) : <any>undefined;
            this.description = data["description"];
            this.id = data["id"];
            this.payload = data["payload"];
            this.state = data["state"];
            this.target_url = data["target_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous14 {
        let result = new Anonymous14();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["created_at"] = this.created_at;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["id"] = this.id;
        data["payload"] = this.payload;
        data["state"] = this.state;
        data["target_url"] = this.target_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        return data; 
    }
}

interface IAnonymous14 {
    created_at?: string;
    creator?: creator3;
    description?: string;
    id?: number;
    payload?: string;
    state?: string;
    target_url?: string;
    updated_at?: string;
    url?: string;
}

class Anonymous15 implements IAnonymous15 {
    clone_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    description?: string;
    fork?: boolean;
    forks?: number;
    forks_count?: number;
    full_name?: string;
    git_url?: string;
    homepage?: string;
    html_url?: string;
    id?: number;
    language?: string;
    master_branch?: string;
    mirror_url?: string;
    name?: string;
    open_issues?: number;
    open_issues_count?: number;
    owner?: owner3;
    private?: boolean;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string;
    size?: number;
    ssh_url?: string;
    svn_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    watchers?: number;
    watchers_count?: number;

    constructor(data?: IAnonymous15) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clone_url = data["clone_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.forks_count = data["forks_count"];
            this.full_name = data["full_name"];
            this.git_url = data["git_url"];
            this.homepage = data["homepage"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.language = data["language"];
            this.master_branch = data["master_branch"];
            this.mirror_url = data["mirror_url"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.open_issues_count = data["open_issues_count"];
            this.owner = data["owner"] ? owner3.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.pushed_at = data["pushed_at"];
            this.size = data["size"];
            this.ssh_url = data["ssh_url"];
            this.svn_url = data["svn_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.watchers = data["watchers"];
            this.watchers_count = data["watchers_count"];
        }
    }

    static fromJS(data: any): Anonymous15 {
        let result = new Anonymous15();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["clone_url"] = this.clone_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["forks_count"] = this.forks_count;
        data["full_name"] = this.full_name;
        data["git_url"] = this.git_url;
        data["homepage"] = this.homepage;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["language"] = this.language;
        data["master_branch"] = this.master_branch;
        data["mirror_url"] = this.mirror_url;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["open_issues_count"] = this.open_issues_count;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pushed_at"] = this.pushed_at;
        data["size"] = this.size;
        data["ssh_url"] = this.ssh_url;
        data["svn_url"] = this.svn_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["watchers"] = this.watchers;
        data["watchers_count"] = this.watchers_count;
        return data; 
    }
}

interface IAnonymous15 {
    clone_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    description?: string;
    fork?: boolean;
    forks?: number;
    forks_count?: number;
    full_name?: string;
    git_url?: string;
    homepage?: string;
    html_url?: string;
    id?: number;
    language?: string;
    master_branch?: string;
    mirror_url?: string;
    name?: string;
    open_issues?: number;
    open_issues_count?: number;
    owner?: owner3;
    private?: boolean;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string;
    size?: number;
    ssh_url?: string;
    svn_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    watchers?: number;
    watchers_count?: number;
}

class Anonymous16 implements IAnonymous16 {
    object?: object3;
    ref?: string;
    url?: string;

    constructor(data?: IAnonymous16) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.object = data["object"] ? object3.fromJS(data["object"]) : <any>undefined;
            this.ref = data["ref"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous16 {
        let result = new Anonymous16();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["object"] = this.object ? this.object.toJSON() : <any>undefined;
        data["ref"] = this.ref;
        data["url"] = this.url;
        return data; 
    }
}

interface IAnonymous16 {
    object?: object3;
    ref?: string;
    url?: string;
}

class Anonymous17 implements IAnonymous17 {
    active?: boolean;
    config?: Config;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    events?: events[];
    id?: number;
    name?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;

    constructor(data?: IAnonymous17) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.active = data["active"];
            this.config = data["config"] ? Config.fromJS(data["config"]) : <any>undefined;
            this.created_at = data["created_at"];
            if (data["events"] && data["events"].constructor === Array) {
                this.events = [];
                for (let item of data["events"])
                    this.events.push(events.fromJS(item));
            }
            this.id = data["id"];
            this.name = data["name"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous17 {
        let result = new Anonymous17();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["active"] = this.active;
        data["config"] = this.config ? this.config.toJSON() : <any>undefined;
        data["created_at"] = this.created_at;
        if (this.events && this.events.constructor === Array) {
            data["events"] = [];
            for (let item of this.events)
                data["events"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        return data; 
    }
}

interface IAnonymous17 {
    active?: boolean;
    config?: Config;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    events?: events[];
    id?: number;
    name?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
}

class Anonymous18 implements IAnonymous18 {
    _links?: _links7;
    body?: string;
    commit_id?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    id?: number;
    path?: string;
    position?: number;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    user?: user11;

    constructor(data?: IAnonymous18) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this._links = data["_links"] ? _links7.fromJS(data["_links"]) : <any>undefined;
            this.body = data["body"];
            this.commit_id = data["commit_id"];
            this.created_at = data["created_at"];
            this.id = data["id"];
            this.path = data["path"];
            this.position = data["position"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.user = data["user"] ? user11.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Anonymous18 {
        let result = new Anonymous18();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
        data["body"] = this.body;
        data["commit_id"] = this.commit_id;
        data["created_at"] = this.created_at;
        data["id"] = this.id;
        data["path"] = this.path;
        data["position"] = this.position;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

interface IAnonymous18 {
    _links?: _links7;
    body?: string;
    commit_id?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    id?: number;
    path?: string;
    position?: number;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    user?: user11;
}

class Anonymous19 implements IAnonymous19 {
    color?: string;
    name?: string;
    url?: string;

    constructor(data?: IAnonymous19) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.color = data["color"];
            this.name = data["name"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous19 {
        let result = new Anonymous19();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["color"] = this.color;
        data["name"] = this.name;
        data["url"] = this.url;
        return data; 
    }
}

interface IAnonymous19 {
    color?: string;
    name?: string;
    url?: string;
}

class Anonymous20 implements IAnonymous20 {
    id?: number;
    key?: string;
    title?: string;
    url?: string;

    constructor(data?: IAnonymous20) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.key = data["key"];
            this.title = data["title"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous20 {
        let result = new Anonymous20();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["title"] = this.title;
        data["url"] = this.url;
        return data; 
    }
}

interface IAnonymous20 {
    id?: number;
    key?: string;
    title?: string;
    url?: string;
}

class Anonymous21 implements IAnonymous21 {
    _links?: _links8;
    base?: base;
    body?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    closed_at?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    diff_url?: string;
    head?: head;
    html_url?: string;
    issue_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    merged_at?: string;
    number?: number;
    patch_url?: string;
    state?: state2;
    title?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    user?: user12;

    constructor(data?: IAnonymous21) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this._links = data["_links"] ? _links8.fromJS(data["_links"]) : <any>undefined;
            this.base = data["base"] ? base.fromJS(data["base"]) : <any>undefined;
            this.body = data["body"];
            this.closed_at = data["closed_at"];
            this.created_at = data["created_at"];
            this.diff_url = data["diff_url"];
            this.head = data["head"] ? head.fromJS(data["head"]) : <any>undefined;
            this.html_url = data["html_url"];
            this.issue_url = data["issue_url"];
            this.merged_at = data["merged_at"];
            this.number = data["number"];
            this.patch_url = data["patch_url"];
            this.state = data["state"] ? state2.fromJS(data["state"]) : <any>undefined;
            this.title = data["title"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.user = data["user"] ? user12.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Anonymous21 {
        let result = new Anonymous21();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
        data["base"] = this.base ? this.base.toJSON() : <any>undefined;
        data["body"] = this.body;
        data["closed_at"] = this.closed_at;
        data["created_at"] = this.created_at;
        data["diff_url"] = this.diff_url;
        data["head"] = this.head ? this.head.toJSON() : <any>undefined;
        data["html_url"] = this.html_url;
        data["issue_url"] = this.issue_url;
        data["merged_at"] = this.merged_at;
        data["number"] = this.number;
        data["patch_url"] = this.patch_url;
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

interface IAnonymous21 {
    _links?: _links8;
    base?: base;
    body?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    closed_at?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    diff_url?: string;
    head?: head;
    html_url?: string;
    issue_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    merged_at?: string;
    number?: number;
    patch_url?: string;
    state?: state2;
    title?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    user?: user12;
}

class Anonymous22 implements IAnonymous22 {
    assets?: assets[];
    assets_url?: string;
    author?: author7;
    body?: string;
    created_at?: string;
    draft?: boolean;
    html_url?: string;
    id?: number;
    name?: string;
    prerelease?: boolean;
    published_at?: string;
    tag_name?: string;
    tarball_url?: string;
    target_commitish?: string;
    upload_url?: string;
    url?: string;
    zipball_url?: string;

    constructor(data?: IAnonymous22) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["assets"] && data["assets"].constructor === Array) {
                this.assets = [];
                for (let item of data["assets"])
                    this.assets.push(assets.fromJS(item));
            }
            this.assets_url = data["assets_url"];
            this.author = data["author"] ? author7.fromJS(data["author"]) : <any>undefined;
            this.body = data["body"];
            this.created_at = data["created_at"];
            this.draft = data["draft"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.name = data["name"];
            this.prerelease = data["prerelease"];
            this.published_at = data["published_at"];
            this.tag_name = data["tag_name"];
            this.tarball_url = data["tarball_url"];
            this.target_commitish = data["target_commitish"];
            this.upload_url = data["upload_url"];
            this.url = data["url"];
            this.zipball_url = data["zipball_url"];
        }
    }

    static fromJS(data: any): Anonymous22 {
        let result = new Anonymous22();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        if (this.assets && this.assets.constructor === Array) {
            data["assets"] = [];
            for (let item of this.assets)
                data["assets"].push(item.toJSON());
        }
        data["assets_url"] = this.assets_url;
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["body"] = this.body;
        data["created_at"] = this.created_at;
        data["draft"] = this.draft;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["name"] = this.name;
        data["prerelease"] = this.prerelease;
        data["published_at"] = this.published_at;
        data["tag_name"] = this.tag_name;
        data["tarball_url"] = this.tarball_url;
        data["target_commitish"] = this.target_commitish;
        data["upload_url"] = this.upload_url;
        data["url"] = this.url;
        data["zipball_url"] = this.zipball_url;
        return data; 
    }
}

interface IAnonymous22 {
    assets?: assets[];
    assets_url?: string;
    author?: author7;
    body?: string;
    created_at?: string;
    draft?: boolean;
    html_url?: string;
    id?: number;
    name?: string;
    prerelease?: boolean;
    published_at?: string;
    tag_name?: string;
    tarball_url?: string;
    target_commitish?: string;
    upload_url?: string;
    url?: string;
    zipball_url?: string;
}

class Anonymous23 implements IAnonymous23 {
    content_type?: string;
    created_at?: string;
    download_count?: number;
    id?: number;
    label?: string;
    name?: string;
    size?: number;
    state?: string;
    updated_at?: string;
    uploader?: uploader;
    url?: string;

    constructor(data?: IAnonymous23) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content_type = data["content_type"];
            this.created_at = data["created_at"];
            this.download_count = data["download_count"];
            this.id = data["id"];
            this.label = data["label"];
            this.name = data["name"];
            this.size = data["size"];
            this.state = data["state"];
            this.updated_at = data["updated_at"];
            this.uploader = data["uploader"] ? uploader.fromJS(data["uploader"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous23 {
        let result = new Anonymous23();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["content_type"] = this.content_type;
        data["created_at"] = this.created_at;
        data["download_count"] = this.download_count;
        data["id"] = this.id;
        data["label"] = this.label;
        data["name"] = this.name;
        data["size"] = this.size;
        data["state"] = this.state;
        data["updated_at"] = this.updated_at;
        data["uploader"] = this.uploader ? this.uploader.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

interface IAnonymous23 {
    content_type?: string;
    created_at?: string;
    download_count?: number;
    id?: number;
    label?: string;
    name?: string;
    size?: number;
    state?: string;
    updated_at?: string;
    uploader?: uploader;
    url?: string;
}

class Anonymous24 implements IAnonymous24 {
    author?: author8;
    /** The Total number of commits authored by the contributor. */
    total?: number;
    weeks?: Weeks[];

    constructor(data?: IAnonymous24) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? author8.fromJS(data["author"]) : <any>undefined;
            this.total = data["total"];
            if (data["weeks"] && data["weeks"].constructor === Array) {
                this.weeks = [];
                for (let item of data["weeks"])
                    this.weeks.push(Weeks.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Anonymous24 {
        let result = new Anonymous24();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["total"] = this.total;
        if (this.weeks && this.weeks.constructor === Array) {
            data["weeks"] = [];
            for (let item of this.weeks)
                data["weeks"].push(item.toJSON());
        }
        return data; 
    }
}

interface IAnonymous24 {
    author?: author8;
    /** The Total number of commits authored by the contributor. */
    total?: number;
    weeks?: Weeks[];
}

class Anonymous25 implements IAnonymous25 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    creator?: creator4;
    description?: string;
    id?: number;
    state?: string;
    target_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;

    constructor(data?: IAnonymous25) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.created_at = data["created_at"];
            this.creator = data["creator"] ? creator4.fromJS(data["creator"]) : <any>undefined;
            this.description = data["description"];
            this.id = data["id"];
            this.state = data["state"];
            this.target_url = data["target_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous25 {
        let result = new Anonymous25();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["created_at"] = this.created_at;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["id"] = this.id;
        data["state"] = this.state;
        data["target_url"] = this.target_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        return data; 
    }
}

interface IAnonymous25 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    creator?: creator4;
    description?: string;
    id?: number;
    state?: string;
    target_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
}

class Anonymous26 implements IAnonymous26 {
    description?: string;
    fork?: boolean;
    full_name?: string;
    html_url?: string;
    id?: number;
    name?: string;
    owner?: owner4;
    private?: boolean;
    url?: string;

    constructor(data?: IAnonymous26) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.fork = data["fork"];
            this.full_name = data["full_name"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.name = data["name"];
            this.owner = data["owner"] ? owner4.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous26 {
        let result = new Anonymous26();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["full_name"] = this.full_name;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["name"] = this.name;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["url"] = this.url;
        return data; 
    }
}

interface IAnonymous26 {
    description?: string;
    fork?: boolean;
    full_name?: string;
    html_url?: string;
    id?: number;
    name?: string;
    owner?: owner4;
    private?: boolean;
    url?: string;
}

class Anonymous27 implements IAnonymous27 {
    clone_url?: string;
    created_at?: string;
    description?: string;
    fork?: boolean;
    forks?: number;
    forks_count?: number;
    full_name?: string;
    git_url?: string;
    homepage?: string;
    html_url?: string;
    id?: number;
    language?: Language;
    master_branch?: string;
    mirror_url?: string;
    name?: string;
    open_issues?: number;
    open_issues_count?: number;
    owner?: owner5;
    private?: boolean;
    pushed_at?: string;
    size?: number;
    ssh_url?: string;
    svn_url?: string;
    updated_at?: string;
    url?: string;
    watchers?: number;
    watchers_count?: number;

    constructor(data?: IAnonymous27) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clone_url = data["clone_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.forks_count = data["forks_count"];
            this.full_name = data["full_name"];
            this.git_url = data["git_url"];
            this.homepage = data["homepage"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.language = data["language"];
            this.master_branch = data["master_branch"];
            this.mirror_url = data["mirror_url"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.open_issues_count = data["open_issues_count"];
            this.owner = data["owner"] ? owner5.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.pushed_at = data["pushed_at"];
            this.size = data["size"];
            this.ssh_url = data["ssh_url"];
            this.svn_url = data["svn_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.watchers = data["watchers"];
            this.watchers_count = data["watchers_count"];
        }
    }

    static fromJS(data: any): Anonymous27 {
        let result = new Anonymous27();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["clone_url"] = this.clone_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["forks_count"] = this.forks_count;
        data["full_name"] = this.full_name;
        data["git_url"] = this.git_url;
        data["homepage"] = this.homepage;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["language"] = this.language;
        data["master_branch"] = this.master_branch;
        data["mirror_url"] = this.mirror_url;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["open_issues_count"] = this.open_issues_count;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pushed_at"] = this.pushed_at;
        data["size"] = this.size;
        data["ssh_url"] = this.ssh_url;
        data["svn_url"] = this.svn_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["watchers"] = this.watchers;
        data["watchers_count"] = this.watchers_count;
        return data; 
    }
}

interface IAnonymous27 {
    clone_url?: string;
    created_at?: string;
    description?: string;
    fork?: boolean;
    forks?: number;
    forks_count?: number;
    full_name?: string;
    git_url?: string;
    homepage?: string;
    html_url?: string;
    id?: number;
    language?: Language;
    master_branch?: string;
    mirror_url?: string;
    name?: string;
    open_issues?: number;
    open_issues_count?: number;
    owner?: owner5;
    private?: boolean;
    pushed_at?: string;
    size?: number;
    ssh_url?: string;
    svn_url?: string;
    updated_at?: string;
    url?: string;
    watchers?: number;
    watchers_count?: number;
}

class Anonymous28 implements IAnonymous28 {
    clone_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    description?: string;
    fork?: boolean;
    forks?: number;
    forks_count?: number;
    full_name?: string;
    git_url?: string;
    homepage?: string;
    html_url?: string;
    id?: number;
    language?: string;
    master_branch?: number;
    mirror_url?: string;
    name?: string;
    open_issues?: number;
    open_issues_count?: number;
    owner?: owner6;
    private?: boolean;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string;
    size?: number;
    ssh_url?: string;
    svn_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    watchers?: number;
    watchers_count?: number;

    constructor(data?: IAnonymous28) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clone_url = data["clone_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.forks_count = data["forks_count"];
            this.full_name = data["full_name"];
            this.git_url = data["git_url"];
            this.homepage = data["homepage"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.language = data["language"];
            this.master_branch = data["master_branch"];
            this.mirror_url = data["mirror_url"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.open_issues_count = data["open_issues_count"];
            this.owner = data["owner"] ? owner6.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.pushed_at = data["pushed_at"];
            this.size = data["size"];
            this.ssh_url = data["ssh_url"];
            this.svn_url = data["svn_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.watchers = data["watchers"];
            this.watchers_count = data["watchers_count"];
        }
    }

    static fromJS(data: any): Anonymous28 {
        let result = new Anonymous28();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["clone_url"] = this.clone_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["forks_count"] = this.forks_count;
        data["full_name"] = this.full_name;
        data["git_url"] = this.git_url;
        data["homepage"] = this.homepage;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["language"] = this.language;
        data["master_branch"] = this.master_branch;
        data["mirror_url"] = this.mirror_url;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["open_issues_count"] = this.open_issues_count;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pushed_at"] = this.pushed_at;
        data["size"] = this.size;
        data["ssh_url"] = this.ssh_url;
        data["svn_url"] = this.svn_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["watchers"] = this.watchers;
        data["watchers_count"] = this.watchers_count;
        return data; 
    }
}

interface IAnonymous28 {
    clone_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    description?: string;
    fork?: boolean;
    forks?: number;
    forks_count?: number;
    full_name?: string;
    git_url?: string;
    homepage?: string;
    html_url?: string;
    id?: number;
    language?: string;
    master_branch?: number;
    mirror_url?: string;
    name?: string;
    open_issues?: number;
    open_issues_count?: number;
    owner?: owner6;
    private?: boolean;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string;
    size?: number;
    ssh_url?: string;
    svn_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    watchers?: number;
    watchers_count?: number;
}

class Anonymous29 implements IAnonymous29 {
    id?: number;
    members_count?: number;
    name?: string;
    organization?: organization2;
    permission?: string;
    repos_count?: number;
    url?: string;

    constructor(data?: IAnonymous29) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.members_count = data["members_count"];
            this.name = data["name"];
            this.organization = data["organization"] ? organization2.fromJS(data["organization"]) : <any>undefined;
            this.permission = data["permission"];
            this.repos_count = data["repos_count"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous29 {
        let result = new Anonymous29();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["id"] = this.id;
        data["members_count"] = this.members_count;
        data["name"] = this.name;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        data["permission"] = this.permission;
        data["repos_count"] = this.repos_count;
        data["url"] = this.url;
        return data; 
    }
}

interface IAnonymous29 {
    id?: number;
    members_count?: number;
    name?: string;
    organization?: organization2;
    permission?: string;
    repos_count?: number;
    url?: string;
}

class Anonymous30 implements IAnonymous30 {
    days?: number[];
    total?: number;
    week?: number;

    constructor(data?: IAnonymous30) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["days"] && data["days"].constructor === Array) {
                this.days = [];
                for (let item of data["days"])
                    this.days.push(item);
            }
            this.total = data["total"];
            this.week = data["week"];
        }
    }

    static fromJS(data: any): Anonymous30 {
        let result = new Anonymous30();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        if (this.days && this.days.constructor === Array) {
            data["days"] = [];
            for (let item of this.days)
                data["days"].push(item);
        }
        data["total"] = this.total;
        data["week"] = this.week;
        return data; 
    }
}

interface IAnonymous30 {
    days?: number[];
    total?: number;
    week?: number;
}

class Uploader implements IUploader {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    site_admin?: boolean;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;

    constructor(data?: IUploader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.site_admin = data["site_admin"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Uploader {
        let result = new Uploader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["site_admin"] = this.site_admin;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface IUploader {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    site_admin?: boolean;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;
}

enum BlobEncoding {
    Utf8 = <any>"utf-8", 
    Base64 = <any>"base64", 
}

class _links implements I_links {
    html?: string;
    self?: string;

    constructor(data?: I_links) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.html = data["html"];
            this.self = data["self"];
        }
    }

    static fromJS(data: any): _links {
        let result = new _links();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["html"] = this.html;
        data["self"] = this.self;
        return data; 
    }
}

interface I_links {
    html?: string;
    self?: string;
}

class commit implements Icommit {
    author?: author9;
    commit?: commit8;
    committer?: committer6;
    parents?: parents4[];
    sha?: string;
    url?: string;

    constructor(data?: Icommit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? author9.fromJS(data["author"]) : <any>undefined;
            this.commit = data["commit"] ? commit8.fromJS(data["commit"]) : <any>undefined;
            this.committer = data["committer"] ? committer6.fromJS(data["committer"]) : <any>undefined;
            if (data["parents"] && data["parents"].constructor === Array) {
                this.parents = [];
                for (let item of data["parents"])
                    this.parents.push(parents4.fromJS(item));
            }
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): commit {
        let result = new commit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["commit"] = this.commit ? this.commit.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        if (this.parents && this.parents.constructor === Array) {
            data["parents"] = [];
            for (let item of this.parents)
                data["parents"].push(item.toJSON());
        }
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

interface Icommit {
    author?: author9;
    commit?: commit8;
    committer?: committer6;
    parents?: parents4[];
    sha?: string;
    url?: string;
}

class Author implements IAuthor {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: IAuthor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Author {
        let result = new Author();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface IAuthor {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class commit2 implements Icommit2 {
    author?: author10;
    committer?: committer7;
    message?: string;
    tree?: tree4;
    url?: string;

    constructor(data?: Icommit2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? author10.fromJS(data["author"]) : <any>undefined;
            this.committer = data["committer"] ? committer7.fromJS(data["committer"]) : <any>undefined;
            this.message = data["message"];
            this.tree = data["tree"] ? tree4.fromJS(data["tree"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): commit2 {
        let result = new commit2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["tree"] = this.tree ? this.tree.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

interface Icommit2 {
    author?: author10;
    committer?: committer7;
    message?: string;
    tree?: tree4;
    url?: string;
}

class Committer implements ICommitter {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: ICommitter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Committer {
        let result = new Committer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface ICommitter {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class Files implements IFiles {
    additions?: number;
    blob_url?: string;
    changes?: number;
    deletions?: number;
    filename?: string;
    patch?: string;
    raw_url?: string;
    status?: string;

    constructor(data?: IFiles) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.additions = data["additions"];
            this.blob_url = data["blob_url"];
            this.changes = data["changes"];
            this.deletions = data["deletions"];
            this.filename = data["filename"];
            this.patch = data["patch"];
            this.raw_url = data["raw_url"];
            this.status = data["status"];
        }
    }

    static fromJS(data: any): Files {
        let result = new Files();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["additions"] = this.additions;
        data["blob_url"] = this.blob_url;
        data["changes"] = this.changes;
        data["deletions"] = this.deletions;
        data["filename"] = this.filename;
        data["patch"] = this.patch;
        data["raw_url"] = this.raw_url;
        data["status"] = this.status;
        return data; 
    }
}

interface IFiles {
    additions?: number;
    blob_url?: string;
    changes?: number;
    deletions?: number;
    filename?: string;
    patch?: string;
    raw_url?: string;
    status?: string;
}

class Parents implements IParents {
    sha?: string;
    url?: string;

    constructor(data?: IParents) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Parents {
        let result = new Parents();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

interface IParents {
    sha?: string;
    url?: string;
}

class Stats implements IStats {
    additions?: number;
    deletions?: number;
    total?: number;

    constructor(data?: IStats) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.additions = data["additions"];
            this.deletions = data["deletions"];
            this.total = data["total"];
        }
    }

    static fromJS(data: any): Stats {
        let result = new Stats();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["additions"] = this.additions;
        data["deletions"] = this.deletions;
        data["total"] = this.total;
        return data; 
    }
}

interface IStats {
    additions?: number;
    deletions?: number;
    total?: number;
}

class user implements Iuser {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iuser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): user {
        let result = new user();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iuser {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class Base_commit implements IBase_commit {
    author?: author11;
    commit?: commit9;
    committer?: committer8;
    parents?: parents5[];
    sha?: string;
    url?: string;

    constructor(data?: IBase_commit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? author11.fromJS(data["author"]) : <any>undefined;
            this.commit = data["commit"] ? commit9.fromJS(data["commit"]) : <any>undefined;
            this.committer = data["committer"] ? committer8.fromJS(data["committer"]) : <any>undefined;
            if (data["parents"] && data["parents"].constructor === Array) {
                this.parents = [];
                for (let item of data["parents"])
                    this.parents.push(parents5.fromJS(item));
            }
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Base_commit {
        let result = new Base_commit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["commit"] = this.commit ? this.commit.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        if (this.parents && this.parents.constructor === Array) {
            data["parents"] = [];
            for (let item of this.parents)
                data["parents"].push(item.toJSON());
        }
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

interface IBase_commit {
    author?: author11;
    commit?: commit9;
    committer?: committer8;
    parents?: parents5[];
    sha?: string;
    url?: string;
}

class Commits implements ICommits {
    author?: author12;
    commit?: commit10;
    committer?: committer9;
    parents?: parents6[];
    sha?: string;
    url?: string;

    constructor(data?: ICommits) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? author12.fromJS(data["author"]) : <any>undefined;
            this.commit = data["commit"] ? commit10.fromJS(data["commit"]) : <any>undefined;
            this.committer = data["committer"] ? committer9.fromJS(data["committer"]) : <any>undefined;
            if (data["parents"] && data["parents"].constructor === Array) {
                this.parents = [];
                for (let item of data["parents"])
                    this.parents.push(parents6.fromJS(item));
            }
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Commits {
        let result = new Commits();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["commit"] = this.commit ? this.commit.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        if (this.parents && this.parents.constructor === Array) {
            data["parents"] = [];
            for (let item of this.parents)
                data["parents"].push(item.toJSON());
        }
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

interface ICommits {
    author?: author12;
    commit?: commit10;
    committer?: committer9;
    parents?: parents6[];
    sha?: string;
    url?: string;
}

class files implements Ifiles {
    additions?: number;
    blob_url?: string;
    changes?: number;
    contents_url?: string;
    deletions?: number;
    filename?: string;
    patch?: string;
    raw_url?: string;
    sha?: string;
    status?: string;

    constructor(data?: Ifiles) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.additions = data["additions"];
            this.blob_url = data["blob_url"];
            this.changes = data["changes"];
            this.contents_url = data["contents_url"];
            this.deletions = data["deletions"];
            this.filename = data["filename"];
            this.patch = data["patch"];
            this.raw_url = data["raw_url"];
            this.sha = data["sha"];
            this.status = data["status"];
        }
    }

    static fromJS(data: any): files {
        let result = new files();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["additions"] = this.additions;
        data["blob_url"] = this.blob_url;
        data["changes"] = this.changes;
        data["contents_url"] = this.contents_url;
        data["deletions"] = this.deletions;
        data["filename"] = this.filename;
        data["patch"] = this.patch;
        data["raw_url"] = this.raw_url;
        data["sha"] = this.sha;
        data["status"] = this.status;
        return data; 
    }
}

interface Ifiles {
    additions?: number;
    blob_url?: string;
    changes?: number;
    contents_url?: string;
    deletions?: number;
    filename?: string;
    patch?: string;
    raw_url?: string;
    sha?: string;
    status?: string;
}

class _links2 implements I_links2 {
    git?: string;
    html?: string;
    self?: string;

    constructor(data?: I_links2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.git = data["git"];
            this.html = data["html"];
            this.self = data["self"];
        }
    }

    static fromJS(data: any): _links2 {
        let result = new _links2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["git"] = this.git;
        data["html"] = this.html;
        data["self"] = this.self;
        return data; 
    }
}

interface I_links2 {
    git?: string;
    html?: string;
    self?: string;
}

class commit3 implements Icommit3 {
    author?: author13;
    committer?: committer10;
    html_url?: string;
    message?: string;
    parents?: parents7[];
    sha?: string;
    tree?: tree5;
    url?: string;

    constructor(data?: Icommit3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? author13.fromJS(data["author"]) : <any>undefined;
            this.committer = data["committer"] ? committer10.fromJS(data["committer"]) : <any>undefined;
            this.html_url = data["html_url"];
            this.message = data["message"];
            if (data["parents"] && data["parents"].constructor === Array) {
                this.parents = [];
                for (let item of data["parents"])
                    this.parents.push(parents7.fromJS(item));
            }
            this.sha = data["sha"];
            this.tree = data["tree"] ? tree5.fromJS(data["tree"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): commit3 {
        let result = new commit3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        data["html_url"] = this.html_url;
        data["message"] = this.message;
        if (this.parents && this.parents.constructor === Array) {
            data["parents"] = [];
            for (let item of this.parents)
                data["parents"].push(item.toJSON());
        }
        data["sha"] = this.sha;
        data["tree"] = this.tree ? this.tree.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

interface Icommit3 {
    author?: author13;
    committer?: committer10;
    html_url?: string;
    message?: string;
    parents?: parents7[];
    sha?: string;
    tree?: tree5;
    url?: string;
}

class Content implements IContent {
    _links?: _links9;
    git_url?: string;
    html_url?: string;
    name?: string;
    path?: string;
    sha?: string;
    size?: number;
    type?: string;
    url?: string;

    constructor(data?: IContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this._links = data["_links"] ? _links9.fromJS(data["_links"]) : <any>undefined;
            this.git_url = data["git_url"];
            this.html_url = data["html_url"];
            this.name = data["name"];
            this.path = data["path"];
            this.sha = data["sha"];
            this.size = data["size"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Content {
        let result = new Content();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
        data["git_url"] = this.git_url;
        data["html_url"] = this.html_url;
        data["name"] = this.name;
        data["path"] = this.path;
        data["sha"] = this.sha;
        data["size"] = this.size;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface IContent {
    _links?: _links9;
    git_url?: string;
    html_url?: string;
    name?: string;
    path?: string;
    sha?: string;
    size?: number;
    type?: string;
    url?: string;
}

class committer implements Icommitter {
    email?: string;
    name?: string;

    constructor(data?: Icommitter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): committer {
        let result = new committer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

interface Icommitter {
    email?: string;
    name?: string;
}

class commit4 implements Icommit4 {
    author?: author14;
    committer?: committer11;
    html_url?: string;
    message?: string;
    parents?: parents8;
    sha?: string;
    tree?: tree6;
    url?: string;

    constructor(data?: Icommit4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? author14.fromJS(data["author"]) : <any>undefined;
            this.committer = data["committer"] ? committer11.fromJS(data["committer"]) : <any>undefined;
            this.html_url = data["html_url"];
            this.message = data["message"];
            this.parents = data["parents"] ? parents8.fromJS(data["parents"]) : <any>undefined;
            this.sha = data["sha"];
            this.tree = data["tree"] ? tree6.fromJS(data["tree"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): commit4 {
        let result = new commit4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        data["html_url"] = this.html_url;
        data["message"] = this.message;
        data["parents"] = this.parents ? this.parents.toJSON() : <any>undefined;
        data["sha"] = this.sha;
        data["tree"] = this.tree ? this.tree.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

interface Icommit4 {
    author?: author14;
    committer?: committer11;
    html_url?: string;
    message?: string;
    parents?: parents8;
    sha?: string;
    tree?: tree6;
    url?: string;
}

class committer2 implements Icommitter2 {
    email?: string;
    name?: string;

    constructor(data?: Icommitter2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): committer2 {
        let result = new committer2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

interface Icommitter2 {
    email?: string;
    name?: string;
}

class Payload implements IPayload {
    deploy_user?: string;
    environment?: string;
    room_id?: number;

    constructor(data?: IPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deploy_user = data["deploy_user"];
            this.environment = data["environment"];
            this.room_id = data["room_id"];
        }
    }

    static fromJS(data: any): Payload {
        let result = new Payload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["deploy_user"] = this.deploy_user;
        data["environment"] = this.environment;
        data["room_id"] = this.room_id;
        return data; 
    }
}

interface IPayload {
    deploy_user?: string;
    environment?: string;
    room_id?: number;
}

class Creator implements ICreator {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    site_admin?: boolean;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;

    constructor(data?: ICreator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.site_admin = data["site_admin"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Creator {
        let result = new Creator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["site_admin"] = this.site_admin;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface ICreator {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    site_admin?: boolean;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;
}

enum EditTeamPermission {
    Pull = <any>"pull", 
    Push = <any>"push", 
    Admin = <any>"admin", 
}

class Actor implements IActor {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: IActor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Actor {
        let result = new Actor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface IActor {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class issue implements Iissue {
    assignee?: assignee;
    body?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    closed_at?: string;
    comments?: number;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    html_url?: string;
    labels?: labels[];
    milestone?: milestone2;
    number?: number;
    pull_request?: pull_request;
    state?: IssueState;
    title?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    user?: user13;

    constructor(data?: Iissue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assignee = data["assignee"] ? assignee.fromJS(data["assignee"]) : <any>undefined;
            this.body = data["body"];
            this.closed_at = data["closed_at"];
            this.comments = data["comments"];
            this.created_at = data["created_at"];
            this.html_url = data["html_url"];
            if (data["labels"] && data["labels"].constructor === Array) {
                this.labels = [];
                for (let item of data["labels"])
                    this.labels.push(labels.fromJS(item));
            }
            this.milestone = data["milestone"] ? milestone2.fromJS(data["milestone"]) : <any>undefined;
            this.number = data["number"];
            this.pull_request = data["pull_request"] ? pull_request.fromJS(data["pull_request"]) : <any>undefined;
            this.state = data["state"] ? IssueState.fromJS(data["state"]) : <any>undefined;
            this.title = data["title"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.user = data["user"] ? user13.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): issue {
        let result = new issue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["assignee"] = this.assignee ? this.assignee.toJSON() : <any>undefined;
        data["body"] = this.body;
        data["closed_at"] = this.closed_at;
        data["comments"] = this.comments;
        data["created_at"] = this.created_at;
        data["html_url"] = this.html_url;
        if (this.labels && this.labels.constructor === Array) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item.toJSON());
        }
        data["milestone"] = this.milestone ? this.milestone.toJSON() : <any>undefined;
        data["number"] = this.number;
        data["pull_request"] = this.pull_request ? this.pull_request.toJSON() : <any>undefined;
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

interface Iissue {
    assignee?: assignee;
    body?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    closed_at?: string;
    comments?: number;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    html_url?: string;
    labels?: labels[];
    milestone?: milestone2;
    number?: number;
    pull_request?: pull_request;
    state?: IssueState;
    title?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    user?: user13;
}

class actor implements Iactor {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iactor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): actor {
        let result = new actor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iactor {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class Org implements IOrg {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: IOrg) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Org {
        let result = new Org();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface IOrg {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class repo implements Irepo {
    id?: number;
    name?: string;
    url?: string;

    constructor(data?: Irepo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): repo {
        let result = new repo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["url"] = this.url;
        return data; 
    }
}

interface Irepo {
    id?: number;
    name?: string;
    url?: string;
}

class _links3 implements I_links3 {
    current_user?: Current_user;
    current_user_actor?: Current_user_actor;
    current_user_organization?: Current_user_organization;
    current_user_public?: Current_user_public;
    timeline?: Timeline;
    user?: user14;

    constructor(data?: I_links3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.current_user = data["current_user"] ? Current_user.fromJS(data["current_user"]) : <any>undefined;
            this.current_user_actor = data["current_user_actor"] ? Current_user_actor.fromJS(data["current_user_actor"]) : <any>undefined;
            this.current_user_organization = data["current_user_organization"] ? Current_user_organization.fromJS(data["current_user_organization"]) : <any>undefined;
            this.current_user_public = data["current_user_public"] ? Current_user_public.fromJS(data["current_user_public"]) : <any>undefined;
            this.timeline = data["timeline"] ? Timeline.fromJS(data["timeline"]) : <any>undefined;
            this.user = data["user"] ? user14.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): _links3 {
        let result = new _links3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["current_user"] = this.current_user ? this.current_user.toJSON() : <any>undefined;
        data["current_user_actor"] = this.current_user_actor ? this.current_user_actor.toJSON() : <any>undefined;
        data["current_user_organization"] = this.current_user_organization ? this.current_user_organization.toJSON() : <any>undefined;
        data["current_user_public"] = this.current_user_public ? this.current_user_public.toJSON() : <any>undefined;
        data["timeline"] = this.timeline ? this.timeline.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

interface I_links3 {
    current_user?: Current_user;
    current_user_actor?: Current_user_actor;
    current_user_organization?: Current_user_organization;
    current_user_public?: Current_user_public;
    timeline?: Timeline;
    user?: user14;
}

class Owner implements IOwner {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: IOwner) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Owner {
        let result = new Owner();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface IOwner {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class files2 implements Ifiles2 {
    ringErl?: RingErl;

    constructor(data?: Ifiles2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ringErl = data["ring.erl"] ? RingErl.fromJS(data["ring.erl"]) : <any>undefined;
        }
    }

    static fromJS(data: any): files2 {
        let result = new files2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["ring.erl"] = this.ringErl ? this.ringErl.toJSON() : <any>undefined;
        return data; 
    }
}

interface Ifiles2 {
    ringErl?: RingErl;
}

class Forks implements IForks {
    /** Timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. */
    created_at?: string;
    url?: string;
    user?: user15;

    constructor(data?: IForks) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.created_at = data["created_at"];
            this.url = data["url"];
            this.user = data["user"] ? user15.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Forks {
        let result = new Forks();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["created_at"] = this.created_at;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

interface IForks {
    /** Timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. */
    created_at?: string;
    url?: string;
    user?: user15;
}

class History implements IHistory {
    change_status?: Change_status;
    /** Timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. */
    committed_at?: string;
    url?: string;
    user?: user16;
    version?: string;

    constructor(data?: IHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.change_status = data["change_status"] ? Change_status.fromJS(data["change_status"]) : <any>undefined;
            this.committed_at = data["committed_at"];
            this.url = data["url"];
            this.user = data["user"] ? user16.fromJS(data["user"]) : <any>undefined;
            this.version = data["version"];
        }
    }

    static fromJS(data: any): History {
        let result = new History();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["change_status"] = this.change_status ? this.change_status.toJSON() : <any>undefined;
        data["committed_at"] = this.committed_at;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["version"] = this.version;
        return data; 
    }
}

interface IHistory {
    change_status?: Change_status;
    /** Timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. */
    committed_at?: string;
    url?: string;
    user?: user16;
    version?: string;
}

class user2 implements Iuser2 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iuser2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): user2 {
        let result = new user2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iuser2 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class author implements Iauthor {
    date?: string;
    email?: string;
    name?: string;

    constructor(data?: Iauthor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): author {
        let result = new author();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

interface Iauthor {
    date?: string;
    email?: string;
    name?: string;
}

class ObjectP implements IObject {
    sha?: string;
    type?: string;
    url?: string;

    constructor(data?: IObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): ObjectP {
        let result = new ObjectP();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["sha"] = this.sha;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface IObject {
    sha?: string;
    type?: string;
    url?: string;
}

class user3 implements Iuser3 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iuser3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): user3 {
        let result = new user3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iuser3 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class author2 implements Iauthor2 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;

    constructor(data?: Iauthor2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): author2 {
        let result = new author2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface Iauthor2 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;
}

class commit5 implements Icommit5 {
    author?: author15;
    comment_count?: number;
    committer?: committer12;
    message?: string;
    tree?: tree7;
    url?: string;

    constructor(data?: Icommit5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? author15.fromJS(data["author"]) : <any>undefined;
            this.comment_count = data["comment_count"];
            this.committer = data["committer"] ? committer12.fromJS(data["committer"]) : <any>undefined;
            this.message = data["message"];
            this.tree = data["tree"] ? tree7.fromJS(data["tree"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): commit5 {
        let result = new commit5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["comment_count"] = this.comment_count;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["tree"] = this.tree ? this.tree.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

interface Icommit5 {
    author?: author15;
    comment_count?: number;
    committer?: committer12;
    message?: string;
    tree?: tree7;
    url?: string;
}

class committer3 implements Icommitter3 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;

    constructor(data?: Icommitter3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): committer3 {
        let result = new committer3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface Icommitter3 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;
}

class parents implements Iparents {
    sha?: string;
    url?: string;

    constructor(data?: Iparents) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): parents {
        let result = new parents();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

interface Iparents {
    sha?: string;
    url?: string;
}

class creator implements Icreator {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Icreator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): creator {
        let result = new creator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Icreator {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

enum MilestoneState {
    Open = <any>"open", 
    Closed = <any>"closed", 
}

class Repository implements IRepository {
    description?: string;
    fork?: boolean;
    full_name?: string;
    html_url?: string;
    id?: number;
    name?: string;
    owner?: owner7;
    private?: boolean;
    url?: string;

    constructor(data?: IRepository) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.fork = data["fork"];
            this.full_name = data["full_name"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.name = data["name"];
            this.owner = data["owner"] ? owner7.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Repository {
        let result = new Repository();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["full_name"] = this.full_name;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["name"] = this.name;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["url"] = this.url;
        return data; 
    }
}

interface IRepository {
    description?: string;
    fork?: boolean;
    full_name?: string;
    html_url?: string;
    id?: number;
    name?: string;
    owner?: owner7;
    private?: boolean;
    url?: string;
}

class Subject implements ISubject {
    latest_comment_url?: string;
    title?: string;
    type?: string;
    url?: string;

    constructor(data?: ISubject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.latest_comment_url = data["latest_comment_url"];
            this.title = data["title"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Subject {
        let result = new Subject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["latest_comment_url"] = this.latest_comment_url;
        data["title"] = this.title;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface ISubject {
    latest_comment_url?: string;
    title?: string;
    type?: string;
    url?: string;
}

enum OrgTeamsPostPermission {
    Pull = <any>"pull", 
    Push = <any>"push", 
    Admin = <any>"admin", 
}

class Errors implements IErrors {
    code?: string;
    field?: string;
    resource?: string;

    constructor(data?: IErrors) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.field = data["field"];
            this.resource = data["resource"];
        }
    }

    static fromJS(data: any): Errors {
        let result = new Errors();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["code"] = this.code;
        data["field"] = this.field;
        data["resource"] = this.resource;
        return data; 
    }
}

interface IErrors {
    code?: string;
    field?: string;
    resource?: string;
}

class files3 implements Ifiles3 {
    delete_this_fileTxt?: string;
    file1Txt?: File1Txt;
    new_fileTxt?: New_fileTxt;
    old_nameTxt?: Old_nameTxt;

    constructor(data?: Ifiles3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.delete_this_fileTxt = data["delete_this_file.txt"];
            this.file1Txt = data["file1.txt"] ? File1Txt.fromJS(data["file1.txt"]) : <any>undefined;
            this.new_fileTxt = data["new_file.txt"] ? New_fileTxt.fromJS(data["new_file.txt"]) : <any>undefined;
            this.old_nameTxt = data["old_name.txt"] ? Old_nameTxt.fromJS(data["old_name.txt"]) : <any>undefined;
        }
    }

    static fromJS(data: any): files3 {
        let result = new files3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["delete_this_file.txt"] = this.delete_this_fileTxt;
        data["file1.txt"] = this.file1Txt ? this.file1Txt.toJSON() : <any>undefined;
        data["new_file.txt"] = this.new_fileTxt ? this.new_fileTxt.toJSON() : <any>undefined;
        data["old_name.txt"] = this.old_nameTxt ? this.old_nameTxt.toJSON() : <any>undefined;
        return data; 
    }
}

interface Ifiles3 {
    delete_this_fileTxt?: string;
    file1Txt?: File1Txt;
    new_fileTxt?: New_fileTxt;
    old_nameTxt?: Old_nameTxt;
}

class files4 implements Ifiles4 {
    file1Txt?: file1Txt;

    constructor(data?: Ifiles4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.file1Txt = data["file1.txt"] ? file1Txt.fromJS(data["file1.txt"]) : <any>undefined;
        }
    }

    static fromJS(data: any): files4 {
        let result = new files4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["file1.txt"] = this.file1Txt ? this.file1Txt.toJSON() : <any>undefined;
        return data; 
    }
}

interface Ifiles4 {
    file1Txt?: file1Txt;
}

class _links4 implements I_links4 {
    comments?: Comments;
    html?: Html;
    review_comments?: Review_comments;
    self?: Self;

    constructor(data?: I_links4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.comments = data["comments"] ? Comments.fromJS(data["comments"]) : <any>undefined;
            this.html = data["html"] ? Html.fromJS(data["html"]) : <any>undefined;
            this.review_comments = data["review_comments"] ? Review_comments.fromJS(data["review_comments"]) : <any>undefined;
            this.self = data["self"] ? Self.fromJS(data["self"]) : <any>undefined;
        }
    }

    static fromJS(data: any): _links4 {
        let result = new _links4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["comments"] = this.comments ? this.comments.toJSON() : <any>undefined;
        data["html"] = this.html ? this.html.toJSON() : <any>undefined;
        data["review_comments"] = this.review_comments ? this.review_comments.toJSON() : <any>undefined;
        data["self"] = this.self ? this.self.toJSON() : <any>undefined;
        return data; 
    }
}

interface I_links4 {
    comments?: Comments;
    html?: Html;
    review_comments?: Review_comments;
    self?: Self;
}

class Base implements IBase {
    label?: string;
    ref?: string;
    repo?: repo2;
    sha?: string;
    user?: user17;

    constructor(data?: IBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.ref = data["ref"];
            this.repo = data["repo"] ? repo2.fromJS(data["repo"]) : <any>undefined;
            this.sha = data["sha"];
            this.user = data["user"] ? user17.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Base {
        let result = new Base();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["label"] = this.label;
        data["ref"] = this.ref;
        data["repo"] = this.repo ? this.repo.toJSON() : <any>undefined;
        data["sha"] = this.sha;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

interface IBase {
    label?: string;
    ref?: string;
    repo?: repo2;
    sha?: string;
    user?: user17;
}

class Head implements IHead {
    label?: string;
    ref?: string;
    repo?: repo3;
    sha?: string;
    user?: user18;

    constructor(data?: IHead) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.ref = data["ref"];
            this.repo = data["repo"] ? repo3.fromJS(data["repo"]) : <any>undefined;
            this.sha = data["sha"];
            this.user = data["user"] ? user18.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Head {
        let result = new Head();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["label"] = this.label;
        data["ref"] = this.ref;
        data["repo"] = this.repo ? this.repo.toJSON() : <any>undefined;
        data["sha"] = this.sha;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

interface IHead {
    label?: string;
    ref?: string;
    repo?: repo3;
    sha?: string;
    user?: user18;
}

class Merged_by implements IMerged_by {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: IMerged_by) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Merged_by {
        let result = new Merged_by();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface IMerged_by {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class user4 implements Iuser4 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iuser4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): user4 {
        let result = new user4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iuser4 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class _links5 implements I_links5 {
    html?: html;
    pull_request?: pull_request2;
    self?: self;

    constructor(data?: I_links5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.html = data["html"] ? html.fromJS(data["html"]) : <any>undefined;
            this.pull_request = data["pull_request"] ? pull_request2.fromJS(data["pull_request"]) : <any>undefined;
            this.self = data["self"] ? self.fromJS(data["self"]) : <any>undefined;
        }
    }

    static fromJS(data: any): _links5 {
        let result = new _links5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["html"] = this.html ? this.html.toJSON() : <any>undefined;
        data["pull_request"] = this.pull_request ? this.pull_request.toJSON() : <any>undefined;
        data["self"] = this.self ? this.self.toJSON() : <any>undefined;
        return data; 
    }
}

interface I_links5 {
    html?: html;
    pull_request?: pull_request2;
    self?: self;
}

class user5 implements Iuser5 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iuser5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): user5 {
        let result = new user5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iuser5 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class Rate implements IRate {
    limit?: number;
    remaining?: number;
    reset?: number;

    constructor(data?: IRate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.limit = data["limit"];
            this.remaining = data["remaining"];
            this.reset = data["reset"];
        }
    }

    static fromJS(data: any): Rate {
        let result = new Rate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["limit"] = this.limit;
        data["remaining"] = this.remaining;
        data["reset"] = this.reset;
        return data; 
    }
}

interface IRate {
    limit?: number;
    remaining?: number;
    reset?: number;
}

class _links6 implements I_links6 {
    git?: string;
    html?: string;
    self?: string;

    constructor(data?: I_links6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.git = data["git"];
            this.html = data["html"];
            this.self = data["self"];
        }
    }

    static fromJS(data: any): _links6 {
        let result = new _links6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["git"] = this.git;
        data["html"] = this.html;
        data["self"] = this.self;
        return data; 
    }
}

interface I_links6 {
    git?: string;
    html?: string;
    self?: string;
}

class object implements Iobject {
    sha?: string;
    type?: string;
    url?: string;

    constructor(data?: Iobject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): object {
        let result = new object();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["sha"] = this.sha;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface Iobject {
    sha?: string;
    type?: string;
    url?: string;
}

class Assets implements IAssets {
    content_type?: string;
    created_at?: string;
    download_count?: number;
    id?: number;
    label?: string;
    name?: string;
    size?: number;
    state?: string;
    updated_at?: string;
    uploader?: uploader2;
    url?: string;

    constructor(data?: IAssets) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content_type = data["content_type"];
            this.created_at = data["created_at"];
            this.download_count = data["download_count"];
            this.id = data["id"];
            this.label = data["label"];
            this.name = data["name"];
            this.size = data["size"];
            this.state = data["state"];
            this.updated_at = data["updated_at"];
            this.uploader = data["uploader"] ? uploader2.fromJS(data["uploader"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Assets {
        let result = new Assets();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["content_type"] = this.content_type;
        data["created_at"] = this.created_at;
        data["download_count"] = this.download_count;
        data["id"] = this.id;
        data["label"] = this.label;
        data["name"] = this.name;
        data["size"] = this.size;
        data["state"] = this.state;
        data["updated_at"] = this.updated_at;
        data["uploader"] = this.uploader ? this.uploader.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

interface IAssets {
    content_type?: string;
    created_at?: string;
    download_count?: number;
    id?: number;
    label?: string;
    name?: string;
    size?: number;
    state?: string;
    updated_at?: string;
    uploader?: uploader2;
    url?: string;
}

class author3 implements Iauthor3 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    site_admin?: boolean;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;

    constructor(data?: Iauthor3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.site_admin = data["site_admin"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): author3 {
        let result = new author3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["site_admin"] = this.site_admin;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface Iauthor3 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    site_admin?: boolean;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;
}

class organization implements Iorganization {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    type?: string;
    url?: string;

    constructor(data?: Iorganization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): organization {
        let result = new organization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface Iorganization {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    type?: string;
    url?: string;
}

class owner implements Iowner {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iowner) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): owner {
        let result = new owner();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iowner {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class Parent implements IParent {
    clone_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    description?: string;
    fork?: boolean;
    forks?: number;
    forks_count?: number;
    full_name?: string;
    git_url?: string;
    homepage?: string;
    html_url?: string;
    id?: number;
    language?: string;
    master_branch?: string;
    mirror_url?: string;
    name?: string;
    open_issues?: number;
    open_issues_count?: number;
    owner?: owner8;
    private?: boolean;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string;
    size?: number;
    ssh_url?: string;
    svn_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    watchers?: number;
    watchers_count?: number;

    constructor(data?: IParent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clone_url = data["clone_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.forks_count = data["forks_count"];
            this.full_name = data["full_name"];
            this.git_url = data["git_url"];
            this.homepage = data["homepage"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.language = data["language"];
            this.master_branch = data["master_branch"];
            this.mirror_url = data["mirror_url"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.open_issues_count = data["open_issues_count"];
            this.owner = data["owner"] ? owner8.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.pushed_at = data["pushed_at"];
            this.size = data["size"];
            this.ssh_url = data["ssh_url"];
            this.svn_url = data["svn_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.watchers = data["watchers"];
            this.watchers_count = data["watchers_count"];
        }
    }

    static fromJS(data: any): Parent {
        let result = new Parent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["clone_url"] = this.clone_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["forks_count"] = this.forks_count;
        data["full_name"] = this.full_name;
        data["git_url"] = this.git_url;
        data["homepage"] = this.homepage;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["language"] = this.language;
        data["master_branch"] = this.master_branch;
        data["mirror_url"] = this.mirror_url;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["open_issues_count"] = this.open_issues_count;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pushed_at"] = this.pushed_at;
        data["size"] = this.size;
        data["ssh_url"] = this.ssh_url;
        data["svn_url"] = this.svn_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["watchers"] = this.watchers;
        data["watchers_count"] = this.watchers_count;
        return data; 
    }
}

interface IParent {
    clone_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    description?: string;
    fork?: boolean;
    forks?: number;
    forks_count?: number;
    full_name?: string;
    git_url?: string;
    homepage?: string;
    html_url?: string;
    id?: number;
    language?: string;
    master_branch?: string;
    mirror_url?: string;
    name?: string;
    open_issues?: number;
    open_issues_count?: number;
    owner?: owner8;
    private?: boolean;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string;
    size?: number;
    ssh_url?: string;
    svn_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    watchers?: number;
    watchers_count?: number;
}

class Source implements ISource {
    clone_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    description?: string;
    fork?: boolean;
    forks?: number;
    forks_count?: number;
    full_name?: string;
    git_url?: string;
    homepage?: string;
    html_url?: string;
    id?: number;
    language?: string;
    master_branch?: string;
    mirror_url?: string;
    name?: string;
    open_issues?: number;
    open_issues_count?: number;
    owner?: owner9;
    private?: boolean;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string;
    size?: number;
    ssh_url?: string;
    svn_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    watchers?: number;
    watchers_count?: number;

    constructor(data?: ISource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clone_url = data["clone_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.forks_count = data["forks_count"];
            this.full_name = data["full_name"];
            this.git_url = data["git_url"];
            this.homepage = data["homepage"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.language = data["language"];
            this.master_branch = data["master_branch"];
            this.mirror_url = data["mirror_url"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.open_issues_count = data["open_issues_count"];
            this.owner = data["owner"] ? owner9.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.pushed_at = data["pushed_at"];
            this.size = data["size"];
            this.ssh_url = data["ssh_url"];
            this.svn_url = data["svn_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.watchers = data["watchers"];
            this.watchers_count = data["watchers_count"];
        }
    }

    static fromJS(data: any): Source {
        let result = new Source();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["clone_url"] = this.clone_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["forks_count"] = this.forks_count;
        data["full_name"] = this.full_name;
        data["git_url"] = this.git_url;
        data["homepage"] = this.homepage;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["language"] = this.language;
        data["master_branch"] = this.master_branch;
        data["mirror_url"] = this.mirror_url;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["open_issues_count"] = this.open_issues_count;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pushed_at"] = this.pushed_at;
        data["size"] = this.size;
        data["ssh_url"] = this.ssh_url;
        data["svn_url"] = this.svn_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["watchers"] = this.watchers;
        data["watchers_count"] = this.watchers_count;
        return data; 
    }
}

interface ISource {
    clone_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    description?: string;
    fork?: boolean;
    forks?: number;
    forks_count?: number;
    full_name?: string;
    git_url?: string;
    homepage?: string;
    html_url?: string;
    id?: number;
    language?: string;
    master_branch?: string;
    mirror_url?: string;
    name?: string;
    open_issues?: number;
    open_issues_count?: number;
    owner?: owner9;
    private?: boolean;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string;
    size?: number;
    ssh_url?: string;
    svn_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    watchers?: number;
    watchers_count?: number;
}

class author4 implements Iauthor4 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string;
    email?: string;
    name?: string;

    constructor(data?: Iauthor4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): author4 {
        let result = new author4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

interface Iauthor4 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string;
    email?: string;
    name?: string;
}

class committer4 implements Icommitter4 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string;
    email?: string;
    name?: string;

    constructor(data?: Icommitter4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): committer4 {
        let result = new committer4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

interface Icommitter4 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string;
    email?: string;
    name?: string;
}

class parents2 implements Iparents2 {
    sha?: string;
    url?: string;

    constructor(data?: Iparents2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): parents2 {
        let result = new parents2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

interface Iparents2 {
    sha?: string;
    url?: string;
}

class tree implements Itree {
    sha?: string;
    url?: string;

    constructor(data?: Itree) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): tree {
        let result = new tree();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

interface Itree {
    sha?: string;
    url?: string;
}

class author5 implements Iauthor5 {
    date?: string;
    email?: string;
    name?: string;

    constructor(data?: Iauthor5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): author5 {
        let result = new author5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

interface Iauthor5 {
    date?: string;
    email?: string;
    name?: string;
}

class Items implements IItems {
    git_url?: string;
    html_url?: string;
    name?: string;
    path?: string;
    repository?: repository;
    score?: number;
    sha?: string;
    url?: string;

    constructor(data?: IItems) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.git_url = data["git_url"];
            this.html_url = data["html_url"];
            this.name = data["name"];
            this.path = data["path"];
            this.repository = data["repository"] ? repository.fromJS(data["repository"]) : <any>undefined;
            this.score = data["score"];
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Items {
        let result = new Items();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["git_url"] = this.git_url;
        data["html_url"] = this.html_url;
        data["name"] = this.name;
        data["path"] = this.path;
        data["repository"] = this.repository ? this.repository.toJSON() : <any>undefined;
        data["score"] = this.score;
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

interface IItems {
    git_url?: string;
    html_url?: string;
    name?: string;
    path?: string;
    repository?: repository;
    score?: number;
    sha?: string;
    url?: string;
}

class items implements Iitems {
    assignee?: assignee2;
    body?: string;
    closed_at?: Closed_at;
    comments?: number;
    comments_url?: string;
    created_at?: string;
    events_url?: string;
    html_url?: string;
    id?: number;
    labels?: labels2[];
    labels_url?: string;
    milestone?: milestone3;
    number?: number;
    pull_request?: pull_request3;
    score?: number;
    state?: string;
    title?: string;
    updated_at?: string;
    url?: string;
    user?: user19;

    constructor(data?: Iitems) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assignee = data["assignee"];
            this.body = data["body"];
            this.closed_at = data["closed_at"];
            this.comments = data["comments"];
            this.comments_url = data["comments_url"];
            this.created_at = data["created_at"];
            this.events_url = data["events_url"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            if (data["labels"] && data["labels"].constructor === Array) {
                this.labels = [];
                for (let item of data["labels"])
                    this.labels.push(labels2.fromJS(item));
            }
            this.labels_url = data["labels_url"];
            this.milestone = data["milestone"];
            this.number = data["number"];
            this.pull_request = data["pull_request"] ? pull_request3.fromJS(data["pull_request"]) : <any>undefined;
            this.score = data["score"];
            this.state = data["state"];
            this.title = data["title"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.user = data["user"] ? user19.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): items {
        let result = new items();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["assignee"] = this.assignee;
        data["body"] = this.body;
        data["closed_at"] = this.closed_at;
        data["comments"] = this.comments;
        data["comments_url"] = this.comments_url;
        data["created_at"] = this.created_at;
        data["events_url"] = this.events_url;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        if (this.labels && this.labels.constructor === Array) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item.toJSON());
        }
        data["labels_url"] = this.labels_url;
        data["milestone"] = this.milestone;
        data["number"] = this.number;
        data["pull_request"] = this.pull_request ? this.pull_request.toJSON() : <any>undefined;
        data["score"] = this.score;
        data["state"] = this.state;
        data["title"] = this.title;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

interface Iitems {
    assignee?: assignee2;
    body?: string;
    closed_at?: Closed_at;
    comments?: number;
    comments_url?: string;
    created_at?: string;
    events_url?: string;
    html_url?: string;
    id?: number;
    labels?: labels2[];
    labels_url?: string;
    milestone?: milestone3;
    number?: number;
    pull_request?: pull_request3;
    score?: number;
    state?: string;
    title?: string;
    updated_at?: string;
    url?: string;
    user?: user19;
}

class Issues implements IIssues {
    body?: string;
    comments?: number;
    created_at?: string;
    gravatar_id?: string;
    html_url?: string;
    labels?: string[];
    number?: number;
    position?: number;
    state?: string;
    title?: string;
    updated_at?: string;
    user?: string;
    votes?: number;

    constructor(data?: IIssues) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.body = data["body"];
            this.comments = data["comments"];
            this.created_at = data["created_at"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            if (data["labels"] && data["labels"].constructor === Array) {
                this.labels = [];
                for (let item of data["labels"])
                    this.labels.push(item);
            }
            this.number = data["number"];
            this.position = data["position"];
            this.state = data["state"];
            this.title = data["title"];
            this.updated_at = data["updated_at"];
            this.user = data["user"];
            this.votes = data["votes"];
        }
    }

    static fromJS(data: any): Issues {
        let result = new Issues();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["body"] = this.body;
        data["comments"] = this.comments;
        data["created_at"] = this.created_at;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        if (this.labels && this.labels.constructor === Array) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item);
        }
        data["number"] = this.number;
        data["position"] = this.position;
        data["state"] = this.state;
        data["title"] = this.title;
        data["updated_at"] = this.updated_at;
        data["user"] = this.user;
        data["votes"] = this.votes;
        return data; 
    }
}

interface IIssues {
    body?: string;
    comments?: number;
    created_at?: string;
    gravatar_id?: string;
    html_url?: string;
    labels?: string[];
    number?: number;
    position?: number;
    state?: string;
    title?: string;
    updated_at?: string;
    user?: string;
    votes?: number;
}

class items2 implements Iitems2 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    default_branch?: string;
    description?: string;
    fork?: boolean;
    forks?: number;
    forks_count?: number;
    full_name?: string;
    homepage?: string;
    html_url?: string;
    id?: number;
    language?: string;
    master_branch?: string;
    name?: string;
    open_issues?: number;
    open_issues_count?: number;
    owner?: owner10;
    private?: boolean;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string;
    score?: number;
    size?: number;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    watchers?: number;
    watchers_count?: number;

    constructor(data?: Iitems2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.created_at = data["created_at"];
            this.default_branch = data["default_branch"];
            this.description = data["description"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.forks_count = data["forks_count"];
            this.full_name = data["full_name"];
            this.homepage = data["homepage"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.language = data["language"];
            this.master_branch = data["master_branch"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.open_issues_count = data["open_issues_count"];
            this.owner = data["owner"] ? owner10.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.pushed_at = data["pushed_at"];
            this.score = data["score"];
            this.size = data["size"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.watchers = data["watchers"];
            this.watchers_count = data["watchers_count"];
        }
    }

    static fromJS(data: any): items2 {
        let result = new items2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["created_at"] = this.created_at;
        data["default_branch"] = this.default_branch;
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["forks_count"] = this.forks_count;
        data["full_name"] = this.full_name;
        data["homepage"] = this.homepage;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["language"] = this.language;
        data["master_branch"] = this.master_branch;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["open_issues_count"] = this.open_issues_count;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pushed_at"] = this.pushed_at;
        data["score"] = this.score;
        data["size"] = this.size;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["watchers"] = this.watchers;
        data["watchers_count"] = this.watchers_count;
        return data; 
    }
}

interface Iitems2 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    default_branch?: string;
    description?: string;
    fork?: boolean;
    forks?: number;
    forks_count?: number;
    full_name?: string;
    homepage?: string;
    html_url?: string;
    id?: number;
    language?: string;
    master_branch?: string;
    name?: string;
    open_issues?: number;
    open_issues_count?: number;
    owner?: owner10;
    private?: boolean;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string;
    score?: number;
    size?: number;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    watchers?: number;
    watchers_count?: number;
}

class Repositories implements IRepositories {
    created?: string;
    created_at?: string;
    description?: string;
    followers?: number;
    fork?: boolean;
    forks?: number;
    has_downloads?: boolean;
    has_issues?: boolean;
    has_wiki?: boolean;
    homepage?: string;
    language?: string;
    name?: string;
    open_issues?: number;
    owner?: string;
    private?: boolean;
    pushed?: string;
    pushed_at?: string;
    score?: number;
    size?: number;
    type?: string;
    url?: string;
    username?: string;
    watchers?: number;

    constructor(data?: IRepositories) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.created = data["created"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.followers = data["followers"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.has_downloads = data["has_downloads"];
            this.has_issues = data["has_issues"];
            this.has_wiki = data["has_wiki"];
            this.homepage = data["homepage"];
            this.language = data["language"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.owner = data["owner"];
            this.private = data["private"];
            this.pushed = data["pushed"];
            this.pushed_at = data["pushed_at"];
            this.score = data["score"];
            this.size = data["size"];
            this.type = data["type"];
            this.url = data["url"];
            this.username = data["username"];
            this.watchers = data["watchers"];
        }
    }

    static fromJS(data: any): Repositories {
        let result = new Repositories();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["created"] = this.created;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["followers"] = this.followers;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["has_downloads"] = this.has_downloads;
        data["has_issues"] = this.has_issues;
        data["has_wiki"] = this.has_wiki;
        data["homepage"] = this.homepage;
        data["language"] = this.language;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["owner"] = this.owner;
        data["private"] = this.private;
        data["pushed"] = this.pushed;
        data["pushed_at"] = this.pushed_at;
        data["score"] = this.score;
        data["size"] = this.size;
        data["type"] = this.type;
        data["url"] = this.url;
        data["username"] = this.username;
        data["watchers"] = this.watchers;
        return data; 
    }
}

interface IRepositories {
    created?: string;
    created_at?: string;
    description?: string;
    followers?: number;
    fork?: boolean;
    forks?: number;
    has_downloads?: boolean;
    has_issues?: boolean;
    has_wiki?: boolean;
    homepage?: string;
    language?: string;
    name?: string;
    open_issues?: number;
    owner?: string;
    private?: boolean;
    pushed?: string;
    pushed_at?: string;
    score?: number;
    size?: number;
    type?: string;
    url?: string;
    username?: string;
    watchers?: number;
}

class user6 implements Iuser6 {
    blog?: string;
    company?: string;
    created?: string;
    created_at?: string;
    email?: string;
    followers_count?: number;
    following_count?: number;
    gravatar_id?: string;
    id?: number;
    location?: string;
    login?: string;
    name?: string;
    public_gist_count?: number;
    public_repo_count?: number;
    type?: string;

    constructor(data?: Iuser6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.blog = data["blog"];
            this.company = data["company"];
            this.created = data["created"];
            this.created_at = data["created_at"];
            this.email = data["email"];
            this.followers_count = data["followers_count"];
            this.following_count = data["following_count"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.location = data["location"];
            this.login = data["login"];
            this.name = data["name"];
            this.public_gist_count = data["public_gist_count"];
            this.public_repo_count = data["public_repo_count"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): user6 {
        let result = new user6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["blog"] = this.blog;
        data["company"] = this.company;
        data["created"] = this.created;
        data["created_at"] = this.created_at;
        data["email"] = this.email;
        data["followers_count"] = this.followers_count;
        data["following_count"] = this.following_count;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["location"] = this.location;
        data["login"] = this.login;
        data["name"] = this.name;
        data["public_gist_count"] = this.public_gist_count;
        data["public_repo_count"] = this.public_repo_count;
        data["type"] = this.type;
        return data; 
    }
}

interface Iuser6 {
    blog?: string;
    company?: string;
    created?: string;
    created_at?: string;
    email?: string;
    followers_count?: number;
    following_count?: number;
    gravatar_id?: string;
    id?: number;
    location?: string;
    login?: string;
    name?: string;
    public_gist_count?: number;
    public_repo_count?: number;
    type?: string;
}

class items3 implements Iitems3 {
    avatar_url?: string;
    followers_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    score?: number;
    subscriptions_url?: string;
    type?: string;
    url?: string;

    constructor(data?: Iitems3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.followers_url = data["followers_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.score = data["score"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): items3 {
        let result = new items3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["followers_url"] = this.followers_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["score"] = this.score;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface Iitems3 {
    avatar_url?: string;
    followers_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    score?: number;
    subscriptions_url?: string;
    type?: string;
    url?: string;
}

class Users implements IUsers {
    created?: string;
    created_at?: string;
    followers?: number;
    followers_count?: number;
    fullname?: string;
    gravatar_id?: string;
    id?: string;
    language?: string;
    location?: string;
    login?: string;
    name?: string;
    public_repo_count?: number;
    repos?: number;
    score?: number;
    type?: string;
    username?: string;

    constructor(data?: IUsers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.created = data["created"];
            this.created_at = data["created_at"];
            this.followers = data["followers"];
            this.followers_count = data["followers_count"];
            this.fullname = data["fullname"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.language = data["language"];
            this.location = data["location"];
            this.login = data["login"];
            this.name = data["name"];
            this.public_repo_count = data["public_repo_count"];
            this.repos = data["repos"];
            this.score = data["score"];
            this.type = data["type"];
            this.username = data["username"];
        }
    }

    static fromJS(data: any): Users {
        let result = new Users();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["created"] = this.created;
        data["created_at"] = this.created_at;
        data["followers"] = this.followers;
        data["followers_count"] = this.followers_count;
        data["fullname"] = this.fullname;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["language"] = this.language;
        data["location"] = this.location;
        data["login"] = this.login;
        data["name"] = this.name;
        data["public_repo_count"] = this.public_repo_count;
        data["repos"] = this.repos;
        data["score"] = this.score;
        data["type"] = this.type;
        data["username"] = this.username;
        return data; 
    }
}

interface IUsers {
    created?: string;
    created_at?: string;
    followers?: number;
    followers_count?: number;
    fullname?: string;
    gravatar_id?: string;
    id?: string;
    language?: string;
    location?: string;
    login?: string;
    name?: string;
    public_repo_count?: number;
    repos?: number;
    score?: number;
    type?: string;
    username?: string;
}

class object2 implements Iobject2 {
    sha?: string;
    type?: string;
    url?: string;

    constructor(data?: Iobject2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): object2 {
        let result = new object2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["sha"] = this.sha;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface Iobject2 {
    sha?: string;
    type?: string;
    url?: string;
}

class Tagger implements ITagger {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string;
    email?: string;
    name?: string;

    constructor(data?: ITagger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Tagger {
        let result = new Tagger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

interface ITagger {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string;
    email?: string;
    name?: string;
}

class tagger implements Itagger {
    /** Timestamp of when this object was tagged. */
    date?: string;
    /** String of the email of the author of the tag. */
    email?: string;
    /** String of the name of the author of the tag. */
    name?: string;

    constructor(data?: Itagger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): tagger {
        let result = new tagger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

interface Itagger {
    /** Timestamp of when this object was tagged. */
    date?: string;
    /** String of the email of the author of the tag. */
    email?: string;
    /** String of the name of the author of the tag. */
    name?: string;
}

class tree2 implements Itree2 {
    mode?: string;
    path?: string;
    sha?: string;
    size?: number;
    type?: string;
    url?: string;

    constructor(data?: Itree2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.mode = data["mode"];
            this.path = data["path"];
            this.sha = data["sha"];
            this.size = data["size"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): tree2 {
        let result = new tree2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["mode"] = this.mode;
        data["path"] = this.path;
        data["sha"] = this.sha;
        data["size"] = this.size;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface Itree2 {
    mode?: string;
    path?: string;
    sha?: string;
    size?: number;
    type?: string;
    url?: string;
}

class tree3 implements Itree3 {
    /** One of 100644 for file (blob), 100755 for executable (blob), 040000 for subdirectory (tree), 160000 for submodule (commit) or 120000 for a blob that specifies the path of a symlink. */
    mode?: Tree3Mode;
    path?: string;
    /** SHA1 checksum ID of the object in the tree. */
    sha?: string;
    type?: Tree3Type;
    url?: string;

    constructor(data?: Itree3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.mode = data["mode"];
            this.path = data["path"];
            this.sha = data["sha"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): tree3 {
        let result = new tree3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["mode"] = this.mode;
        data["path"] = this.path;
        data["sha"] = this.sha;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface Itree3 {
    /** One of 100644 for file (blob), 100755 for executable (blob), 040000 for subdirectory (tree), 160000 for submodule (commit) or 120000 for a blob that specifies the path of a symlink. */
    mode?: Tree3Mode;
    path?: string;
    /** SHA1 checksum ID of the object in the tree. */
    sha?: string;
    type?: Tree3Type;
    url?: string;
}

class Plan implements IPlan {
    collaborators?: number;
    name?: string;
    private_repos?: number;
    space?: number;

    constructor(data?: IPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.collaborators = data["collaborators"];
            this.name = data["name"];
            this.private_repos = data["private_repos"];
            this.space = data["space"];
        }
    }

    static fromJS(data: any): Plan {
        let result = new Plan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["collaborators"] = this.collaborators;
        data["name"] = this.name;
        data["private_repos"] = this.private_repos;
        data["space"] = this.space;
        return data; 
    }
}

interface IPlan {
    collaborators?: number;
    name?: string;
    private_repos?: number;
    space?: number;
}

class files5 implements Ifiles5 {
    ringErl?: ringErl;

    constructor(data?: Ifiles5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ringErl = data["ring.erl"] ? ringErl.fromJS(data["ring.erl"]) : <any>undefined;
        }
    }

    static fromJS(data: any): files5 {
        let result = new files5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["ring.erl"] = this.ringErl ? this.ringErl.toJSON() : <any>undefined;
        return data; 
    }
}

interface Ifiles5 {
    ringErl?: ringErl;
}

class user7 implements Iuser7 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iuser7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): user7 {
        let result = new user7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iuser7 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class user8 implements Iuser8 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iuser8) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): user8 {
        let result = new user8();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iuser8 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class Assignee implements IAssignee {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: IAssignee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Assignee {
        let result = new Assignee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface IAssignee {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class Labels implements ILabels {
    color?: string;
    name?: string;
    url?: string;

    constructor(data?: ILabels) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.color = data["color"];
            this.name = data["name"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Labels {
        let result = new Labels();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["color"] = this.color;
        data["name"] = this.name;
        data["url"] = this.url;
        return data; 
    }
}

interface ILabels {
    color?: string;
    name?: string;
    url?: string;
}

class milestone implements Imilestone {
    closed_issues?: number;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    creator?: creator5;
    description?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    due_on?: string;
    number?: number;
    open_issues?: number;
    state?: milestoneState;
    title?: string;
    url?: string;

    constructor(data?: Imilestone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.closed_issues = data["closed_issues"];
            this.created_at = data["created_at"];
            this.creator = data["creator"] ? creator5.fromJS(data["creator"]) : <any>undefined;
            this.description = data["description"];
            this.due_on = data["due_on"];
            this.number = data["number"];
            this.open_issues = data["open_issues"];
            this.state = data["state"];
            this.title = data["title"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): milestone {
        let result = new milestone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["closed_issues"] = this.closed_issues;
        data["created_at"] = this.created_at;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["due_on"] = this.due_on;
        data["number"] = this.number;
        data["open_issues"] = this.open_issues;
        data["state"] = this.state;
        data["title"] = this.title;
        data["url"] = this.url;
        return data; 
    }
}

interface Imilestone {
    closed_issues?: number;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    creator?: creator5;
    description?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    due_on?: string;
    number?: number;
    open_issues?: number;
    state?: milestoneState;
    title?: string;
    url?: string;
}

class Pull_request implements IPull_request {
    diff_url?: string;
    html_url?: string;
    patch_url?: string;

    constructor(data?: IPull_request) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.diff_url = data["diff_url"];
            this.html_url = data["html_url"];
            this.patch_url = data["patch_url"];
        }
    }

    static fromJS(data: any): Pull_request {
        let result = new Pull_request();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["diff_url"] = this.diff_url;
        data["html_url"] = this.html_url;
        data["patch_url"] = this.patch_url;
        return data; 
    }
}

interface IPull_request {
    diff_url?: string;
    html_url?: string;
    patch_url?: string;
}

enum state {
    Open = <any>"open", 
    Closed = <any>"closed", 
}

class user9 implements Iuser9 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iuser9) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): user9 {
        let result = new user9();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iuser9 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class owner2 implements Iowner2 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iowner2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): owner2 {
        let result = new owner2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iowner2 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class commit6 implements Icommit6 {
    sha?: string;
    url?: string;

    constructor(data?: Icommit6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): commit6 {
        let result = new commit6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

interface Icommit6 {
    sha?: string;
    url?: string;
}

class user10 implements Iuser10 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iuser10) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): user10 {
        let result = new user10();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iuser10 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class author6 implements Iauthor6 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iauthor6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): author6 {
        let result = new author6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iauthor6 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class commit7 implements Icommit7 {
    author?: author16;
    committer?: committer13;
    message?: string;
    tree?: tree8;
    url?: string;

    constructor(data?: Icommit7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? author16.fromJS(data["author"]) : <any>undefined;
            this.committer = data["committer"] ? committer13.fromJS(data["committer"]) : <any>undefined;
            this.message = data["message"];
            this.tree = data["tree"] ? tree8.fromJS(data["tree"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): commit7 {
        let result = new commit7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["tree"] = this.tree ? this.tree.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

interface Icommit7 {
    author?: author16;
    committer?: committer13;
    message?: string;
    tree?: tree8;
    url?: string;
}

class committer5 implements Icommitter5 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Icommitter5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): committer5 {
        let result = new committer5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Icommitter5 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class parents3 implements Iparents3 {
    sha?: string;
    url?: string;

    constructor(data?: Iparents3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): parents3 {
        let result = new parents3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

interface Iparents3 {
    sha?: string;
    url?: string;
}

class Statuses implements IStatuses {
    context?: string;
    created_at?: string;
    description?: string;
    id?: number;
    state?: string;
    target_url?: string;
    updated_at?: string;
    url?: string;

    constructor(data?: IStatuses) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.context = data["context"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.id = data["id"];
            this.state = data["state"];
            this.target_url = data["target_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Statuses {
        let result = new Statuses();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["context"] = this.context;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["id"] = this.id;
        data["state"] = this.state;
        data["target_url"] = this.target_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        return data; 
    }
}

interface IStatuses {
    context?: string;
    created_at?: string;
    description?: string;
    id?: number;
    state?: string;
    target_url?: string;
    updated_at?: string;
    url?: string;
}

class creator2 implements Icreator2 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    site_admin?: boolean;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;

    constructor(data?: Icreator2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.site_admin = data["site_admin"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): creator2 {
        let result = new creator2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["site_admin"] = this.site_admin;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface Icreator2 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    site_admin?: boolean;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;
}

class creator3 implements Icreator3 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    site_admin?: boolean;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;

    constructor(data?: Icreator3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.site_admin = data["site_admin"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): creator3 {
        let result = new creator3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["site_admin"] = this.site_admin;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface Icreator3 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    site_admin?: boolean;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;
}

class owner3 implements Iowner3 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iowner3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): owner3 {
        let result = new owner3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iowner3 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class object3 implements Iobject3 {
    sha?: string;
    type?: string;
    url?: string;

    constructor(data?: Iobject3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): object3 {
        let result = new object3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["sha"] = this.sha;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface Iobject3 {
    sha?: string;
    type?: string;
    url?: string;
}

class Config implements IConfig {
    content_type?: string;
    url?: string;

    constructor(data?: IConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content_type = data["content_type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Config {
        let result = new Config();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["content_type"] = this.content_type;
        data["url"] = this.url;
        return data; 
    }
}

interface IConfig {
    content_type?: string;
    url?: string;
}

enum events {
    Push = <any>"push", 
    Issues = <any>"issues", 
    Issue_comment = <any>"issue_comment", 
    Commit_comment = <any>"commit_comment", 
    Pull_request = <any>"pull_request", 
    Pull_request_review_comment = <any>"pull_request_review_comment", 
    Gollum = <any>"gollum", 
    Watch = <any>"watch", 
    Download = <any>"download", 
    Fork = <any>"fork", 
    Fork_apply = <any>"fork_apply", 
    Member = <any>"member", 
    Public = <any>"public", 
    Team_add = <any>"team_add", 
    Status = <any>"status", 
}

class _links7 implements I_links7 {
    html?: html2;
    pull_request?: pull_request4;
    self?: self2;

    constructor(data?: I_links7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.html = data["html"] ? html2.fromJS(data["html"]) : <any>undefined;
            this.pull_request = data["pull_request"] ? pull_request4.fromJS(data["pull_request"]) : <any>undefined;
            this.self = data["self"] ? self2.fromJS(data["self"]) : <any>undefined;
        }
    }

    static fromJS(data: any): _links7 {
        let result = new _links7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["html"] = this.html ? this.html.toJSON() : <any>undefined;
        data["pull_request"] = this.pull_request ? this.pull_request.toJSON() : <any>undefined;
        data["self"] = this.self ? this.self.toJSON() : <any>undefined;
        return data; 
    }
}

interface I_links7 {
    html?: html2;
    pull_request?: pull_request4;
    self?: self2;
}

class user11 implements Iuser11 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iuser11) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): user11 {
        let result = new user11();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iuser11 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class _links8 implements I_links8 {
    comments?: comments;
    html?: html3;
    review_comments?: review_comments;
    self?: self3;

    constructor(data?: I_links8) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.comments = data["comments"] ? comments.fromJS(data["comments"]) : <any>undefined;
            this.html = data["html"] ? html3.fromJS(data["html"]) : <any>undefined;
            this.review_comments = data["review_comments"] ? review_comments.fromJS(data["review_comments"]) : <any>undefined;
            this.self = data["self"] ? self3.fromJS(data["self"]) : <any>undefined;
        }
    }

    static fromJS(data: any): _links8 {
        let result = new _links8();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["comments"] = this.comments ? this.comments.toJSON() : <any>undefined;
        data["html"] = this.html ? this.html.toJSON() : <any>undefined;
        data["review_comments"] = this.review_comments ? this.review_comments.toJSON() : <any>undefined;
        data["self"] = this.self ? this.self.toJSON() : <any>undefined;
        return data; 
    }
}

interface I_links8 {
    comments?: comments;
    html?: html3;
    review_comments?: review_comments;
    self?: self3;
}

class base implements Ibase {
    label?: string;
    ref?: string;
    repo?: repo4;
    sha?: string;
    user?: user20;

    constructor(data?: Ibase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.ref = data["ref"];
            this.repo = data["repo"] ? repo4.fromJS(data["repo"]) : <any>undefined;
            this.sha = data["sha"];
            this.user = data["user"] ? user20.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): base {
        let result = new base();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["label"] = this.label;
        data["ref"] = this.ref;
        data["repo"] = this.repo ? this.repo.toJSON() : <any>undefined;
        data["sha"] = this.sha;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

interface Ibase {
    label?: string;
    ref?: string;
    repo?: repo4;
    sha?: string;
    user?: user20;
}

class head implements Ihead {
    label?: string;
    ref?: string;
    repo?: repo5;
    sha?: string;
    user?: user21;

    constructor(data?: Ihead) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.ref = data["ref"];
            this.repo = data["repo"] ? repo5.fromJS(data["repo"]) : <any>undefined;
            this.sha = data["sha"];
            this.user = data["user"] ? user21.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): head {
        let result = new head();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["label"] = this.label;
        data["ref"] = this.ref;
        data["repo"] = this.repo ? this.repo.toJSON() : <any>undefined;
        data["sha"] = this.sha;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

interface Ihead {
    label?: string;
    ref?: string;
    repo?: repo5;
    sha?: string;
    user?: user21;
}

enum state2 {
    Open = <any>"open", 
    Closed = <any>"closed", 
}

class user12 implements Iuser12 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iuser12) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): user12 {
        let result = new user12();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iuser12 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class assets implements Iassets {
    content_type?: string;
    created_at?: string;
    download_count?: number;
    id?: number;
    label?: string;
    name?: string;
    size?: number;
    state?: string;
    updated_at?: string;
    uploader?: uploader3;
    url?: string;

    constructor(data?: Iassets) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content_type = data["content_type"];
            this.created_at = data["created_at"];
            this.download_count = data["download_count"];
            this.id = data["id"];
            this.label = data["label"];
            this.name = data["name"];
            this.size = data["size"];
            this.state = data["state"];
            this.updated_at = data["updated_at"];
            this.uploader = data["uploader"] ? uploader3.fromJS(data["uploader"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): assets {
        let result = new assets();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["content_type"] = this.content_type;
        data["created_at"] = this.created_at;
        data["download_count"] = this.download_count;
        data["id"] = this.id;
        data["label"] = this.label;
        data["name"] = this.name;
        data["size"] = this.size;
        data["state"] = this.state;
        data["updated_at"] = this.updated_at;
        data["uploader"] = this.uploader ? this.uploader.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

interface Iassets {
    content_type?: string;
    created_at?: string;
    download_count?: number;
    id?: number;
    label?: string;
    name?: string;
    size?: number;
    state?: string;
    updated_at?: string;
    uploader?: uploader3;
    url?: string;
}

class author7 implements Iauthor7 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    site_admin?: boolean;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;

    constructor(data?: Iauthor7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.site_admin = data["site_admin"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): author7 {
        let result = new author7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["site_admin"] = this.site_admin;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface Iauthor7 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    site_admin?: boolean;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;
}

class uploader implements Iuploader {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    site_admin?: boolean;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;

    constructor(data?: Iuploader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.site_admin = data["site_admin"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): uploader {
        let result = new uploader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["site_admin"] = this.site_admin;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface Iuploader {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    site_admin?: boolean;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;
}

class author8 implements Iauthor8 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iauthor8) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): author8 {
        let result = new author8();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iauthor8 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class Weeks implements IWeeks {
    /** Number of additions. */
    a?: number;
    /** Number of commits. */
    c?: number;
    /** Number of deletions. */
    d?: number;
    /** Start of the week. */
    w?: string;

    constructor(data?: IWeeks) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.a = data["a"];
            this.c = data["c"];
            this.d = data["d"];
            this.w = data["w"];
        }
    }

    static fromJS(data: any): Weeks {
        let result = new Weeks();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["a"] = this.a;
        data["c"] = this.c;
        data["d"] = this.d;
        data["w"] = this.w;
        return data; 
    }
}

interface IWeeks {
    /** Number of additions. */
    a?: number;
    /** Number of commits. */
    c?: number;
    /** Number of deletions. */
    d?: number;
    /** Start of the week. */
    w?: string;
}

class creator4 implements Icreator4 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Icreator4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): creator4 {
        let result = new creator4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Icreator4 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class owner4 implements Iowner4 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iowner4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): owner4 {
        let result = new owner4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iowner4 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class Language implements ILanguage {

    constructor(data?: ILanguage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): Language {
        let result = new Language();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        return data; 
    }
}

interface ILanguage {
}

class owner5 implements Iowner5 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iowner5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): owner5 {
        let result = new owner5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iowner5 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class owner6 implements Iowner6 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iowner6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): owner6 {
        let result = new owner6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iowner6 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class organization2 implements Iorganization2 {
    avatar_url?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iorganization2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): organization2 {
        let result = new organization2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iorganization2 {
    avatar_url?: string;
    id?: number;
    login?: string;
    url?: string;
}

class author9 implements Iauthor9 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iauthor9) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): author9 {
        let result = new author9();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iauthor9 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class commit8 implements Icommit8 {
    author?: author17;
    committer?: committer14;
    message?: string;
    tree?: tree9;
    url?: string;

    constructor(data?: Icommit8) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? author17.fromJS(data["author"]) : <any>undefined;
            this.committer = data["committer"] ? committer14.fromJS(data["committer"]) : <any>undefined;
            this.message = data["message"];
            this.tree = data["tree"] ? tree9.fromJS(data["tree"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): commit8 {
        let result = new commit8();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["tree"] = this.tree ? this.tree.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

interface Icommit8 {
    author?: author17;
    committer?: committer14;
    message?: string;
    tree?: tree9;
    url?: string;
}

class committer6 implements Icommitter6 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Icommitter6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): committer6 {
        let result = new committer6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Icommitter6 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class parents4 implements Iparents4 {
    sha?: string;
    url?: string;

    constructor(data?: Iparents4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): parents4 {
        let result = new parents4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

interface Iparents4 {
    sha?: string;
    url?: string;
}

class author10 implements Iauthor10 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string;
    email?: string;
    name?: string;

    constructor(data?: Iauthor10) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): author10 {
        let result = new author10();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

interface Iauthor10 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string;
    email?: string;
    name?: string;
}

class committer7 implements Icommitter7 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string;
    email?: string;
    name?: string;

    constructor(data?: Icommitter7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): committer7 {
        let result = new committer7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

interface Icommitter7 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string;
    email?: string;
    name?: string;
}

class tree4 implements Itree4 {
    sha?: string;
    url?: string;

    constructor(data?: Itree4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): tree4 {
        let result = new tree4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

interface Itree4 {
    sha?: string;
    url?: string;
}

class author11 implements Iauthor11 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    site_admin?: boolean;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;

    constructor(data?: Iauthor11) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.site_admin = data["site_admin"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): author11 {
        let result = new author11();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["site_admin"] = this.site_admin;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface Iauthor11 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    site_admin?: boolean;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;
}

class commit9 implements Icommit9 {
    author?: author18;
    committer?: committer15;
    message?: string;
    tree?: tree10;
    url?: string;

    constructor(data?: Icommit9) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? author18.fromJS(data["author"]) : <any>undefined;
            this.committer = data["committer"] ? committer15.fromJS(data["committer"]) : <any>undefined;
            this.message = data["message"];
            this.tree = data["tree"] ? tree10.fromJS(data["tree"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): commit9 {
        let result = new commit9();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["tree"] = this.tree ? this.tree.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

interface Icommit9 {
    author?: author18;
    committer?: committer15;
    message?: string;
    tree?: tree10;
    url?: string;
}

class committer8 implements Icommitter8 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    site_admin?: boolean;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;

    constructor(data?: Icommitter8) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.site_admin = data["site_admin"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): committer8 {
        let result = new committer8();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["site_admin"] = this.site_admin;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface Icommitter8 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    site_admin?: boolean;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;
}

class parents5 implements Iparents5 {
    sha?: string;
    url?: string;

    constructor(data?: Iparents5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): parents5 {
        let result = new parents5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

interface Iparents5 {
    sha?: string;
    url?: string;
}

class author12 implements Iauthor12 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    site_admin?: boolean;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;

    constructor(data?: Iauthor12) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.site_admin = data["site_admin"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): author12 {
        let result = new author12();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["site_admin"] = this.site_admin;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface Iauthor12 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    site_admin?: boolean;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;
}

class commit10 implements Icommit10 {
    author?: author19;
    committer?: committer16;
    message?: string;
    tree?: tree11;
    url?: string;

    constructor(data?: Icommit10) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? author19.fromJS(data["author"]) : <any>undefined;
            this.committer = data["committer"] ? committer16.fromJS(data["committer"]) : <any>undefined;
            this.message = data["message"];
            this.tree = data["tree"] ? tree11.fromJS(data["tree"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): commit10 {
        let result = new commit10();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["tree"] = this.tree ? this.tree.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

interface Icommit10 {
    author?: author19;
    committer?: committer16;
    message?: string;
    tree?: tree11;
    url?: string;
}

class committer9 implements Icommitter9 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    site_admin?: boolean;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;

    constructor(data?: Icommitter9) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.site_admin = data["site_admin"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): committer9 {
        let result = new committer9();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["site_admin"] = this.site_admin;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface Icommitter9 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    site_admin?: boolean;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;
}

class parents6 implements Iparents6 {
    sha?: string;
    url?: string;

    constructor(data?: Iparents6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): parents6 {
        let result = new parents6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

interface Iparents6 {
    sha?: string;
    url?: string;
}

class author13 implements Iauthor13 {
    date?: string;
    email?: string;
    name?: string;

    constructor(data?: Iauthor13) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): author13 {
        let result = new author13();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

interface Iauthor13 {
    date?: string;
    email?: string;
    name?: string;
}

class committer10 implements Icommitter10 {
    date?: string;
    email?: string;
    name?: string;

    constructor(data?: Icommitter10) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): committer10 {
        let result = new committer10();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

interface Icommitter10 {
    date?: string;
    email?: string;
    name?: string;
}

class parents7 implements Iparents7 {
    html_url?: string;
    sha?: string;
    url?: string;

    constructor(data?: Iparents7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.html_url = data["html_url"];
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): parents7 {
        let result = new parents7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["html_url"] = this.html_url;
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

interface Iparents7 {
    html_url?: string;
    sha?: string;
    url?: string;
}

class tree5 implements Itree5 {
    sha?: string;
    url?: string;

    constructor(data?: Itree5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): tree5 {
        let result = new tree5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

interface Itree5 {
    sha?: string;
    url?: string;
}

class _links9 implements I_links9 {
    git?: string;
    html?: string;
    self?: string;

    constructor(data?: I_links9) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.git = data["git"];
            this.html = data["html"];
            this.self = data["self"];
        }
    }

    static fromJS(data: any): _links9 {
        let result = new _links9();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["git"] = this.git;
        data["html"] = this.html;
        data["self"] = this.self;
        return data; 
    }
}

interface I_links9 {
    git?: string;
    html?: string;
    self?: string;
}

class author14 implements Iauthor14 {
    date?: string;
    email?: string;
    name?: string;

    constructor(data?: Iauthor14) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): author14 {
        let result = new author14();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

interface Iauthor14 {
    date?: string;
    email?: string;
    name?: string;
}

class committer11 implements Icommitter11 {
    date?: string;
    email?: string;
    name?: string;

    constructor(data?: Icommitter11) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): committer11 {
        let result = new committer11();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

interface Icommitter11 {
    date?: string;
    email?: string;
    name?: string;
}

class parents8 implements Iparents8 {
    html_url?: string;
    sha?: string;
    url?: string;

    constructor(data?: Iparents8) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.html_url = data["html_url"];
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): parents8 {
        let result = new parents8();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["html_url"] = this.html_url;
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

interface Iparents8 {
    html_url?: string;
    sha?: string;
    url?: string;
}

class tree6 implements Itree6 {
    sha?: string;
    url?: string;

    constructor(data?: Itree6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): tree6 {
        let result = new tree6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

interface Itree6 {
    sha?: string;
    url?: string;
}

class assignee implements Iassignee {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iassignee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): assignee {
        let result = new assignee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iassignee {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class labels implements Ilabels {
    color?: string;
    name?: string;
    url?: string;

    constructor(data?: Ilabels) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.color = data["color"];
            this.name = data["name"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): labels {
        let result = new labels();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["color"] = this.color;
        data["name"] = this.name;
        data["url"] = this.url;
        return data; 
    }
}

interface Ilabels {
    color?: string;
    name?: string;
    url?: string;
}

class milestone2 implements Imilestone2 {
    closed_issues?: number;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    creator?: creator6;
    description?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    due_on?: string;
    number?: number;
    open_issues?: number;
    state?: Milestone2State;
    title?: string;
    url?: string;

    constructor(data?: Imilestone2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.closed_issues = data["closed_issues"];
            this.created_at = data["created_at"];
            this.creator = data["creator"] ? creator6.fromJS(data["creator"]) : <any>undefined;
            this.description = data["description"];
            this.due_on = data["due_on"];
            this.number = data["number"];
            this.open_issues = data["open_issues"];
            this.state = data["state"] ? Milestone2State.fromJS(data["state"]) : <any>undefined;
            this.title = data["title"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): milestone2 {
        let result = new milestone2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["closed_issues"] = this.closed_issues;
        data["created_at"] = this.created_at;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["due_on"] = this.due_on;
        data["number"] = this.number;
        data["open_issues"] = this.open_issues;
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["url"] = this.url;
        return data; 
    }
}

interface Imilestone2 {
    closed_issues?: number;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    creator?: creator6;
    description?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    due_on?: string;
    number?: number;
    open_issues?: number;
    state?: Milestone2State;
    title?: string;
    url?: string;
}

class pull_request implements Ipull_request {
    diff_url?: string;
    html_url?: string;
    patch_url?: string;

    constructor(data?: Ipull_request) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.diff_url = data["diff_url"];
            this.html_url = data["html_url"];
            this.patch_url = data["patch_url"];
        }
    }

    static fromJS(data: any): pull_request {
        let result = new pull_request();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["diff_url"] = this.diff_url;
        data["html_url"] = this.html_url;
        data["patch_url"] = this.patch_url;
        return data; 
    }
}

interface Ipull_request {
    diff_url?: string;
    html_url?: string;
    patch_url?: string;
}

enum IssueState {
    Open = <any>"open", 
    Closed = <any>"closed", 
}

class user13 implements Iuser13 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iuser13) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): user13 {
        let result = new user13();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iuser13 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class Current_user implements ICurrent_user {
    href?: string;
    type?: string;

    constructor(data?: ICurrent_user) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): Current_user {
        let result = new Current_user();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["href"] = this.href;
        data["type"] = this.type;
        return data; 
    }
}

interface ICurrent_user {
    href?: string;
    type?: string;
}

class Current_user_actor implements ICurrent_user_actor {
    href?: string;
    type?: string;

    constructor(data?: ICurrent_user_actor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): Current_user_actor {
        let result = new Current_user_actor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["href"] = this.href;
        data["type"] = this.type;
        return data; 
    }
}

interface ICurrent_user_actor {
    href?: string;
    type?: string;
}

class Current_user_organization implements ICurrent_user_organization {
    href?: string;
    type?: string;

    constructor(data?: ICurrent_user_organization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): Current_user_organization {
        let result = new Current_user_organization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["href"] = this.href;
        data["type"] = this.type;
        return data; 
    }
}

interface ICurrent_user_organization {
    href?: string;
    type?: string;
}

class Current_user_public implements ICurrent_user_public {
    href?: string;
    type?: string;

    constructor(data?: ICurrent_user_public) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): Current_user_public {
        let result = new Current_user_public();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["href"] = this.href;
        data["type"] = this.type;
        return data; 
    }
}

interface ICurrent_user_public {
    href?: string;
    type?: string;
}

class Timeline implements ITimeline {
    href?: string;
    type?: string;

    constructor(data?: ITimeline) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): Timeline {
        let result = new Timeline();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["href"] = this.href;
        data["type"] = this.type;
        return data; 
    }
}

interface ITimeline {
    href?: string;
    type?: string;
}

class user14 implements Iuser14 {
    href?: string;
    type?: string;

    constructor(data?: Iuser14) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): user14 {
        let result = new user14();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["href"] = this.href;
        data["type"] = this.type;
        return data; 
    }
}

interface Iuser14 {
    href?: string;
    type?: string;
}

class RingErl implements IRingErl {
    filename?: string;
    raw_url?: string;
    size?: number;

    constructor(data?: IRingErl) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filename = data["filename"];
            this.raw_url = data["raw_url"];
            this.size = data["size"];
        }
    }

    static fromJS(data: any): RingErl {
        let result = new RingErl();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["filename"] = this.filename;
        data["raw_url"] = this.raw_url;
        data["size"] = this.size;
        return data; 
    }
}

interface IRingErl {
    filename?: string;
    raw_url?: string;
    size?: number;
}

class user15 implements Iuser15 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iuser15) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): user15 {
        let result = new user15();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iuser15 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class Change_status implements IChange_status {
    additions?: number;
    deletions?: number;
    total?: number;

    constructor(data?: IChange_status) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.additions = data["additions"];
            this.deletions = data["deletions"];
            this.total = data["total"];
        }
    }

    static fromJS(data: any): Change_status {
        let result = new Change_status();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["additions"] = this.additions;
        data["deletions"] = this.deletions;
        data["total"] = this.total;
        return data; 
    }
}

interface IChange_status {
    additions?: number;
    deletions?: number;
    total?: number;
}

class user16 implements Iuser16 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iuser16) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): user16 {
        let result = new user16();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iuser16 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class author15 implements Iauthor15 {
    date?: string;
    email?: string;
    name?: string;

    constructor(data?: Iauthor15) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): author15 {
        let result = new author15();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

interface Iauthor15 {
    date?: string;
    email?: string;
    name?: string;
}

class committer12 implements Icommitter12 {
    date?: string;
    email?: string;
    name?: string;

    constructor(data?: Icommitter12) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): committer12 {
        let result = new committer12();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

interface Icommitter12 {
    date?: string;
    email?: string;
    name?: string;
}

class tree7 implements Itree7 {
    sha?: string;
    url?: string;

    constructor(data?: Itree7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): tree7 {
        let result = new tree7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

interface Itree7 {
    sha?: string;
    url?: string;
}

class owner7 implements Iowner7 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iowner7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): owner7 {
        let result = new owner7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iowner7 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class File1Txt implements IFile1Txt {
    content?: string;

    constructor(data?: IFile1Txt) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["content"];
        }
    }

    static fromJS(data: any): File1Txt {
        let result = new File1Txt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["content"] = this.content;
        return data; 
    }
}

interface IFile1Txt {
    content?: string;
}

class New_fileTxt implements INew_fileTxt {
    content?: string;

    constructor(data?: INew_fileTxt) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["content"];
        }
    }

    static fromJS(data: any): New_fileTxt {
        let result = new New_fileTxt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["content"] = this.content;
        return data; 
    }
}

interface INew_fileTxt {
    content?: string;
}

class Old_nameTxt implements IOld_nameTxt {
    content?: string;
    filename?: string;

    constructor(data?: IOld_nameTxt) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["content"];
            this.filename = data["filename"];
        }
    }

    static fromJS(data: any): Old_nameTxt {
        let result = new Old_nameTxt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["content"] = this.content;
        data["filename"] = this.filename;
        return data; 
    }
}

interface IOld_nameTxt {
    content?: string;
    filename?: string;
}

class file1Txt implements Ifile1Txt {
    content?: string;

    constructor(data?: Ifile1Txt) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["content"];
        }
    }

    static fromJS(data: any): file1Txt {
        let result = new file1Txt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["content"] = this.content;
        return data; 
    }
}

interface Ifile1Txt {
    content?: string;
}

class Comments implements IComments {
    href?: string;

    constructor(data?: IComments) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): Comments {
        let result = new Comments();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

interface IComments {
    href?: string;
}

class Html implements IHtml {
    href?: string;

    constructor(data?: IHtml) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): Html {
        let result = new Html();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

interface IHtml {
    href?: string;
}

class Review_comments implements IReview_comments {
    href?: string;

    constructor(data?: IReview_comments) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): Review_comments {
        let result = new Review_comments();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

interface IReview_comments {
    href?: string;
}

class Self implements ISelf {
    href?: string;

    constructor(data?: ISelf) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): Self {
        let result = new Self();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

interface ISelf {
    href?: string;
}

class repo2 implements Irepo2 {
    clone_url?: string;
    created_at?: string;
    description?: string;
    fork?: boolean;
    forks?: number;
    forks_count?: number;
    full_name?: string;
    git_url?: string;
    homepage?: string;
    html_url?: string;
    id?: number;
    language?: language;
    master_branch?: string;
    mirror_url?: string;
    name?: string;
    open_issues?: number;
    open_issues_count?: number;
    owner?: owner11;
    private?: boolean;
    pushed_at?: string;
    size?: number;
    ssh_url?: string;
    svn_url?: string;
    updated_at?: string;
    url?: string;
    watchers?: number;
    watchers_count?: number;

    constructor(data?: Irepo2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clone_url = data["clone_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.forks_count = data["forks_count"];
            this.full_name = data["full_name"];
            this.git_url = data["git_url"];
            this.homepage = data["homepage"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.language = data["language"];
            this.master_branch = data["master_branch"];
            this.mirror_url = data["mirror_url"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.open_issues_count = data["open_issues_count"];
            this.owner = data["owner"] ? owner11.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.pushed_at = data["pushed_at"];
            this.size = data["size"];
            this.ssh_url = data["ssh_url"];
            this.svn_url = data["svn_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.watchers = data["watchers"];
            this.watchers_count = data["watchers_count"];
        }
    }

    static fromJS(data: any): repo2 {
        let result = new repo2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["clone_url"] = this.clone_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["forks_count"] = this.forks_count;
        data["full_name"] = this.full_name;
        data["git_url"] = this.git_url;
        data["homepage"] = this.homepage;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["language"] = this.language;
        data["master_branch"] = this.master_branch;
        data["mirror_url"] = this.mirror_url;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["open_issues_count"] = this.open_issues_count;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pushed_at"] = this.pushed_at;
        data["size"] = this.size;
        data["ssh_url"] = this.ssh_url;
        data["svn_url"] = this.svn_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["watchers"] = this.watchers;
        data["watchers_count"] = this.watchers_count;
        return data; 
    }
}

interface Irepo2 {
    clone_url?: string;
    created_at?: string;
    description?: string;
    fork?: boolean;
    forks?: number;
    forks_count?: number;
    full_name?: string;
    git_url?: string;
    homepage?: string;
    html_url?: string;
    id?: number;
    language?: language;
    master_branch?: string;
    mirror_url?: string;
    name?: string;
    open_issues?: number;
    open_issues_count?: number;
    owner?: owner11;
    private?: boolean;
    pushed_at?: string;
    size?: number;
    ssh_url?: string;
    svn_url?: string;
    updated_at?: string;
    url?: string;
    watchers?: number;
    watchers_count?: number;
}

class user17 implements Iuser17 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iuser17) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): user17 {
        let result = new user17();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iuser17 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class repo3 implements Irepo3 {
    clone_url?: string;
    created_at?: string;
    description?: string;
    fork?: boolean;
    forks?: number;
    forks_count?: number;
    full_name?: string;
    git_url?: string;
    homepage?: string;
    html_url?: string;
    id?: number;
    language?: language2;
    master_branch?: string;
    mirror_url?: string;
    name?: string;
    open_issues?: number;
    open_issues_count?: number;
    owner?: owner12;
    private?: boolean;
    pushed_at?: string;
    size?: number;
    ssh_url?: string;
    svn_url?: string;
    updated_at?: string;
    url?: string;
    watchers?: number;
    watchers_count?: number;

    constructor(data?: Irepo3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clone_url = data["clone_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.forks_count = data["forks_count"];
            this.full_name = data["full_name"];
            this.git_url = data["git_url"];
            this.homepage = data["homepage"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.language = data["language"];
            this.master_branch = data["master_branch"];
            this.mirror_url = data["mirror_url"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.open_issues_count = data["open_issues_count"];
            this.owner = data["owner"] ? owner12.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.pushed_at = data["pushed_at"];
            this.size = data["size"];
            this.ssh_url = data["ssh_url"];
            this.svn_url = data["svn_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.watchers = data["watchers"];
            this.watchers_count = data["watchers_count"];
        }
    }

    static fromJS(data: any): repo3 {
        let result = new repo3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["clone_url"] = this.clone_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["forks_count"] = this.forks_count;
        data["full_name"] = this.full_name;
        data["git_url"] = this.git_url;
        data["homepage"] = this.homepage;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["language"] = this.language;
        data["master_branch"] = this.master_branch;
        data["mirror_url"] = this.mirror_url;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["open_issues_count"] = this.open_issues_count;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pushed_at"] = this.pushed_at;
        data["size"] = this.size;
        data["ssh_url"] = this.ssh_url;
        data["svn_url"] = this.svn_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["watchers"] = this.watchers;
        data["watchers_count"] = this.watchers_count;
        return data; 
    }
}

interface Irepo3 {
    clone_url?: string;
    created_at?: string;
    description?: string;
    fork?: boolean;
    forks?: number;
    forks_count?: number;
    full_name?: string;
    git_url?: string;
    homepage?: string;
    html_url?: string;
    id?: number;
    language?: language2;
    master_branch?: string;
    mirror_url?: string;
    name?: string;
    open_issues?: number;
    open_issues_count?: number;
    owner?: owner12;
    private?: boolean;
    pushed_at?: string;
    size?: number;
    ssh_url?: string;
    svn_url?: string;
    updated_at?: string;
    url?: string;
    watchers?: number;
    watchers_count?: number;
}

class user18 implements Iuser18 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iuser18) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): user18 {
        let result = new user18();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iuser18 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class html implements Ihtml {
    href?: string;

    constructor(data?: Ihtml) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): html {
        let result = new html();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

interface Ihtml {
    href?: string;
}

class pull_request2 implements Ipull_request2 {
    href?: string;

    constructor(data?: Ipull_request2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): pull_request2 {
        let result = new pull_request2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

interface Ipull_request2 {
    href?: string;
}

class self implements Iself {
    href?: string;

    constructor(data?: Iself) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): self {
        let result = new self();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

interface Iself {
    href?: string;
}

class uploader2 implements Iuploader2 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    site_admin?: boolean;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;

    constructor(data?: Iuploader2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.site_admin = data["site_admin"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): uploader2 {
        let result = new uploader2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["site_admin"] = this.site_admin;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface Iuploader2 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    site_admin?: boolean;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;
}

class owner8 implements Iowner8 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iowner8) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): owner8 {
        let result = new owner8();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iowner8 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class owner9 implements Iowner9 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iowner9) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): owner9 {
        let result = new owner9();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iowner9 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class repository implements Irepository {
    archive_url?: string;
    assignees_url?: string;
    blobs_url?: string;
    branches_url?: string;
    collaborators_url?: string;
    comments_url?: string;
    commits_url?: string;
    compare_url?: string;
    contents_url?: string;
    contributors_url?: string;
    description?: string;
    downloads_url?: string;
    events_url?: string;
    fork?: boolean;
    forks_url?: string;
    full_name?: string;
    git_commits_url?: string;
    git_refs_url?: string;
    git_tags_url?: string;
    hooks_url?: string;
    html_url?: string;
    id?: number;
    issue_comment_url?: string;
    issue_events_url?: string;
    issues_url?: string;
    keys_url?: string;
    labels_url?: string;
    languages_url?: string;
    merges_url?: string;
    milestones_url?: string;
    name?: string;
    notifications_url?: string;
    owner?: owner13;
    private?: boolean;
    pulls_url?: string;
    stargazers_url?: string;
    statuses_url?: string;
    subscribers_url?: string;
    subscription_url?: string;
    tags_url?: string;
    teams_url?: string;
    trees_url?: string;
    url?: string;

    constructor(data?: Irepository) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.archive_url = data["archive_url"];
            this.assignees_url = data["assignees_url"];
            this.blobs_url = data["blobs_url"];
            this.branches_url = data["branches_url"];
            this.collaborators_url = data["collaborators_url"];
            this.comments_url = data["comments_url"];
            this.commits_url = data["commits_url"];
            this.compare_url = data["compare_url"];
            this.contents_url = data["contents_url"];
            this.contributors_url = data["contributors_url"];
            this.description = data["description"];
            this.downloads_url = data["downloads_url"];
            this.events_url = data["events_url"];
            this.fork = data["fork"];
            this.forks_url = data["forks_url"];
            this.full_name = data["full_name"];
            this.git_commits_url = data["git_commits_url"];
            this.git_refs_url = data["git_refs_url"];
            this.git_tags_url = data["git_tags_url"];
            this.hooks_url = data["hooks_url"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.issue_comment_url = data["issue_comment_url"];
            this.issue_events_url = data["issue_events_url"];
            this.issues_url = data["issues_url"];
            this.keys_url = data["keys_url"];
            this.labels_url = data["labels_url"];
            this.languages_url = data["languages_url"];
            this.merges_url = data["merges_url"];
            this.milestones_url = data["milestones_url"];
            this.name = data["name"];
            this.notifications_url = data["notifications_url"];
            this.owner = data["owner"] ? owner13.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.pulls_url = data["pulls_url"];
            this.stargazers_url = data["stargazers_url"];
            this.statuses_url = data["statuses_url"];
            this.subscribers_url = data["subscribers_url"];
            this.subscription_url = data["subscription_url"];
            this.tags_url = data["tags_url"];
            this.teams_url = data["teams_url"];
            this.trees_url = data["trees_url"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): repository {
        let result = new repository();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["archive_url"] = this.archive_url;
        data["assignees_url"] = this.assignees_url;
        data["blobs_url"] = this.blobs_url;
        data["branches_url"] = this.branches_url;
        data["collaborators_url"] = this.collaborators_url;
        data["comments_url"] = this.comments_url;
        data["commits_url"] = this.commits_url;
        data["compare_url"] = this.compare_url;
        data["contents_url"] = this.contents_url;
        data["contributors_url"] = this.contributors_url;
        data["description"] = this.description;
        data["downloads_url"] = this.downloads_url;
        data["events_url"] = this.events_url;
        data["fork"] = this.fork;
        data["forks_url"] = this.forks_url;
        data["full_name"] = this.full_name;
        data["git_commits_url"] = this.git_commits_url;
        data["git_refs_url"] = this.git_refs_url;
        data["git_tags_url"] = this.git_tags_url;
        data["hooks_url"] = this.hooks_url;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["issue_comment_url"] = this.issue_comment_url;
        data["issue_events_url"] = this.issue_events_url;
        data["issues_url"] = this.issues_url;
        data["keys_url"] = this.keys_url;
        data["labels_url"] = this.labels_url;
        data["languages_url"] = this.languages_url;
        data["merges_url"] = this.merges_url;
        data["milestones_url"] = this.milestones_url;
        data["name"] = this.name;
        data["notifications_url"] = this.notifications_url;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pulls_url"] = this.pulls_url;
        data["stargazers_url"] = this.stargazers_url;
        data["statuses_url"] = this.statuses_url;
        data["subscribers_url"] = this.subscribers_url;
        data["subscription_url"] = this.subscription_url;
        data["tags_url"] = this.tags_url;
        data["teams_url"] = this.teams_url;
        data["trees_url"] = this.trees_url;
        data["url"] = this.url;
        return data; 
    }
}

interface Irepository {
    archive_url?: string;
    assignees_url?: string;
    blobs_url?: string;
    branches_url?: string;
    collaborators_url?: string;
    comments_url?: string;
    commits_url?: string;
    compare_url?: string;
    contents_url?: string;
    contributors_url?: string;
    description?: string;
    downloads_url?: string;
    events_url?: string;
    fork?: boolean;
    forks_url?: string;
    full_name?: string;
    git_commits_url?: string;
    git_refs_url?: string;
    git_tags_url?: string;
    hooks_url?: string;
    html_url?: string;
    id?: number;
    issue_comment_url?: string;
    issue_events_url?: string;
    issues_url?: string;
    keys_url?: string;
    labels_url?: string;
    languages_url?: string;
    merges_url?: string;
    milestones_url?: string;
    name?: string;
    notifications_url?: string;
    owner?: owner13;
    private?: boolean;
    pulls_url?: string;
    stargazers_url?: string;
    statuses_url?: string;
    subscribers_url?: string;
    subscription_url?: string;
    tags_url?: string;
    teams_url?: string;
    trees_url?: string;
    url?: string;
}

class assignee2 implements Iassignee2 {

    constructor(data?: Iassignee2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): assignee2 {
        let result = new assignee2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        return data; 
    }
}

interface Iassignee2 {
}

class Closed_at implements IClosed_at {

    constructor(data?: IClosed_at) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): Closed_at {
        let result = new Closed_at();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        return data; 
    }
}

interface IClosed_at {
}

class labels2 implements Ilabels2 {
    color?: string;
    name?: string;
    url?: string;

    constructor(data?: Ilabels2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.color = data["color"];
            this.name = data["name"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): labels2 {
        let result = new labels2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["color"] = this.color;
        data["name"] = this.name;
        data["url"] = this.url;
        return data; 
    }
}

interface Ilabels2 {
    color?: string;
    name?: string;
    url?: string;
}

class milestone3 implements Imilestone3 {

    constructor(data?: Imilestone3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): milestone3 {
        let result = new milestone3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        return data; 
    }
}

interface Imilestone3 {
}

class pull_request3 implements Ipull_request3 {
    diff_url?: Diff_url;
    html_url?: Html_url;
    patch_url?: Patch_url;

    constructor(data?: Ipull_request3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.diff_url = data["diff_url"];
            this.html_url = data["html_url"];
            this.patch_url = data["patch_url"];
        }
    }

    static fromJS(data: any): pull_request3 {
        let result = new pull_request3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["diff_url"] = this.diff_url;
        data["html_url"] = this.html_url;
        data["patch_url"] = this.patch_url;
        return data; 
    }
}

interface Ipull_request3 {
    diff_url?: Diff_url;
    html_url?: Html_url;
    patch_url?: Patch_url;
}

class user19 implements Iuser19 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;

    constructor(data?: Iuser19) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): user19 {
        let result = new user19();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface Iuser19 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;
}

class owner10 implements Iowner10 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    received_events_url?: string;
    type?: string;
    url?: string;

    constructor(data?: Iowner10) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.received_events_url = data["received_events_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): owner10 {
        let result = new owner10();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["received_events_url"] = this.received_events_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface Iowner10 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    received_events_url?: string;
    type?: string;
    url?: string;
}

enum Tree3Mode {
    _100644 = <any>"100644", 
    _100755 = <any>"100755", 
    _040000 = <any>"040000", 
    _160000 = <any>"160000", 
    _120000 = <any>"120000", 
}

enum Tree3Type {
    Blob = <any>"blob", 
    Tree = <any>"tree", 
    Commit = <any>"commit", 
}

class ringErl implements IringErl {
    filename?: string;
    raw_url?: string;
    size?: number;

    constructor(data?: IringErl) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filename = data["filename"];
            this.raw_url = data["raw_url"];
            this.size = data["size"];
        }
    }

    static fromJS(data: any): ringErl {
        let result = new ringErl();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["filename"] = this.filename;
        data["raw_url"] = this.raw_url;
        data["size"] = this.size;
        return data; 
    }
}

interface IringErl {
    filename?: string;
    raw_url?: string;
    size?: number;
}

class creator5 implements Icreator5 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Icreator5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): creator5 {
        let result = new creator5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Icreator5 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

enum milestoneState {
    Open = <any>"open", 
    Closed = <any>"closed", 
}

class author16 implements Iauthor16 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string;
    email?: string;
    name?: string;

    constructor(data?: Iauthor16) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): author16 {
        let result = new author16();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

interface Iauthor16 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string;
    email?: string;
    name?: string;
}

class committer13 implements Icommitter13 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string;
    email?: string;
    name?: string;

    constructor(data?: Icommitter13) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): committer13 {
        let result = new committer13();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

interface Icommitter13 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string;
    email?: string;
    name?: string;
}

class tree8 implements Itree8 {
    sha?: string;
    url?: string;

    constructor(data?: Itree8) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): tree8 {
        let result = new tree8();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

interface Itree8 {
    sha?: string;
    url?: string;
}

class html2 implements Ihtml2 {
    href?: string;

    constructor(data?: Ihtml2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): html2 {
        let result = new html2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

interface Ihtml2 {
    href?: string;
}

class pull_request4 implements Ipull_request4 {
    href?: string;

    constructor(data?: Ipull_request4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): pull_request4 {
        let result = new pull_request4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

interface Ipull_request4 {
    href?: string;
}

class self2 implements Iself2 {
    href?: string;

    constructor(data?: Iself2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): self2 {
        let result = new self2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

interface Iself2 {
    href?: string;
}

class comments implements Icomments {
    href?: string;

    constructor(data?: Icomments) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): comments {
        let result = new comments();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

interface Icomments {
    href?: string;
}

class html3 implements Ihtml3 {
    href?: string;

    constructor(data?: Ihtml3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): html3 {
        let result = new html3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

interface Ihtml3 {
    href?: string;
}

class review_comments implements Ireview_comments {
    href?: string;

    constructor(data?: Ireview_comments) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): review_comments {
        let result = new review_comments();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

interface Ireview_comments {
    href?: string;
}

class self3 implements Iself3 {
    href?: string;

    constructor(data?: Iself3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): self3 {
        let result = new self3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

interface Iself3 {
    href?: string;
}

class repo4 implements Irepo4 {
    clone_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    description?: string;
    fork?: boolean;
    forks?: number;
    forks_count?: number;
    full_name?: string;
    git_url?: string;
    homepage?: string;
    html_url?: string;
    id?: number;
    language?: string;
    master_branch?: string;
    mirror_url?: string;
    name?: string;
    open_issues?: number;
    open_issues_count?: number;
    owner?: owner14;
    private?: boolean;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string;
    size?: number;
    ssh_url?: string;
    svn_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    watchers?: number;
    watchers_count?: number;

    constructor(data?: Irepo4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clone_url = data["clone_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.forks_count = data["forks_count"];
            this.full_name = data["full_name"];
            this.git_url = data["git_url"];
            this.homepage = data["homepage"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.language = data["language"];
            this.master_branch = data["master_branch"];
            this.mirror_url = data["mirror_url"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.open_issues_count = data["open_issues_count"];
            this.owner = data["owner"] ? owner14.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.pushed_at = data["pushed_at"];
            this.size = data["size"];
            this.ssh_url = data["ssh_url"];
            this.svn_url = data["svn_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.watchers = data["watchers"];
            this.watchers_count = data["watchers_count"];
        }
    }

    static fromJS(data: any): repo4 {
        let result = new repo4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["clone_url"] = this.clone_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["forks_count"] = this.forks_count;
        data["full_name"] = this.full_name;
        data["git_url"] = this.git_url;
        data["homepage"] = this.homepage;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["language"] = this.language;
        data["master_branch"] = this.master_branch;
        data["mirror_url"] = this.mirror_url;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["open_issues_count"] = this.open_issues_count;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pushed_at"] = this.pushed_at;
        data["size"] = this.size;
        data["ssh_url"] = this.ssh_url;
        data["svn_url"] = this.svn_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["watchers"] = this.watchers;
        data["watchers_count"] = this.watchers_count;
        return data; 
    }
}

interface Irepo4 {
    clone_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    description?: string;
    fork?: boolean;
    forks?: number;
    forks_count?: number;
    full_name?: string;
    git_url?: string;
    homepage?: string;
    html_url?: string;
    id?: number;
    language?: string;
    master_branch?: string;
    mirror_url?: string;
    name?: string;
    open_issues?: number;
    open_issues_count?: number;
    owner?: owner14;
    private?: boolean;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string;
    size?: number;
    ssh_url?: string;
    svn_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    watchers?: number;
    watchers_count?: number;
}

class user20 implements Iuser20 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iuser20) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): user20 {
        let result = new user20();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iuser20 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class repo5 implements Irepo5 {
    clone_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    description?: string;
    fork?: boolean;
    forks?: number;
    forks_count?: number;
    full_name?: string;
    git_url?: string;
    homepage?: string;
    html_url?: string;
    id?: number;
    language?: string;
    master_branch?: string;
    mirror_url?: string;
    name?: string;
    open_issues?: number;
    open_issues_count?: number;
    owner?: owner15;
    private?: boolean;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string;
    size?: number;
    ssh_url?: string;
    svn_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    watchers?: number;
    watchers_count?: number;

    constructor(data?: Irepo5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clone_url = data["clone_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.forks_count = data["forks_count"];
            this.full_name = data["full_name"];
            this.git_url = data["git_url"];
            this.homepage = data["homepage"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.language = data["language"];
            this.master_branch = data["master_branch"];
            this.mirror_url = data["mirror_url"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.open_issues_count = data["open_issues_count"];
            this.owner = data["owner"] ? owner15.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.pushed_at = data["pushed_at"];
            this.size = data["size"];
            this.ssh_url = data["ssh_url"];
            this.svn_url = data["svn_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.watchers = data["watchers"];
            this.watchers_count = data["watchers_count"];
        }
    }

    static fromJS(data: any): repo5 {
        let result = new repo5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["clone_url"] = this.clone_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["forks_count"] = this.forks_count;
        data["full_name"] = this.full_name;
        data["git_url"] = this.git_url;
        data["homepage"] = this.homepage;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["language"] = this.language;
        data["master_branch"] = this.master_branch;
        data["mirror_url"] = this.mirror_url;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["open_issues_count"] = this.open_issues_count;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pushed_at"] = this.pushed_at;
        data["size"] = this.size;
        data["ssh_url"] = this.ssh_url;
        data["svn_url"] = this.svn_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["watchers"] = this.watchers;
        data["watchers_count"] = this.watchers_count;
        return data; 
    }
}

interface Irepo5 {
    clone_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string;
    description?: string;
    fork?: boolean;
    forks?: number;
    forks_count?: number;
    full_name?: string;
    git_url?: string;
    homepage?: string;
    html_url?: string;
    id?: number;
    language?: string;
    master_branch?: string;
    mirror_url?: string;
    name?: string;
    open_issues?: number;
    open_issues_count?: number;
    owner?: owner15;
    private?: boolean;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string;
    size?: number;
    ssh_url?: string;
    svn_url?: string;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string;
    url?: string;
    watchers?: number;
    watchers_count?: number;
}

class user21 implements Iuser21 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iuser21) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): user21 {
        let result = new user21();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iuser21 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class uploader3 implements Iuploader3 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    site_admin?: boolean;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;

    constructor(data?: Iuploader3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.site_admin = data["site_admin"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): uploader3 {
        let result = new uploader3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["site_admin"] = this.site_admin;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface Iuploader3 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    site_admin?: boolean;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;
}

class author17 implements Iauthor17 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string;
    email?: string;
    name?: string;

    constructor(data?: Iauthor17) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): author17 {
        let result = new author17();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

interface Iauthor17 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string;
    email?: string;
    name?: string;
}

class committer14 implements Icommitter14 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string;
    email?: string;
    name?: string;

    constructor(data?: Icommitter14) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): committer14 {
        let result = new committer14();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

interface Icommitter14 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string;
    email?: string;
    name?: string;
}

class tree9 implements Itree9 {
    sha?: string;
    url?: string;

    constructor(data?: Itree9) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): tree9 {
        let result = new tree9();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

interface Itree9 {
    sha?: string;
    url?: string;
}

class author18 implements Iauthor18 {
    date?: string;
    email?: string;
    name?: string;

    constructor(data?: Iauthor18) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): author18 {
        let result = new author18();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

interface Iauthor18 {
    date?: string;
    email?: string;
    name?: string;
}

class committer15 implements Icommitter15 {
    date?: string;
    email?: string;
    name?: string;

    constructor(data?: Icommitter15) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): committer15 {
        let result = new committer15();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

interface Icommitter15 {
    date?: string;
    email?: string;
    name?: string;
}

class tree10 implements Itree10 {
    sha?: string;
    url?: string;

    constructor(data?: Itree10) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): tree10 {
        let result = new tree10();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

interface Itree10 {
    sha?: string;
    url?: string;
}

class author19 implements Iauthor19 {
    date?: string;
    email?: string;
    name?: string;

    constructor(data?: Iauthor19) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): author19 {
        let result = new author19();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

interface Iauthor19 {
    date?: string;
    email?: string;
    name?: string;
}

class committer16 implements Icommitter16 {
    date?: string;
    email?: string;
    name?: string;

    constructor(data?: Icommitter16) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): committer16 {
        let result = new committer16();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

interface Icommitter16 {
    date?: string;
    email?: string;
    name?: string;
}

class tree11 implements Itree11 {
    sha?: string;
    url?: string;

    constructor(data?: Itree11) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): tree11 {
        let result = new tree11();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

interface Itree11 {
    sha?: string;
    url?: string;
}

class creator6 implements Icreator6 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Icreator6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): creator6 {
        let result = new creator6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Icreator6 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

enum Milestone2State {
    Open = <any>"open", 
    Closed = <any>"closed", 
}

class language implements Ilanguage {

    constructor(data?: Ilanguage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): language {
        let result = new language();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        return data; 
    }
}

interface Ilanguage {
}

class owner11 implements Iowner11 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iowner11) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): owner11 {
        let result = new owner11();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iowner11 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class language2 implements Ilanguage2 {

    constructor(data?: Ilanguage2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): language2 {
        let result = new language2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        return data; 
    }
}

interface Ilanguage2 {
}

class owner12 implements Iowner12 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iowner12) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): owner12 {
        let result = new owner12();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iowner12 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class owner13 implements Iowner13 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;

    constructor(data?: Iowner13) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): owner13 {
        let result = new owner13();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

interface Iowner13 {
    avatar_url?: string;
    events_url?: string;
    followers_url?: string;
    following_url?: string;
    gists_url?: string;
    gravatar_id?: string;
    html_url?: string;
    id?: number;
    login?: string;
    organizations_url?: string;
    received_events_url?: string;
    repos_url?: string;
    starred_url?: string;
    subscriptions_url?: string;
    type?: string;
    url?: string;
}

class Diff_url implements IDiff_url {

    constructor(data?: IDiff_url) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): Diff_url {
        let result = new Diff_url();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        return data; 
    }
}

interface IDiff_url {
}

class Html_url implements IHtml_url {

    constructor(data?: IHtml_url) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): Html_url {
        let result = new Html_url();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        return data; 
    }
}

interface IHtml_url {
}

class Patch_url implements IPatch_url {

    constructor(data?: IPatch_url) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): Patch_url {
        let result = new Patch_url();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        return data; 
    }
}

interface IPatch_url {
}

class owner14 implements Iowner14 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iowner14) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): owner14 {
        let result = new owner14();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iowner14 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class owner15 implements Iowner15 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;

    constructor(data?: Iowner15) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): owner15 {
        let result = new owner15();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = data ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

interface Iowner15 {
    avatar_url?: string;
    gravatar_id?: string;
    id?: number;
    login?: string;
    url?: string;
}

class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    result: any; 

    constructor(message: string, status: number, response: string, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.result = result;
    }
}

function throwException(message: string, status: number, response: string, result?: any): any {
    if(result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, null);
}